#![allow(dead_code, non_camel_case_types, non_upper_case_globals, non_snake_case)]

#[cfg(target_os = "windows")]
extern crate winapi;

#[cfg(debug_assertions)]
use std::fmt;
use std::default::Default;
use std::mem::{transmute, zeroed};
use std::os::raw::{
    c_char, c_int, c_long, c_longlong, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
};

pub type ptrdiff_t = isize;
pub type size_t = usize;
pub type wchar_t = c_int;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: c_longlong,
    pub __clang_max_align_nonce2: f64,
}

impl Default for max_align_t {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

pub type int8_t = i8;
pub type int16_t = i16;
pub type int32_t = i32;
pub type int64_t = i64;
pub type uint8_t = u8;
pub type uint16_t = u16;
pub type uint32_t = u32;
pub type uint64_t = u64;
pub type int_least8_t = c_char;
pub type int_least16_t = c_short;
pub type int_least32_t = c_int;
pub type int_least64_t = c_long;
pub type uint_least8_t = c_uchar;
pub type uint_least16_t = c_ushort;
pub type uint_least32_t = c_uint;
pub type uint_least64_t = c_ulong;
pub type int_fast8_t = c_char;
pub type int_fast16_t = c_long;
pub type int_fast32_t = c_long;
pub type int_fast64_t = c_long;
pub type uint_fast8_t = c_uchar;
pub type uint_fast16_t = c_ulong;
pub type uint_fast32_t = c_ulong;
pub type uint_fast64_t = c_ulong;
pub type intptr_t = isize;
pub type uintptr_t = usize;
pub type intmax_t = c_long;
pub type uintmax_t = c_ulong;
pub type VkFlags = uint32_t;
pub type VkBool32 = uint32_t;
pub type VkDeviceSize = uint64_t;
pub type VkSampleMask = uint32_t;

pub enum VkInstance_T {}

pub type VkInstance = *mut VkInstance_T;

pub enum VkPhysicalDevice_T {}

pub type VkPhysicalDevice = *mut VkPhysicalDevice_T;

pub enum VkDevice_T {}

pub type VkDevice = *mut VkDevice_T;

pub enum VkQueue_T {}

pub type VkQueue = *mut VkQueue_T;

pub enum VkSemaphore_T {}

pub type VkSemaphore = *mut VkSemaphore_T;

pub enum VkCommandBuffer_T {}

pub type VkCommandBuffer = *mut VkCommandBuffer_T;

pub enum VkFence_T {}

pub type VkFence = *mut VkFence_T;

pub enum VkDeviceMemory_T {}

pub type VkDeviceMemory = *mut VkDeviceMemory_T;

pub enum VkBuffer_T {}

pub type VkBuffer = *mut VkBuffer_T;

pub enum VkImage_T {}

pub type VkImage = *mut VkImage_T;

pub enum VkEvent_T {}

pub type VkEvent = *mut VkEvent_T;

pub enum VkQueryPool_T {}

pub type VkQueryPool = *mut VkQueryPool_T;

pub enum VkBufferView_T {}

pub type VkBufferView = *mut VkBufferView_T;

pub enum VkImageView_T {}

pub type VkImageView = *mut VkImageView_T;

pub enum VkShaderModule_T {}

pub type VkShaderModule = *mut VkShaderModule_T;

pub enum VkPipelineCache_T {}

pub type VkPipelineCache = *mut VkPipelineCache_T;

pub enum VkPipelineLayout_T {}

pub type VkPipelineLayout = *mut VkPipelineLayout_T;

pub enum VkRenderPass_T {}

pub type VkRenderPass = *mut VkRenderPass_T;

pub enum VkPipeline_T {}

pub type VkPipeline = *mut VkPipeline_T;

pub enum VkDescriptorSetLayout_T {}

pub type VkDescriptorSetLayout = *mut VkDescriptorSetLayout_T;

pub enum VkSampler_T {}

pub type VkSampler = *mut VkSampler_T;

pub enum VkDescriptorPool_T {}

pub type VkDescriptorPool = *mut VkDescriptorPool_T;

pub enum VkDescriptorSet_T {}

pub type VkDescriptorSet = *mut VkDescriptorSet_T;

pub enum VkFramebuffer_T {}

pub type VkFramebuffer = *mut VkFramebuffer_T;

pub enum VkCommandPool_T {}

pub type VkCommandPool = *mut VkCommandPool_T;

pub const VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE: VkPipelineCacheHeaderVersion =
    VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
pub const VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE: VkPipelineCacheHeaderVersion =
    VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
pub const VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE: VkPipelineCacheHeaderVersion =
    VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;

pub const VK_QUEUE_FAMILY_IGNORED: u32 = !0u32;

pub const VK_TRUE: VkBool32 = 1;
pub const VK_FALSE: VkBool32 = 0;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 2147483647,
}

pub const VK_RESULT_BEGIN_RANGE: VkResult = VkResult::VK_ERROR_FORMAT_NOT_SUPPORTED;
pub const VK_RESULT_END_RANGE: VkResult = VkResult::VK_INCOMPLETE;

#[derive(Copy, Clone, Debug)]
#[repr(i32)]
pub enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_ERROR_NOT_PERMITTED_EXT = -1000174001,
    VK_RESULT_RANGE_SIZE = 17,
    VK_RESULT_MAX_ENUM = 2147483647,
}

pub const VK_STRUCTURE_TYPE_BEGIN_RANGE: VkStructureType =
    VkStructureType::VK_STRUCTURE_TYPE_APPLICATION_INFO;
pub const VK_STRUCTURE_TYPE_END_RANGE: VkStructureType =
    VkStructureType::VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_RANGE_SIZE = 49,
    VK_STRUCTURE_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE: VkSystemAllocationScope =
    VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_COMMAND;
pub const VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE: VkSystemAllocationScope =
    VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = 5,
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 2147483647,
}

pub const VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE: VkInternalAllocationType =
    VkInternalAllocationType::VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
pub const VK_INTERNAL_ALLOCATION_TYPE_END_RANGE: VkInternalAllocationType =
    VkInternalAllocationType::VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = 1,
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_FORMAT_BEGIN_RANGE: VkFormat = VkFormat::VK_FORMAT_UNDEFINED;
pub const VK_FORMAT_END_RANGE: VkFormat = VkFormat::VK_FORMAT_ASTC_12x12_SRGB_BLOCK;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_RANGE_SIZE = 185,
    VK_FORMAT_MAX_ENUM = 2147483647,
}

pub const VK_IMAGE_TYPE_BEGIN_RANGE: VkImageType = VkImageType::VK_IMAGE_TYPE_1D;
pub const VK_IMAGE_TYPE_END_RANGE: VkImageType = VkImageType::VK_IMAGE_TYPE_3D;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_RANGE_SIZE = 3,
    VK_IMAGE_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_IMAGE_TILING_BEGIN_RANGE: VkImageTiling = VkImageTiling::VK_IMAGE_TILING_OPTIMAL;
pub const VK_IMAGE_TILING_END_RANGE: VkImageTiling = VkImageTiling::VK_IMAGE_TILING_LINEAR;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_RANGE_SIZE = 2,
    VK_IMAGE_TILING_MAX_ENUM = 2147483647,
}

pub const VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE: VkPhysicalDeviceType =
    VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_OTHER;
pub const VK_PHYSICAL_DEVICE_TYPE_END_RANGE: VkPhysicalDeviceType =
    VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_CPU;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = 5,
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_QUERY_TYPE_BEGIN_RANGE: VkQueryType = VkQueryType::VK_QUERY_TYPE_OCCLUSION;
pub const VK_QUERY_TYPE_END_RANGE: VkQueryType = VkQueryType::VK_QUERY_TYPE_TIMESTAMP;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_RANGE_SIZE = 3,
    VK_QUERY_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_SHARING_MODE_BEGIN_RANGE: VkSharingMode = VkSharingMode::VK_SHARING_MODE_EXCLUSIVE;
pub const VK_SHARING_MODE_END_RANGE: VkSharingMode = VkSharingMode::VK_SHARING_MODE_CONCURRENT;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_RANGE_SIZE = 2,
    VK_SHARING_MODE_MAX_ENUM = 2147483647,
}

pub const VK_IMAGE_LAYOUT_BEGIN_RANGE: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED;
pub const VK_IMAGE_LAYOUT_END_RANGE: VkImageLayout = VkImageLayout::VK_IMAGE_LAYOUT_PREINITIALIZED;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_RANGE_SIZE = 9,
    VK_IMAGE_LAYOUT_MAX_ENUM = 2147483647,
}

pub const VK_IMAGE_VIEW_TYPE_BEGIN_RANGE: VkImageViewType = VkImageViewType::VK_IMAGE_VIEW_TYPE_1D;
pub const VK_IMAGE_VIEW_TYPE_END_RANGE: VkImageViewType =
    VkImageViewType::VK_IMAGE_VIEW_TYPE_CUBE_ARRAY;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_RANGE_SIZE = 7,
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_COMPONENT_SWIZZLE_BEGIN_RANGE: VkComponentSwizzle =
    VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;
pub const VK_COMPONENT_SWIZZLE_END_RANGE: VkComponentSwizzle =
    VkComponentSwizzle::VK_COMPONENT_SWIZZLE_A;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_RANGE_SIZE = 7,
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 2147483647,
}

pub const VK_VERTEX_INPUT_RATE_BEGIN_RANGE: VkVertexInputRate =
    VkVertexInputRate::VK_VERTEX_INPUT_RATE_VERTEX;
pub const VK_VERTEX_INPUT_RATE_END_RANGE: VkVertexInputRate =
    VkVertexInputRate::VK_VERTEX_INPUT_RATE_INSTANCE;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_RANGE_SIZE = 2,
    VK_VERTEX_INPUT_RATE_MAX_ENUM = 2147483647,
}

pub const VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE: VkPrimitiveTopology =
    VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_POINT_LIST;
pub const VK_PRIMITIVE_TOPOLOGY_END_RANGE: VkPrimitiveTopology =
    VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_PATCH_LIST;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = 11,
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 2147483647,
}

pub const VK_POLYGON_MODE_BEGIN_RANGE: VkPolygonMode = VkPolygonMode::VK_POLYGON_MODE_FILL;
pub const VK_POLYGON_MODE_END_RANGE: VkPolygonMode = VkPolygonMode::VK_POLYGON_MODE_POINT;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_RANGE_SIZE = 3,
    VK_POLYGON_MODE_MAX_ENUM = 2147483647,
}

pub const VK_FRONT_FACE_BEGIN_RANGE: VkFrontFace = VkFrontFace::VK_FRONT_FACE_COUNTER_CLOCKWISE;
pub const VK_FRONT_FACE_END_RANGE: VkFrontFace = VkFrontFace::VK_FRONT_FACE_CLOCKWISE;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_RANGE_SIZE = 2,
    VK_FRONT_FACE_MAX_ENUM = 2147483647,
}

pub const VK_COMPARE_OP_BEGIN_RANGE: VkCompareOp = VkCompareOp::VK_COMPARE_OP_NEVER;
pub const VK_COMPARE_OP_END_RANGE: VkCompareOp = VkCompareOp::VK_COMPARE_OP_ALWAYS;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_RANGE_SIZE = 8,
    VK_COMPARE_OP_MAX_ENUM = 2147483647,
}

pub const VK_STENCIL_OP_BEGIN_RANGE: VkStencilOp = VkStencilOp::VK_STENCIL_OP_KEEP;
pub const VK_STENCIL_OP_END_RANGE: VkStencilOp = VkStencilOp::VK_STENCIL_OP_DECREMENT_AND_WRAP;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_RANGE_SIZE = 8,
    VK_STENCIL_OP_MAX_ENUM = 2147483647,
}

pub const VK_LOGIC_OP_BEGIN_RANGE: VkLogicOp = VkLogicOp::VK_LOGIC_OP_CLEAR;
pub const VK_LOGIC_OP_END_RANGE: VkLogicOp = VkLogicOp::VK_LOGIC_OP_SET;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_RANGE_SIZE = 16,
    VK_LOGIC_OP_MAX_ENUM = 2147483647,
}

pub const VK_BLEND_FACTOR_BEGIN_RANGE: VkBlendFactor = VkBlendFactor::VK_BLEND_FACTOR_ZERO;
pub const VK_BLEND_FACTOR_END_RANGE: VkBlendFactor =
    VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_RANGE_SIZE = 19,
    VK_BLEND_FACTOR_MAX_ENUM = 2147483647,
}

pub const VK_BLEND_OP_BEGIN_RANGE: VkBlendOp = VkBlendOp::VK_BLEND_OP_ADD;
pub const VK_BLEND_OP_END_RANGE: VkBlendOp = VkBlendOp::VK_BLEND_OP_MAX;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_RANGE_SIZE = 5,
    VK_BLEND_OP_MAX_ENUM = 2147483647,
}

pub const VK_DYNAMIC_STATE_BEGIN_RANGE: VkDynamicState = VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT;
pub const VK_DYNAMIC_STATE_END_RANGE: VkDynamicState =
    VkDynamicState::VK_DYNAMIC_STATE_STENCIL_REFERENCE;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_RANGE_SIZE = 9,
    VK_DYNAMIC_STATE_MAX_ENUM = 2147483647,
}

pub const VK_FILTER_BEGIN_RANGE: VkFilter = VkFilter::VK_FILTER_NEAREST;
pub const VK_FILTER_END_RANGE: VkFilter = VkFilter::VK_FILTER_LINEAR;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_RANGE_SIZE = 2,
    VK_FILTER_MAX_ENUM = 2147483647,
}

pub const VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE: VkSamplerMipmapMode =
    VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_NEAREST;
pub const VK_SAMPLER_MIPMAP_MODE_END_RANGE: VkSamplerMipmapMode =
    VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_LINEAR;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = 2,
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 2147483647,
}

pub const VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE: VkSamplerAddressMode =
    VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_REPEAT;
pub const VK_SAMPLER_ADDRESS_MODE_END_RANGE: VkSamplerAddressMode =
    VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
pub const VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE: VkSamplerAddressMode =
    VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 2147483647,
}

pub const VK_BORDER_COLOR_BEGIN_RANGE: VkBorderColor =
    VkBorderColor::VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK;
pub const VK_BORDER_COLOR_END_RANGE: VkBorderColor =
    VkBorderColor::VK_BORDER_COLOR_INT_OPAQUE_WHITE;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_RANGE_SIZE = 6,
    VK_BORDER_COLOR_MAX_ENUM = 2147483647,
}

pub const VK_DESCRIPTOR_TYPE_BEGIN_RANGE: VkDescriptorType =
    VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLER;
pub const VK_DESCRIPTOR_TYPE_END_RANGE: VkDescriptorType =
    VkDescriptorType::VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_RANGE_SIZE = 11,
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE: VkAttachmentLoadOp =
    VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_LOAD;
pub const VK_ATTACHMENT_LOAD_OP_END_RANGE: VkAttachmentLoadOp =
    VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_DONT_CARE;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = 3,
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 2147483647,
}

pub const VK_ATTACHMENT_STORE_OP_BEGIN_RANGE: VkAttachmentStoreOp =
    VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_STORE;
pub const VK_ATTACHMENT_STORE_OP_END_RANGE: VkAttachmentStoreOp =
    VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_RANGE_SIZE = 2,
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 2147483647,
}

pub const VK_PIPELINE_BIND_POINT_BEGIN_RANGE: VkPipelineBindPoint =
    VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS;
pub const VK_PIPELINE_BIND_POINT_END_RANGE: VkPipelineBindPoint =
    VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_COMPUTE;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_RANGE_SIZE = 2,
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 2147483647,
}

pub const VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE: VkCommandBufferLevel =
    VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_PRIMARY;
pub const VK_COMMAND_BUFFER_LEVEL_END_RANGE: VkCommandBufferLevel =
    VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_SECONDARY;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = 2,
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 2147483647,
}

pub const VK_INDEX_TYPE_BEGIN_RANGE: VkIndexType = VkIndexType::VK_INDEX_TYPE_UINT16;
pub const VK_INDEX_TYPE_END_RANGE: VkIndexType = VkIndexType::VK_INDEX_TYPE_UINT32;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_RANGE_SIZE = 2,
    VK_INDEX_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_SUBPASS_CONTENTS_BEGIN_RANGE: VkSubpassContents =
    VkSubpassContents::VK_SUBPASS_CONTENTS_INLINE;
pub const VK_SUBPASS_CONTENTS_END_RANGE: VkSubpassContents =
    VkSubpassContents::VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_RANGE_SIZE = 2,
    VK_SUBPASS_CONTENTS_MAX_ENUM = 2147483647,
}

pub type VkInstanceCreateFlags = VkFlags;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 1,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 2,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 4,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 8,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 16,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 32,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 64,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 128,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 256,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 512,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 1024,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 2048,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 4096,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 8192,
    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkFormatFeatureFlags = VkFlags;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 1,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 2,
    VK_IMAGE_USAGE_SAMPLED_BIT = 4,
    VK_IMAGE_USAGE_STORAGE_BIT = 8,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128,
    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkImageUsageFlags = VkFlags;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 1,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 4,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 8,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 16,
    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkImageCreateFlags = VkFlags;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 1,
    VK_SAMPLE_COUNT_2_BIT = 2,
    VK_SAMPLE_COUNT_4_BIT = 4,
    VK_SAMPLE_COUNT_8_BIT = 8,
    VK_SAMPLE_COUNT_16_BIT = 16,
    VK_SAMPLE_COUNT_32_BIT = 32,
    VK_SAMPLE_COUNT_64_BIT = 64,
    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkSampleCountFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 1,
    VK_QUEUE_COMPUTE_BIT = 2,
    VK_QUEUE_TRANSFER_BIT = 4,
    VK_QUEUE_SPARSE_BINDING_BIT = 8,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkQueueFlags = VkFlags;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 2,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 4,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 8,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 16,
    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkMemoryPropertyFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkMemoryHeapFlags = VkFlags;
pub type VkDeviceCreateFlags = VkFlags;
pub type VkDeviceQueueCreateFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 1,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 2,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 4,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 8,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 16,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 32,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 64,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 128,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 256,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 512,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 1024,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 2048,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 4096,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 8192,
    VK_PIPELINE_STAGE_HOST_BIT = 16384,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 32768,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 65536,
    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkPipelineStageFlags = VkFlags;
pub type VkMemoryMapFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 1,
    VK_IMAGE_ASPECT_DEPTH_BIT = 2,
    VK_IMAGE_ASPECT_STENCIL_BIT = 4,
    VK_IMAGE_ASPECT_METADATA_BIT = 8,
    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkImageAspectFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 1,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 2,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 4,
    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkSparseImageFormatFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 1,
    VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkSparseMemoryBindFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 1,
    VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkFenceCreateFlags = VkFlags;
pub type VkSemaphoreCreateFlags = VkFlags;
pub type VkEventCreateFlags = VkFlags;
pub type VkQueryPoolCreateFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 1,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 2,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 4,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 8,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 16,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 32,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 64,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 128,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 256,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 512,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 1024,
    VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkQueryPipelineStatisticFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 1,
    VK_QUERY_RESULT_WAIT_BIT = 2,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 4,
    VK_QUERY_RESULT_PARTIAL_BIT = 8,
    VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkQueryResultFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 1,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 4,
    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkBufferCreateFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 1,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 2,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 4,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 8,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 16,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 32,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 64,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 128,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 256,
    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkBufferUsageFlags = VkFlags;
pub type VkBufferViewCreateFlags = VkFlags;
pub type VkImageViewCreateFlags = VkFlags;
pub type VkShaderModuleCreateFlags = VkFlags;
pub type VkPipelineCacheCreateFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 1,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 2,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 4,
    VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkPipelineCreateFlags = VkFlags;
pub type VkPipelineShaderStageCreateFlags = VkFlags;

pub const VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM: VkShaderStageFlagBits =
    VkShaderStageFlagBits::VK_SHADER_STAGE_ALL;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 1,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4,
    VK_SHADER_STAGE_GEOMETRY_BIT = 8,
    VK_SHADER_STAGE_FRAGMENT_BIT = 16,
    VK_SHADER_STAGE_COMPUTE_BIT = 32,
    VK_SHADER_STAGE_ALL_GRAPHICS = 31,
    VK_SHADER_STAGE_ALL = 2147483647,
}

pub type VkPipelineVertexInputStateCreateFlags = VkFlags;
pub type VkPipelineInputAssemblyStateCreateFlags = VkFlags;
pub type VkPipelineTessellationStateCreateFlags = VkFlags;
pub type VkPipelineViewportStateCreateFlags = VkFlags;
pub type VkPipelineRasterizationStateCreateFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 1,
    VK_CULL_MODE_BACK_BIT = 2,
    VK_CULL_MODE_FRONT_AND_BACK = 3,
    VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkCullModeFlags = VkFlags;
pub type VkPipelineMultisampleStateCreateFlags = VkFlags;
pub type VkPipelineDepthStencilStateCreateFlags = VkFlags;
pub type VkPipelineColorBlendStateCreateFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 1,
    VK_COLOR_COMPONENT_G_BIT = 2,
    VK_COLOR_COMPONENT_B_BIT = 4,
    VK_COLOR_COMPONENT_A_BIT = 8,
    VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkColorComponentFlags = VkFlags;
pub type VkPipelineDynamicStateCreateFlags = VkFlags;
pub type VkPipelineLayoutCreateFlags = VkFlags;
pub type VkShaderStageFlags = VkFlags;
pub type VkSamplerCreateFlags = VkFlags;
pub type VkDescriptorSetLayoutCreateFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 1,
    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkDescriptorPoolCreateFlags = VkFlags;
pub type VkDescriptorPoolResetFlags = VkFlags;
pub type VkFramebufferCreateFlags = VkFlags;
pub type VkRenderPassCreateFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 1,
    VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkAttachmentDescriptionFlags = VkFlags;
pub type VkSubpassDescriptionFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 1,
    VK_ACCESS_INDEX_READ_BIT = 2,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 4,
    VK_ACCESS_UNIFORM_READ_BIT = 8,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 16,
    VK_ACCESS_SHADER_READ_BIT = 32,
    VK_ACCESS_SHADER_WRITE_BIT = 64,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 128,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 256,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024,
    VK_ACCESS_TRANSFER_READ_BIT = 2048,
    VK_ACCESS_TRANSFER_WRITE_BIT = 4096,
    VK_ACCESS_HOST_READ_BIT = 8192,
    VK_ACCESS_HOST_WRITE_BIT = 16384,
    VK_ACCESS_MEMORY_READ_BIT = 32768,
    VK_ACCESS_MEMORY_WRITE_BIT = 65536,
    VK_ACCESS_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkAccessFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 1,
    VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkDependencyFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 1,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 2,
    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkCommandPoolCreateFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 1,
    VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkCommandPoolResetFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 2,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 4,
    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkCommandBufferUsageFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 1,
    VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkQueryControlFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 1,
    VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkCommandBufferResetFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 1,
    VK_STENCIL_FACE_BACK_BIT = 2,
    VK_STENCIL_FRONT_AND_BACK = 3,
    VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkStencilFaceFlags = VkFlags;
pub type PFN_vkAllocationFunction = unsafe extern "C" fn(
    pUserData: *mut c_void,
    size: size_t,
    alignment: size_t,
    allocationScope: VkSystemAllocationScope,
) -> *mut c_void;
pub type PFN_vkReallocationFunction =
    unsafe extern "C" fn(
        pUserData: *mut c_void,
        pOriginal: *mut c_void,
        size: size_t,
        alignment: size_t,
        allocationScope: VkSystemAllocationScope,
    ) -> *mut c_void;
pub type PFN_vkFreeFunction = unsafe extern "C" fn(pUserData: *mut c_void, pMemory: *mut c_void);
pub type PFN_vkInternalAllocationNotification =
    unsafe extern "C" fn(
        pUserData: *mut c_void,
        size: size_t,
        allocationType: VkInternalAllocationType,
        allocationScope: VkSystemAllocationScope,
    );
pub type PFN_vkInternalFreeNotification =
    unsafe extern "C" fn(
        pUserData: *mut c_void,
        size: size_t,
        allocationType: VkInternalAllocationType,
        allocationScope: VkSystemAllocationScope,
    );
pub type PFN_vkVoidFunction = unsafe extern "C" fn();

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkApplicationInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub pApplicationName: *const c_char,
    pub applicationVersion: uint32_t,
    pub pEngineName: *const c_char,
    pub engineVersion: uint32_t,
    pub apiVersion: uint32_t,
}

impl Default for VkApplicationInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkInstanceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkInstanceCreateFlags,
    pub pApplicationInfo: *const VkApplicationInfo,
    pub enabledLayerCount: uint32_t,
    pub ppEnabledLayerNames: *const *const c_char,
    pub enabledExtensionCount: uint32_t,
    pub ppEnabledExtensionNames: *const *const c_char,
}

impl Default for VkInstanceCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAllocationCallbacks {
    pub pUserData: *mut c_void,
    pub pfnAllocation: PFN_vkAllocationFunction,
    pub pfnReallocation: PFN_vkReallocationFunction,
    pub pfnFree: PFN_vkFreeFunction,
    pub pfnInternalAllocation: PFN_vkInternalAllocationNotification,
    pub pfnInternalFree: PFN_vkInternalFreeNotification,
}

impl Default for VkAllocationCallbacks {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceFeatures {
    pub robustBufferAccess: VkBool32,
    pub fullDrawIndexUint32: VkBool32,
    pub imageCubeArray: VkBool32,
    pub independentBlend: VkBool32,
    pub geometryShader: VkBool32,
    pub tessellationShader: VkBool32,
    pub sampleRateShading: VkBool32,
    pub dualSrcBlend: VkBool32,
    pub logicOp: VkBool32,
    pub multiDrawIndirect: VkBool32,
    pub drawIndirectFirstInstance: VkBool32,
    pub depthClamp: VkBool32,
    pub depthBiasClamp: VkBool32,
    pub fillModeNonSolid: VkBool32,
    pub depthBounds: VkBool32,
    pub wideLines: VkBool32,
    pub largePoints: VkBool32,
    pub alphaToOne: VkBool32,
    pub multiViewport: VkBool32,
    pub samplerAnisotropy: VkBool32,
    pub textureCompressionETC2: VkBool32,
    pub textureCompressionASTC_LDR: VkBool32,
    pub textureCompressionBC: VkBool32,
    pub occlusionQueryPrecise: VkBool32,
    pub pipelineStatisticsQuery: VkBool32,
    pub vertexPipelineStoresAndAtomics: VkBool32,
    pub fragmentStoresAndAtomics: VkBool32,
    pub shaderTessellationAndGeometryPointSize: VkBool32,
    pub shaderImageGatherExtended: VkBool32,
    pub shaderStorageImageExtendedFormats: VkBool32,
    pub shaderStorageImageMultisample: VkBool32,
    pub shaderStorageImageReadWithoutFormat: VkBool32,
    pub shaderStorageImageWriteWithoutFormat: VkBool32,
    pub shaderUniformBufferArrayDynamicIndexing: VkBool32,
    pub shaderSampledImageArrayDynamicIndexing: VkBool32,
    pub shaderStorageBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageImageArrayDynamicIndexing: VkBool32,
    pub shaderClipDistance: VkBool32,
    pub shaderCullDistance: VkBool32,
    pub shaderFloat64: VkBool32,
    pub shaderInt64: VkBool32,
    pub shaderInt16: VkBool32,
    pub shaderResourceResidency: VkBool32,
    pub shaderResourceMinLod: VkBool32,
    pub sparseBinding: VkBool32,
    pub sparseResidencyBuffer: VkBool32,
    pub sparseResidencyImage2D: VkBool32,
    pub sparseResidencyImage3D: VkBool32,
    pub sparseResidency2Samples: VkBool32,
    pub sparseResidency4Samples: VkBool32,
    pub sparseResidency8Samples: VkBool32,
    pub sparseResidency16Samples: VkBool32,
    pub sparseResidencyAliased: VkBool32,
    pub variableMultisampleRate: VkBool32,
    pub inheritedQueries: VkBool32,
}

impl Default for VkPhysicalDeviceFeatures {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkFormatProperties {
    pub linearTilingFeatures: VkFormatFeatureFlags,
    pub optimalTilingFeatures: VkFormatFeatureFlags,
    pub bufferFeatures: VkFormatFeatureFlags,
}

impl Default for VkFormatProperties {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkExtent3D {
    pub width: uint32_t,
    pub height: uint32_t,
    pub depth: uint32_t,
}

impl Default for VkExtent3D {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageFormatProperties {
    pub maxExtent: VkExtent3D,
    pub maxMipLevels: uint32_t,
    pub maxArrayLayers: uint32_t,
    pub sampleCounts: VkSampleCountFlags,
    pub maxResourceSize: VkDeviceSize,
}

impl Default for VkImageFormatProperties {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceLimits {
    pub maxImageDimension1D: uint32_t,
    pub maxImageDimension2D: uint32_t,
    pub maxImageDimension3D: uint32_t,
    pub maxImageDimensionCube: uint32_t,
    pub maxImageArrayLayers: uint32_t,
    pub maxTexelBufferElements: uint32_t,
    pub maxUniformBufferRange: uint32_t,
    pub maxStorageBufferRange: uint32_t,
    pub maxPushConstantsSize: uint32_t,
    pub maxMemoryAllocationCount: uint32_t,
    pub maxSamplerAllocationCount: uint32_t,
    pub bufferImageGranularity: VkDeviceSize,
    pub sparseAddressSpaceSize: VkDeviceSize,
    pub maxBoundDescriptorSets: uint32_t,
    pub maxPerStageDescriptorSamplers: uint32_t,
    pub maxPerStageDescriptorUniformBuffers: uint32_t,
    pub maxPerStageDescriptorStorageBuffers: uint32_t,
    pub maxPerStageDescriptorSampledImages: uint32_t,
    pub maxPerStageDescriptorStorageImages: uint32_t,
    pub maxPerStageDescriptorInputAttachments: uint32_t,
    pub maxPerStageResources: uint32_t,
    pub maxDescriptorSetSamplers: uint32_t,
    pub maxDescriptorSetUniformBuffers: uint32_t,
    pub maxDescriptorSetUniformBuffersDynamic: uint32_t,
    pub maxDescriptorSetStorageBuffers: uint32_t,
    pub maxDescriptorSetStorageBuffersDynamic: uint32_t,
    pub maxDescriptorSetSampledImages: uint32_t,
    pub maxDescriptorSetStorageImages: uint32_t,
    pub maxDescriptorSetInputAttachments: uint32_t,
    pub maxVertexInputAttributes: uint32_t,
    pub maxVertexInputBindings: uint32_t,
    pub maxVertexInputAttributeOffset: uint32_t,
    pub maxVertexInputBindingStride: uint32_t,
    pub maxVertexOutputComponents: uint32_t,
    pub maxTessellationGenerationLevel: uint32_t,
    pub maxTessellationPatchSize: uint32_t,
    pub maxTessellationControlPerVertexInputComponents: uint32_t,
    pub maxTessellationControlPerVertexOutputComponents: uint32_t,
    pub maxTessellationControlPerPatchOutputComponents: uint32_t,
    pub maxTessellationControlTotalOutputComponents: uint32_t,
    pub maxTessellationEvaluationInputComponents: uint32_t,
    pub maxTessellationEvaluationOutputComponents: uint32_t,
    pub maxGeometryShaderInvocations: uint32_t,
    pub maxGeometryInputComponents: uint32_t,
    pub maxGeometryOutputComponents: uint32_t,
    pub maxGeometryOutputVertices: uint32_t,
    pub maxGeometryTotalOutputComponents: uint32_t,
    pub maxFragmentInputComponents: uint32_t,
    pub maxFragmentOutputAttachments: uint32_t,
    pub maxFragmentDualSrcAttachments: uint32_t,
    pub maxFragmentCombinedOutputResources: uint32_t,
    pub maxComputeSharedMemorySize: uint32_t,
    pub maxComputeWorkGroupCount: [uint32_t; 3usize],
    pub maxComputeWorkGroupInvocations: uint32_t,
    pub maxComputeWorkGroupSize: [uint32_t; 3usize],
    pub subPixelPrecisionBits: uint32_t,
    pub subTexelPrecisionBits: uint32_t,
    pub mipmapPrecisionBits: uint32_t,
    pub maxDrawIndexedIndexValue: uint32_t,
    pub maxDrawIndirectCount: uint32_t,
    pub maxSamplerLodBias: f32,
    pub maxSamplerAnisotropy: f32,
    pub maxViewports: uint32_t,
    pub maxViewportDimensions: [uint32_t; 2usize],
    pub viewportBoundsRange: [f32; 2usize],
    pub viewportSubPixelBits: uint32_t,
    pub minMemoryMapAlignment: size_t,
    pub minTexelBufferOffsetAlignment: VkDeviceSize,
    pub minUniformBufferOffsetAlignment: VkDeviceSize,
    pub minStorageBufferOffsetAlignment: VkDeviceSize,
    pub minTexelOffset: int32_t,
    pub maxTexelOffset: uint32_t,
    pub minTexelGatherOffset: int32_t,
    pub maxTexelGatherOffset: uint32_t,
    pub minInterpolationOffset: f32,
    pub maxInterpolationOffset: f32,
    pub subPixelInterpolationOffsetBits: uint32_t,
    pub maxFramebufferWidth: uint32_t,
    pub maxFramebufferHeight: uint32_t,
    pub maxFramebufferLayers: uint32_t,
    pub framebufferColorSampleCounts: VkSampleCountFlags,
    pub framebufferDepthSampleCounts: VkSampleCountFlags,
    pub framebufferStencilSampleCounts: VkSampleCountFlags,
    pub framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
    pub maxColorAttachments: uint32_t,
    pub sampledImageColorSampleCounts: VkSampleCountFlags,
    pub sampledImageIntegerSampleCounts: VkSampleCountFlags,
    pub sampledImageDepthSampleCounts: VkSampleCountFlags,
    pub sampledImageStencilSampleCounts: VkSampleCountFlags,
    pub storageImageSampleCounts: VkSampleCountFlags,
    pub maxSampleMaskWords: uint32_t,
    pub timestampComputeAndGraphics: VkBool32,
    pub timestampPeriod: f32,
    pub maxClipDistances: uint32_t,
    pub maxCullDistances: uint32_t,
    pub maxCombinedClipAndCullDistances: uint32_t,
    pub discreteQueuePriorities: uint32_t,
    pub pointSizeRange: [f32; 2usize],
    pub lineWidthRange: [f32; 2usize],
    pub pointSizeGranularity: f32,
    pub lineWidthGranularity: f32,
    pub strictLines: VkBool32,
    pub standardSampleLocations: VkBool32,
    pub optimalBufferCopyOffsetAlignment: VkDeviceSize,
    pub optimalBufferCopyRowPitchAlignment: VkDeviceSize,
    pub nonCoherentAtomSize: VkDeviceSize,
}

impl Default for VkPhysicalDeviceLimits {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceSparseProperties {
    pub residencyStandard2DBlockShape: VkBool32,
    pub residencyStandard2DMultisampleBlockShape: VkBool32,
    pub residencyStandard3DBlockShape: VkBool32,
    pub residencyAlignedMipSize: VkBool32,
    pub residencyNonResidentStrict: VkBool32,
}

impl Default for VkPhysicalDeviceSparseProperties {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy)]
pub struct VkPhysicalDeviceProperties {
    pub apiVersion: uint32_t,
    pub driverVersion: uint32_t,
    pub vendorID: uint32_t,
    pub deviceID: uint32_t,
    pub deviceType: VkPhysicalDeviceType,
    pub deviceName: [c_char; 256usize],
    pub pipelineCacheUUID: [uint8_t; 16usize],
    pub limits: VkPhysicalDeviceLimits,
    pub sparseProperties: VkPhysicalDeviceSparseProperties,
}

#[cfg(debug_assertions)]
impl fmt::Debug for VkPhysicalDeviceProperties {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "")
    }
}

impl Clone for VkPhysicalDeviceProperties {
    fn clone(&self) -> Self {
        *self
    }
}

impl Default for VkPhysicalDeviceProperties {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkQueueFamilyProperties {
    pub queueFlags: VkQueueFlags,
    pub queueCount: uint32_t,
    pub timestampValidBits: uint32_t,
    pub minImageTransferGranularity: VkExtent3D,
}

impl Default for VkQueueFamilyProperties {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryType {
    pub propertyFlags: VkMemoryPropertyFlags,
    pub heapIndex: uint32_t,
}

impl Default for VkMemoryType {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryHeap {
    pub size: VkDeviceSize,
    pub flags: VkMemoryHeapFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkMemoryHeap {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPhysicalDeviceMemoryProperties {
    pub memoryTypeCount: uint32_t,
    pub memoryTypes: [VkMemoryType; 32usize],
    pub memoryHeapCount: uint32_t,
    pub memoryHeaps: [VkMemoryHeap; 16usize],
}

impl Default for VkPhysicalDeviceMemoryProperties {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceQueueCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkDeviceQueueCreateFlags,
    pub queueFamilyIndex: uint32_t,
    pub queueCount: uint32_t,
    pub pQueuePriorities: *const f32,
}

impl Default for VkDeviceQueueCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDeviceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkDeviceCreateFlags,
    pub queueCreateInfoCount: uint32_t,
    pub pQueueCreateInfos: *const VkDeviceQueueCreateInfo,
    pub enabledLayerCount: uint32_t,
    pub ppEnabledLayerNames: *const *const c_char,
    pub enabledExtensionCount: uint32_t,
    pub ppEnabledExtensionNames: *const *const c_char,
    pub pEnabledFeatures: *const VkPhysicalDeviceFeatures,
}

impl Default for VkDeviceCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy)]
pub struct VkExtensionProperties {
    pub extensionName: [u8; 256usize],
    pub specVersion: uint32_t,
}

impl Clone for VkExtensionProperties {
    fn clone(&self) -> Self {
        *self
    }
}

impl Default for VkExtensionProperties {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy)]
pub struct VkLayerProperties {
    pub layerName: [u8; 256usize],
    pub specVersion: uint32_t,
    pub implementationVersion: uint32_t,
    pub description: [u8; 256usize],
}

impl Clone for VkLayerProperties {
    fn clone(&self) -> Self {
        *self
    }
}

impl Default for VkLayerProperties {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub waitSemaphoreCount: uint32_t,
    pub pWaitSemaphores: *const VkSemaphore,
    pub pWaitDstStageMask: *const VkPipelineStageFlags,
    pub commandBufferCount: uint32_t,
    pub pCommandBuffers: *const VkCommandBuffer,
    pub signalSemaphoreCount: uint32_t,
    pub pSignalSemaphores: *const VkSemaphore,
}

impl Default for VkSubmitInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub allocationSize: VkDeviceSize,
    pub memoryTypeIndex: uint32_t,
}

impl Default for VkMemoryAllocateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMappedMemoryRange {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub memory: VkDeviceMemory,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}

impl Default for VkMappedMemoryRange {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryRequirements {
    pub size: VkDeviceSize,
    pub alignment: VkDeviceSize,
    pub memoryTypeBits: uint32_t,
}

impl Default for VkMemoryRequirements {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSparseImageFormatProperties {
    pub aspectMask: VkImageAspectFlags,
    pub imageGranularity: VkExtent3D,
    pub flags: VkSparseImageFormatFlags,
}

impl Default for VkSparseImageFormatProperties {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSparseImageMemoryRequirements {
    pub formatProperties: VkSparseImageFormatProperties,
    pub imageMipTailFirstLod: uint32_t,
    pub imageMipTailSize: VkDeviceSize,
    pub imageMipTailOffset: VkDeviceSize,
    pub imageMipTailStride: VkDeviceSize,
}

impl Default for VkSparseImageMemoryRequirements {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSparseMemoryBind {
    pub resourceOffset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkSparseMemoryBind {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSparseBufferMemoryBindInfo {
    pub buffer: VkBuffer,
    pub bindCount: uint32_t,
    pub pBinds: *const VkSparseMemoryBind,
}

impl Default for VkSparseBufferMemoryBindInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSparseImageOpaqueMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: uint32_t,
    pub pBinds: *const VkSparseMemoryBind,
}

impl Default for VkSparseImageOpaqueMemoryBindInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageSubresource {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: uint32_t,
    pub arrayLayer: uint32_t,
}

impl Default for VkImageSubresource {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkOffset3D {
    pub x: int32_t,
    pub y: int32_t,
    pub z: int32_t,
}

impl Default for VkOffset3D {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSparseImageMemoryBind {
    pub subresource: VkImageSubresource,
    pub offset: VkOffset3D,
    pub extent: VkExtent3D,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkSparseImageMemoryBind {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSparseImageMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: uint32_t,
    pub pBinds: *const VkSparseImageMemoryBind,
}

impl Default for VkSparseImageMemoryBindInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBindSparseInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub waitSemaphoreCount: uint32_t,
    pub pWaitSemaphores: *const VkSemaphore,
    pub bufferBindCount: uint32_t,
    pub pBufferBinds: *const VkSparseBufferMemoryBindInfo,
    pub imageOpaqueBindCount: uint32_t,
    pub pImageOpaqueBinds: *const VkSparseImageOpaqueMemoryBindInfo,
    pub imageBindCount: uint32_t,
    pub pImageBinds: *const VkSparseImageMemoryBindInfo,
    pub signalSemaphoreCount: uint32_t,
    pub pSignalSemaphores: *const VkSemaphore,
}

impl Default for VkBindSparseInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkFenceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkFenceCreateFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkFenceCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSemaphoreCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkSemaphoreCreateFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkSemaphoreCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkEventCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkEventCreateFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkEventCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkQueryPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkQueryPoolCreateFlags,
    pub queryType: VkQueryType,
    pub queryCount: uint32_t,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}

impl Default for VkQueryPoolCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkBufferCreateFlags,
    pub size: VkDeviceSize,
    pub usage: VkBufferUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: uint32_t,
    pub pQueueFamilyIndices: *const uint32_t,
}

impl Default for VkBufferCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkBufferViewCreateFlags,
    pub buffer: VkBuffer,
    pub format: VkFormat,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}

impl Default for VkBufferViewCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkImageCreateFlags,
    pub imageType: VkImageType,
    pub format: VkFormat,
    pub extent: VkExtent3D,
    pub mipLevels: uint32_t,
    pub arrayLayers: uint32_t,
    pub samples: VkSampleCountFlagBits,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: uint32_t,
    pub pQueueFamilyIndices: *const uint32_t,
    pub initialLayout: VkImageLayout,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkImageCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSubresourceLayout {
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub rowPitch: VkDeviceSize,
    pub arrayPitch: VkDeviceSize,
    pub depthPitch: VkDeviceSize,
}

impl Default for VkSubresourceLayout {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkComponentMapping {
    pub r: VkComponentSwizzle,
    pub g: VkComponentSwizzle,
    pub b: VkComponentSwizzle,
    pub a: VkComponentSwizzle,
}

impl Default for VkComponentMapping {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageSubresourceRange {
    pub aspectMask: VkImageAspectFlags,
    pub baseMipLevel: uint32_t,
    pub levelCount: uint32_t,
    pub baseArrayLayer: uint32_t,
    pub layerCount: uint32_t,
}

impl Default for VkImageSubresourceRange {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkImageViewCreateFlags,
    pub image: VkImage,
    pub viewType: VkImageViewType,
    pub format: VkFormat,
    pub components: VkComponentMapping,
    pub subresourceRange: VkImageSubresourceRange,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkImageViewCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkShaderModuleCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkShaderModuleCreateFlags,
    pub codeSize: size_t,
    pub pCode: *const uint32_t,
}

impl Default for VkShaderModuleCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineCacheCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineCacheCreateFlags,
    pub initialDataSize: size_t,
    pub pInitialData: *const c_void,
}

impl Default for VkPipelineCacheCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSpecializationMapEntry {
    pub constantID: uint32_t,
    pub offset: uint32_t,
    pub size: size_t,
}

impl Default for VkSpecializationMapEntry {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSpecializationInfo {
    pub mapEntryCount: uint32_t,
    pub pMapEntries: *const VkSpecializationMapEntry,
    pub dataSize: size_t,
    pub pData: *const c_void,
}

impl Default for VkSpecializationInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineShaderStageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineShaderStageCreateFlags,
    pub stage: VkShaderStageFlagBits,
    pub module: VkShaderModule,
    pub pName: *const c_char,
    pub pSpecializationInfo: *const VkSpecializationInfo,
}

impl Default for VkPipelineShaderStageCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkVertexInputBindingDescription {
    pub binding: uint32_t,
    pub stride: uint32_t,
    pub inputRate: VkVertexInputRate,
}

impl Default for VkVertexInputBindingDescription {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkVertexInputAttributeDescription {
    pub location: uint32_t,
    pub binding: uint32_t,
    pub format: VkFormat,
    pub offset: uint32_t,
}

impl Default for VkVertexInputAttributeDescription {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineVertexInputStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineVertexInputStateCreateFlags,
    pub vertexBindingDescriptionCount: uint32_t,
    pub pVertexBindingDescriptions: *const VkVertexInputBindingDescription,
    pub vertexAttributeDescriptionCount: uint32_t,
    pub pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription,
}

impl Default for VkPipelineVertexInputStateCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineInputAssemblyStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineInputAssemblyStateCreateFlags,
    pub topology: VkPrimitiveTopology,
    pub primitiveRestartEnable: VkBool32,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkPipelineInputAssemblyStateCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineTessellationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineTessellationStateCreateFlags,
    pub patchControlPoints: uint32_t,
}

impl Default for VkPipelineTessellationStateCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkViewport {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub minDepth: f32,
    pub maxDepth: f32,
}

impl Default for VkViewport {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkOffset2D {
    pub x: int32_t,
    pub y: int32_t,
}

impl Default for VkOffset2D {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkExtent2D {
    pub width: uint32_t,
    pub height: uint32_t,
}

impl Default for VkExtent2D {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkRect2D {
    pub offset: VkOffset2D,
    pub extent: VkExtent2D,
}

impl Default for VkRect2D {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineViewportStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineViewportStateCreateFlags,
    pub viewportCount: uint32_t,
    pub pViewports: *const VkViewport,
    pub scissorCount: uint32_t,
    pub pScissors: *const VkRect2D,
}

impl Default for VkPipelineViewportStateCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineRasterizationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineRasterizationStateCreateFlags,
    pub depthClampEnable: VkBool32,
    pub rasterizerDiscardEnable: VkBool32,
    pub polygonMode: VkPolygonMode,
    pub cullMode: VkCullModeFlags,
    pub frontFace: VkFrontFace,
    pub depthBiasEnable: VkBool32,
    pub depthBiasConstantFactor: f32,
    pub depthBiasClamp: f32,
    pub depthBiasSlopeFactor: f32,
    pub lineWidth: f32,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkPipelineRasterizationStateCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineMultisampleStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineMultisampleStateCreateFlags,
    pub rasterizationSamples: VkSampleCountFlagBits,
    pub sampleShadingEnable: VkBool32,
    pub minSampleShading: f32,
    pub pSampleMask: *const VkSampleMask,
    pub alphaToCoverageEnable: VkBool32,
    pub alphaToOneEnable: VkBool32,
}

impl Default for VkPipelineMultisampleStateCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkStencilOpState {
    pub failOp: VkStencilOp,
    pub passOp: VkStencilOp,
    pub depthFailOp: VkStencilOp,
    pub compareOp: VkCompareOp,
    pub compareMask: uint32_t,
    pub writeMask: uint32_t,
    pub reference: uint32_t,
}

impl Default for VkStencilOpState {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineDepthStencilStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineDepthStencilStateCreateFlags,
    pub depthTestEnable: VkBool32,
    pub depthWriteEnable: VkBool32,
    pub depthCompareOp: VkCompareOp,
    pub depthBoundsTestEnable: VkBool32,
    pub stencilTestEnable: VkBool32,
    pub front: VkStencilOpState,
    pub back: VkStencilOpState,
    pub minDepthBounds: f32,
    pub maxDepthBounds: f32,
}

impl Default for VkPipelineDepthStencilStateCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineColorBlendAttachmentState {
    pub blendEnable: VkBool32,
    pub srcColorBlendFactor: VkBlendFactor,
    pub dstColorBlendFactor: VkBlendFactor,
    pub colorBlendOp: VkBlendOp,
    pub srcAlphaBlendFactor: VkBlendFactor,
    pub dstAlphaBlendFactor: VkBlendFactor,
    pub alphaBlendOp: VkBlendOp,
    pub colorWriteMask: VkColorComponentFlags,
}

impl Default for VkPipelineColorBlendAttachmentState {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineColorBlendStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineColorBlendStateCreateFlags,
    pub logicOpEnable: VkBool32,
    pub logicOp: VkLogicOp,
    pub attachmentCount: uint32_t,
    pub pAttachments: *const VkPipelineColorBlendAttachmentState,
    pub blendConstants: [f32; 4usize],
}

impl Default for VkPipelineColorBlendStateCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineDynamicStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineDynamicStateCreateFlags,
    pub dynamicStateCount: uint32_t,
    pub pDynamicStates: *const VkDynamicState,
}

impl Default for VkPipelineDynamicStateCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkGraphicsPipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineCreateFlags,
    pub stageCount: uint32_t,
    pub pStages: *const VkPipelineShaderStageCreateInfo,
    pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
    pub pInputAssemblyState: *const VkPipelineInputAssemblyStateCreateInfo,
    pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
    pub pViewportState: *const VkPipelineViewportStateCreateInfo,
    pub pRasterizationState: *const VkPipelineRasterizationStateCreateInfo,
    pub pMultisampleState: *const VkPipelineMultisampleStateCreateInfo,
    pub pDepthStencilState: *const VkPipelineDepthStencilStateCreateInfo,
    pub pColorBlendState: *const VkPipelineColorBlendStateCreateInfo,
    pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
    pub layout: VkPipelineLayout,
    pub renderPass: VkRenderPass,
    pub subpass: uint32_t,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: int32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkGraphicsPipelineCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkComputePipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineCreateFlags,
    pub stage: VkPipelineShaderStageCreateInfo,
    pub layout: VkPipelineLayout,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: int32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkComputePipelineCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPushConstantRange {
    pub stageFlags: VkShaderStageFlags,
    pub offset: uint32_t,
    pub size: uint32_t,
}

impl Default for VkPushConstantRange {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPipelineLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkPipelineLayoutCreateFlags,
    pub setLayoutCount: uint32_t,
    pub pSetLayouts: *const VkDescriptorSetLayout,
    pub pushConstantRangeCount: uint32_t,
    pub pPushConstantRanges: *const VkPushConstantRange,
}

impl Default for VkPipelineLayoutCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSamplerCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkSamplerCreateFlags,
    pub magFilter: VkFilter,
    pub minFilter: VkFilter,
    pub mipmapMode: VkSamplerMipmapMode,
    pub addressModeU: VkSamplerAddressMode,
    pub addressModeV: VkSamplerAddressMode,
    pub addressModeW: VkSamplerAddressMode,
    pub mipLodBias: f32,
    pub anisotropyEnable: VkBool32,
    pub maxAnisotropy: f32,
    pub compareEnable: VkBool32,
    pub compareOp: VkCompareOp,
    pub minLod: f32,
    pub maxLod: f32,
    pub borderColor: VkBorderColor,
    pub unnormalizedCoordinates: VkBool32,
}

impl Default for VkSamplerCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorSetLayoutBinding {
    pub binding: uint32_t,
    pub descriptorType: VkDescriptorType,
    pub descriptorCount: uint32_t,
    pub stageFlags: VkShaderStageFlags,
    pub pImmutableSamplers: *const VkSampler,
}

impl Default for VkDescriptorSetLayoutBinding {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorSetLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkDescriptorSetLayoutCreateFlags,
    pub bindingCount: uint32_t,
    pub pBindings: *const VkDescriptorSetLayoutBinding,
}

impl Default for VkDescriptorSetLayoutCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorPoolSize {
    pub type_: VkDescriptorType,
    pub descriptorCount: uint32_t,
}

impl Default for VkDescriptorPoolSize {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkDescriptorPoolCreateFlags,
    pub maxSets: uint32_t,
    pub poolSizeCount: uint32_t,
    pub pPoolSizes: *const VkDescriptorPoolSize,
}

impl Default for VkDescriptorPoolCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorSetAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub descriptorPool: VkDescriptorPool,
    pub descriptorSetCount: uint32_t,
    pub pSetLayouts: *const VkDescriptorSetLayout,
}

impl Default for VkDescriptorSetAllocateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorImageInfo {
    pub sampler: VkSampler,
    pub imageView: VkImageView,
    pub imageLayout: VkImageLayout,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkDescriptorImageInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDescriptorBufferInfo {
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}

impl Default for VkDescriptorBufferInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkWriteDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: uint32_t,
    pub dstArrayElement: uint32_t,
    pub descriptorCount: uint32_t,
    pub descriptorType: VkDescriptorType,
    pub pImageInfo: *const VkDescriptorImageInfo,
    pub pBufferInfo: *const VkDescriptorBufferInfo,
    pub pTexelBufferView: *const VkBufferView,
}

impl Default for VkWriteDescriptorSet {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCopyDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub srcSet: VkDescriptorSet,
    pub srcBinding: uint32_t,
    pub srcArrayElement: uint32_t,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: uint32_t,
    pub dstArrayElement: uint32_t,
    pub descriptorCount: uint32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkCopyDescriptorSet {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkFramebufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkFramebufferCreateFlags,
    pub renderPass: VkRenderPass,
    pub attachmentCount: uint32_t,
    pub pAttachments: *const VkImageView,
    pub width: uint32_t,
    pub height: uint32_t,
    pub layers: uint32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkFramebufferCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAttachmentDescription {
    pub flags: VkAttachmentDescriptionFlags,
    pub format: VkFormat,
    pub samples: VkSampleCountFlagBits,
    pub loadOp: VkAttachmentLoadOp,
    pub storeOp: VkAttachmentStoreOp,
    pub stencilLoadOp: VkAttachmentLoadOp,
    pub stencilStoreOp: VkAttachmentStoreOp,
    pub initialLayout: VkImageLayout,
    pub finalLayout: VkImageLayout,
}

impl Default for VkAttachmentDescription {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkAttachmentReference {
    pub attachment: uint32_t,
    pub layout: VkImageLayout,
}

impl Default for VkAttachmentReference {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSubpassDescription {
    pub flags: VkSubpassDescriptionFlags,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub inputAttachmentCount: uint32_t,
    pub pInputAttachments: *const VkAttachmentReference,
    pub colorAttachmentCount: uint32_t,
    pub pColorAttachments: *const VkAttachmentReference,
    pub pResolveAttachments: *const VkAttachmentReference,
    pub pDepthStencilAttachment: *const VkAttachmentReference,
    pub preserveAttachmentCount: uint32_t,
    pub pPreserveAttachments: *const uint32_t,
}

impl Default for VkSubpassDescription {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSubpassDependency {
    pub srcSubpass: uint32_t,
    pub dstSubpass: uint32_t,
    pub srcStageMask: VkPipelineStageFlags,
    pub dstStageMask: VkPipelineStageFlags,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub dependencyFlags: VkDependencyFlags,
}

impl Default for VkSubpassDependency {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkRenderPassCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkRenderPassCreateFlags,
    pub attachmentCount: uint32_t,
    pub pAttachments: *const VkAttachmentDescription,
    pub subpassCount: uint32_t,
    pub pSubpasses: *const VkSubpassDescription,
    pub dependencyCount: uint32_t,
    pub pDependencies: *const VkSubpassDependency,
}

impl Default for VkRenderPassCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCommandPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkCommandPoolCreateFlags,
    pub queueFamilyIndex: uint32_t,
}

impl Default for VkCommandPoolCreateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCommandBufferAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub commandPool: VkCommandPool,
    pub level: VkCommandBufferLevel,
    pub commandBufferCount: uint32_t,
}

impl Default for VkCommandBufferAllocateInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCommandBufferInheritanceInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub renderPass: VkRenderPass,
    pub subpass: uint32_t,
    pub framebuffer: VkFramebuffer,
    pub occlusionQueryEnable: VkBool32,
    pub queryFlags: VkQueryControlFlags,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkCommandBufferInheritanceInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkCommandBufferBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkCommandBufferUsageFlags,
    pub pInheritanceInfo: *const VkCommandBufferInheritanceInfo,
}

impl Default for VkCommandBufferBeginInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferCopy {
    pub srcOffset: VkDeviceSize,
    pub dstOffset: VkDeviceSize,
    pub size: VkDeviceSize,
}

impl Default for VkBufferCopy {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageSubresourceLayers {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: uint32_t,
    pub baseArrayLayer: uint32_t,
    pub layerCount: uint32_t,
}

impl Default for VkImageSubresourceLayers {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageCopy {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}

impl Default for VkImageCopy {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageBlit {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffsets: [VkOffset3D; 2usize],
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffsets: [VkOffset3D; 2usize],
}

impl Default for VkImageBlit {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferImageCopy {
    pub bufferOffset: VkDeviceSize,
    pub bufferRowLength: uint32_t,
    pub bufferImageHeight: uint32_t,
    pub imageSubresource: VkImageSubresourceLayers,
    pub imageOffset: VkOffset3D,
    pub imageExtent: VkExtent3D,
}

impl Default for VkBufferImageCopy {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkClearColorValue {
    pub _bindgen_data_: [u32; 4usize],
}

impl VkClearColorValue {
    pub unsafe fn float32(&mut self) -> *mut [f32; 4usize] {
        let raw: *mut u8 = transmute(&self._bindgen_data_);
        transmute(raw.offset(0))
    }
    pub unsafe fn int32(&mut self) -> *mut [int32_t; 4usize] {
        let raw: *mut u8 = transmute(&self._bindgen_data_);
        transmute(raw.offset(0))
    }
    pub unsafe fn uint32(&mut self) -> *mut [uint32_t; 4usize] {
        let raw: *mut u8 = transmute(&self._bindgen_data_);
        transmute(raw.offset(0))
    }
}

impl Default for VkClearColorValue {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkClearDepthStencilValue {
    pub depth: f32,
    pub stencil: uint32_t,
}

impl Default for VkClearDepthStencilValue {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkClearValue {
    pub data: [f32; 4usize],
}

impl VkClearValue {
    pub unsafe fn color(&mut self) -> *mut VkClearColorValue {
        let raw: *mut u8 = transmute(&self.data);
        transmute(raw.offset(0))
    }
    pub unsafe fn depthStencil(&mut self) -> *mut VkClearDepthStencilValue {
        let raw: *mut u8 = transmute(&self.data);
        transmute(raw.offset(0))
    }
}

impl Default for VkClearValue {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkClearAttachment {
    pub aspectMask: VkImageAspectFlags,
    pub colorAttachment: uint32_t,
    pub clearValue: VkClearValue,
}

impl Default for VkClearAttachment {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkClearRect {
    pub rect: VkRect2D,
    pub baseArrayLayer: uint32_t,
    pub layerCount: uint32_t,
}

impl Default for VkClearRect {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageResolve {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}

impl Default for VkImageResolve {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
}

impl Default for VkMemoryBarrier {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkBufferMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub srcQueueFamilyIndex: uint32_t,
    pub dstQueueFamilyIndex: uint32_t,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}

impl Default for VkBufferMemoryBarrier {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkImageMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub oldLayout: VkImageLayout,
    pub newLayout: VkImageLayout,
    pub srcQueueFamilyIndex: uint32_t,
    pub dstQueueFamilyIndex: uint32_t,
    pub image: VkImage,
    pub subresourceRange: VkImageSubresourceRange,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkImageMemoryBarrier {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkRenderPassBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub renderPass: VkRenderPass,
    pub framebuffer: VkFramebuffer,
    pub renderArea: VkRect2D,
    pub clearValueCount: uint32_t,
    pub pClearValues: *const VkClearValue,
}

impl Default for VkRenderPassBeginInfo {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDispatchIndirectCommand {
    pub x: uint32_t,
    pub y: uint32_t,
    pub z: uint32_t,
}

impl Default for VkDispatchIndirectCommand {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDrawIndexedIndirectCommand {
    pub indexCount: uint32_t,
    pub instanceCount: uint32_t,
    pub firstIndex: uint32_t,
    pub vertexOffset: int32_t,
    pub firstInstance: uint32_t,
}

impl Default for VkDrawIndexedIndirectCommand {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDrawIndirectCommand {
    pub vertexCount: uint32_t,
    pub instanceCount: uint32_t,
    pub firstVertex: uint32_t,
    pub firstInstance: uint32_t,
}

impl Default for VkDrawIndirectCommand {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

pub type PFN_vkCreateInstance = unsafe extern "C" fn(
    pCreateInfo: *const VkInstanceCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pInstance: *mut VkInstance,
) -> VkResult;
pub type PFN_vkDestroyInstance =
    unsafe extern "C" fn(instance: VkInstance, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkEnumeratePhysicalDevices =
    unsafe extern "C" fn(
        instance: VkInstance,
        pPhysicalDeviceCount: *mut uint32_t,
        pPhysicalDevices: *mut VkPhysicalDevice,
    ) -> VkResult;
pub type PFN_vkGetPhysicalDeviceFeatures =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures,
    );
pub type PFN_vkGetPhysicalDeviceFormatProperties =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties,
    );
pub type PFN_vkGetPhysicalDeviceImageFormatProperties =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        tiling: VkImageTiling,
        usage: VkImageUsageFlags,
        flags: VkImageCreateFlags,
        pImageFormatProperties: *mut VkImageFormatProperties,
    ) -> VkResult;
pub type PFN_vkGetPhysicalDeviceProperties =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties,
    );
pub type PFN_vkGetPhysicalDeviceQueueFamilyProperties =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut uint32_t,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties,
    );
pub type PFN_vkGetPhysicalDeviceMemoryProperties =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties,
    );
pub type PFN_vkGetInstanceProcAddr =
    unsafe extern "C" fn(instance: VkInstance, pName: *const c_char) -> PFN_vkVoidFunction;
pub type PFN_vkGetDeviceProcAddr =
    unsafe extern "C" fn(device: VkDevice, pName: *const c_char) -> PFN_vkVoidFunction;
pub type PFN_vkCreateDevice = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice,
    pCreateInfo: *const VkDeviceCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pDevice: *mut VkDevice,
) -> VkResult;
pub type PFN_vkDestroyDevice =
    unsafe extern "C" fn(device: VkDevice, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkEnumerateInstanceExtensionProperties =
    unsafe extern "C" fn(
        pLayerName: *const c_char,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult;
pub type PFN_vkEnumerateDeviceExtensionProperties =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pLayerName: *const c_char,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult;
pub type PFN_vkEnumerateInstanceLayerProperties =
    unsafe extern "C" fn(pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties)
        -> VkResult;
pub type PFN_vkEnumerateDeviceLayerProperties =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkLayerProperties,
    ) -> VkResult;
pub type PFN_vkGetDeviceQueue = unsafe extern "C" fn(
    device: VkDevice,
    queueFamilyIndex: uint32_t,
    queueIndex: uint32_t,
    pQueue: *mut VkQueue,
);
pub type PFN_vkQueueSubmit = unsafe extern "C" fn(
    queue: VkQueue,
    submitCount: uint32_t,
    pSubmits: *const VkSubmitInfo,
    fence: VkFence,
) -> VkResult;
pub type PFN_vkQueueWaitIdle = extern "C" fn(queue: VkQueue) -> VkResult;
pub type PFN_vkDeviceWaitIdle = extern "C" fn(device: VkDevice) -> VkResult;
pub type PFN_vkAllocateMemory = unsafe extern "C" fn(
    device: VkDevice,
    pAllocateInfo: *const VkMemoryAllocateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pMemory: *mut VkDeviceMemory,
) -> VkResult;
pub type PFN_vkFreeMemory = unsafe extern "C" fn(
    device: VkDevice,
    memory: VkDeviceMemory,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkMapMemory = unsafe extern "C" fn(
    device: VkDevice,
    memory: VkDeviceMemory,
    offset: VkDeviceSize,
    size: VkDeviceSize,
    flags: VkMemoryMapFlags,
    ppData: *mut *mut c_void,
) -> VkResult;
pub type PFN_vkUnmapMemory = extern "C" fn(device: VkDevice, memory: VkDeviceMemory);
pub type PFN_vkFlushMappedMemoryRanges =
    unsafe extern "C" fn(
        device: VkDevice,
        memoryRangeCount: uint32_t,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult;
pub type PFN_vkInvalidateMappedMemoryRanges =
    unsafe extern "C" fn(
        device: VkDevice,
        memoryRangeCount: uint32_t,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult;
pub type PFN_vkGetDeviceMemoryCommitment =
    unsafe extern "C" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        pCommittedMemoryInBytes: *mut VkDeviceSize,
    );
pub type PFN_vkBindBufferMemory = extern "C" fn(
    device: VkDevice,
    buffer: VkBuffer,
    memory: VkDeviceMemory,
    memoryOffset: VkDeviceSize,
) -> VkResult;
pub type PFN_vkBindImageMemory = extern "C" fn(
    device: VkDevice,
    image: VkImage,
    memory: VkDeviceMemory,
    memoryOffset: VkDeviceSize,
) -> VkResult;
pub type PFN_vkGetBufferMemoryRequirements =
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        pMemoryRequirements: *mut VkMemoryRequirements,
    );
pub type PFN_vkGetImageMemoryRequirements =
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pMemoryRequirements: *mut VkMemoryRequirements,
    );
pub type PFN_vkGetImageSparseMemoryRequirements =
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pSparseMemoryRequirementCount: *mut uint32_t,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements,
    );
pub type PFN_vkGetPhysicalDeviceSparseImageFormatProperties =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        samples: VkSampleCountFlagBits,
        usage: VkImageUsageFlags,
        tiling: VkImageTiling,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkSparseImageFormatProperties,
    );
pub type PFN_vkQueueBindSparse = unsafe extern "C" fn(
    queue: VkQueue,
    bindInfoCount: uint32_t,
    pBindInfo: *const VkBindSparseInfo,
    fence: VkFence,
) -> VkResult;
pub type PFN_vkCreateFence = unsafe extern "C" fn(
    device: VkDevice,
    pCreateInfo: *const VkFenceCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pFence: *mut VkFence,
) -> VkResult;
pub type PFN_vkDestroyFence = unsafe extern "C" fn(
    device: VkDevice,
    fence: VkFence,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkResetFences =
    unsafe extern "C" fn(device: VkDevice, fenceCount: uint32_t, pFences: *const VkFence)
        -> VkResult;
pub type PFN_vkGetFenceStatus = extern "C" fn(device: VkDevice, fence: VkFence) -> VkResult;
pub type PFN_vkWaitForFences = unsafe extern "C" fn(
    device: VkDevice,
    fenceCount: uint32_t,
    pFences: *const VkFence,
    waitAll: VkBool32,
    timeout: uint64_t,
) -> VkResult;
pub type PFN_vkCreateSemaphore = unsafe extern "C" fn(
    device: VkDevice,
    pCreateInfo: *const VkSemaphoreCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pSemaphore: *mut VkSemaphore,
) -> VkResult;
pub type PFN_vkDestroySemaphore = unsafe extern "C" fn(
    device: VkDevice,
    semaphore: VkSemaphore,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkCreateEvent = unsafe extern "C" fn(
    device: VkDevice,
    pCreateInfo: *const VkEventCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pEvent: *mut VkEvent,
) -> VkResult;
pub type PFN_vkDestroyEvent = unsafe extern "C" fn(
    device: VkDevice,
    event: VkEvent,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkGetEventStatus = extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult;
pub type PFN_vkSetEvent = extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult;
pub type PFN_vkResetEvent = extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult;
pub type PFN_vkCreateQueryPool = unsafe extern "C" fn(
    device: VkDevice,
    pCreateInfo: *const VkQueryPoolCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pQueryPool: *mut VkQueryPool,
) -> VkResult;
pub type PFN_vkDestroyQueryPool = unsafe extern "C" fn(
    device: VkDevice,
    queryPool: VkQueryPool,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkGetQueryPoolResults = unsafe extern "C" fn(
    device: VkDevice,
    queryPool: VkQueryPool,
    firstQuery: uint32_t,
    queryCount: uint32_t,
    dataSize: size_t,
    pData: *mut c_void,
    stride: VkDeviceSize,
    flags: VkQueryResultFlags,
) -> VkResult;
pub type PFN_vkCreateBuffer = unsafe extern "C" fn(
    device: VkDevice,
    pCreateInfo: *const VkBufferCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pBuffer: *mut VkBuffer,
) -> VkResult;
pub type PFN_vkDestroyBuffer = unsafe extern "C" fn(
    device: VkDevice,
    buffer: VkBuffer,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkCreateBufferView = unsafe extern "C" fn(
    device: VkDevice,
    pCreateInfo: *const VkBufferViewCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pView: *mut VkBufferView,
) -> VkResult;
pub type PFN_vkDestroyBufferView = unsafe extern "C" fn(
    device: VkDevice,
    bufferView: VkBufferView,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkCreateImage = unsafe extern "C" fn(
    device: VkDevice,
    pCreateInfo: *const VkImageCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pImage: *mut VkImage,
) -> VkResult;
pub type PFN_vkDestroyImage = unsafe extern "C" fn(
    device: VkDevice,
    image: VkImage,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkGetImageSubresourceLayout =
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pSubresource: *const VkImageSubresource,
        pLayout: *mut VkSubresourceLayout,
    );
pub type PFN_vkCreateImageView = unsafe extern "C" fn(
    device: VkDevice,
    pCreateInfo: *const VkImageViewCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pView: *mut VkImageView,
) -> VkResult;
pub type PFN_vkDestroyImageView = unsafe extern "C" fn(
    device: VkDevice,
    imageView: VkImageView,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkCreateShaderModule =
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkShaderModuleCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pShaderModule: *mut VkShaderModule,
    ) -> VkResult;
pub type PFN_vkDestroyShaderModule = unsafe extern "C" fn(
    device: VkDevice,
    shaderModule: VkShaderModule,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkCreatePipelineCache =
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkPipelineCacheCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineCache: *mut VkPipelineCache,
    ) -> VkResult;
pub type PFN_vkDestroyPipelineCache =
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        pAllocator: *const VkAllocationCallbacks,
    );
pub type PFN_vkGetPipelineCacheData = unsafe extern "C" fn(
    device: VkDevice,
    pipelineCache: VkPipelineCache,
    pDataSize: *mut size_t,
    pData: *mut c_void,
) -> VkResult;
pub type PFN_vkMergePipelineCaches = unsafe extern "C" fn(
    device: VkDevice,
    dstCache: VkPipelineCache,
    srcCacheCount: uint32_t,
    pSrcCaches: *const VkPipelineCache,
) -> VkResult;
pub type PFN_vkCreateGraphicsPipelines =
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: uint32_t,
        pCreateInfos: *const VkGraphicsPipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult;
pub type PFN_vkCreateComputePipelines =
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: uint32_t,
        pCreateInfos: *const VkComputePipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult;
pub type PFN_vkDestroyPipeline = unsafe extern "C" fn(
    device: VkDevice,
    pipeline: VkPipeline,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkCreatePipelineLayout =
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkPipelineLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineLayout: *mut VkPipelineLayout,
    ) -> VkResult;
pub type PFN_vkDestroyPipelineLayout =
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineLayout: VkPipelineLayout,
        pAllocator: *const VkAllocationCallbacks,
    );
pub type PFN_vkCreateSampler = unsafe extern "C" fn(
    device: VkDevice,
    pCreateInfo: *const VkSamplerCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pSampler: *mut VkSampler,
) -> VkResult;
pub type PFN_vkDestroySampler = unsafe extern "C" fn(
    device: VkDevice,
    sampler: VkSampler,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkCreateDescriptorSetLayout =
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSetLayout: *mut VkDescriptorSetLayout,
    ) -> VkResult;
pub type PFN_vkDestroyDescriptorSetLayout =
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorSetLayout: VkDescriptorSetLayout,
        pAllocator: *const VkAllocationCallbacks,
    );
pub type PFN_vkCreateDescriptorPool =
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorPool: *mut VkDescriptorPool,
    ) -> VkResult;
pub type PFN_vkDestroyDescriptorPool =
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        pAllocator: *const VkAllocationCallbacks,
    );
pub type PFN_vkResetDescriptorPool = extern "C" fn(
    device: VkDevice,
    descriptorPool: VkDescriptorPool,
    flags: VkDescriptorPoolResetFlags,
) -> VkResult;
pub type PFN_vkAllocateDescriptorSets =
    unsafe extern "C" fn(
        device: VkDevice,
        pAllocateInfo: *const VkDescriptorSetAllocateInfo,
        pDescriptorSets: *mut VkDescriptorSet,
    ) -> VkResult;
pub type PFN_vkFreeDescriptorSets = unsafe extern "C" fn(
    device: VkDevice,
    descriptorPool: VkDescriptorPool,
    descriptorSetCount: uint32_t,
    pDescriptorSets: *const VkDescriptorSet,
) -> VkResult;
pub type PFN_vkUpdateDescriptorSets =
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorWriteCount: uint32_t,
        pDescriptorWrites: *const VkWriteDescriptorSet,
        descriptorCopyCount: uint32_t,
        pDescriptorCopies: *const VkCopyDescriptorSet,
    );
pub type PFN_vkCreateFramebuffer =
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkFramebufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pFramebuffer: *mut VkFramebuffer,
    ) -> VkResult;
pub type PFN_vkDestroyFramebuffer = unsafe extern "C" fn(
    device: VkDevice,
    framebuffer: VkFramebuffer,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkCreateRenderPass = unsafe extern "C" fn(
    device: VkDevice,
    pCreateInfo: *const VkRenderPassCreateInfo,
    pAllocator: *const VkAllocationCallbacks,
    pRenderPass: *mut VkRenderPass,
) -> VkResult;
pub type PFN_vkDestroyRenderPass = unsafe extern "C" fn(
    device: VkDevice,
    renderPass: VkRenderPass,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkGetRenderAreaGranularity =
    unsafe extern "C" fn(device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D);
pub type PFN_vkCreateCommandPool =
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkCommandPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pCommandPool: *mut VkCommandPool,
    ) -> VkResult;
pub type PFN_vkDestroyCommandPool = unsafe extern "C" fn(
    device: VkDevice,
    commandPool: VkCommandPool,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkResetCommandPool =
    extern "C" fn(device: VkDevice, commandPool: VkCommandPool, flags: VkCommandPoolResetFlags)
        -> VkResult;
pub type PFN_vkAllocateCommandBuffers =
    unsafe extern "C" fn(
        device: VkDevice,
        pAllocateInfo: *const VkCommandBufferAllocateInfo,
        pCommandBuffers: *mut VkCommandBuffer,
    ) -> VkResult;
pub type PFN_vkFreeCommandBuffers = unsafe extern "C" fn(
    device: VkDevice,
    commandPool: VkCommandPool,
    commandBufferCount: uint32_t,
    pCommandBuffers: *const VkCommandBuffer,
);
pub type PFN_vkBeginCommandBuffer =
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pBeginInfo: *const VkCommandBufferBeginInfo,
    ) -> VkResult;
pub type PFN_vkEndCommandBuffer = extern "C" fn(commandBuffer: VkCommandBuffer) -> VkResult;
pub type PFN_vkResetCommandBuffer =
    extern "C" fn(commandBuffer: VkCommandBuffer, flags: VkCommandBufferResetFlags) -> VkResult;
pub type PFN_vkCmdBindPipeline = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    pipelineBindPoint: VkPipelineBindPoint,
    pipeline: VkPipeline,
);
pub type PFN_vkCmdSetViewport = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    firstViewport: uint32_t,
    viewportCount: uint32_t,
    pViewports: *const VkViewport,
);
pub type PFN_vkCmdSetScissor = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    firstScissor: uint32_t,
    scissorCount: uint32_t,
    pScissors: *const VkRect2D,
);
pub type PFN_vkCmdSetLineWidth = extern "C" fn(commandBuffer: VkCommandBuffer, lineWidth: f32);
pub type PFN_vkCmdSetDepthBias = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    depthBiasConstantFactor: f32,
    depthBiasClamp: f32,
    depthBiasSlopeFactor: f32,
);
pub type PFN_vkCmdSetBlendConstants =
    extern "C" fn(commandBuffer: VkCommandBuffer, blendConstants: *mut f32);
pub type PFN_vkCmdSetDepthBounds =
    extern "C" fn(commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32);
pub type PFN_vkCmdSetStencilCompareMask = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    faceMask: VkStencilFaceFlags,
    compareMask: uint32_t,
);
pub type PFN_vkCmdSetStencilWriteMask = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    faceMask: VkStencilFaceFlags,
    writeMask: uint32_t,
);
pub type PFN_vkCmdSetStencilReference = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    faceMask: VkStencilFaceFlags,
    reference: uint32_t,
);
pub type PFN_vkCmdBindDescriptorSets =
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        firstSet: uint32_t,
        descriptorSetCount: uint32_t,
        pDescriptorSets: *const VkDescriptorSet,
        dynamicOffsetCount: uint32_t,
        pDynamicOffsets: *const uint32_t,
    );
pub type PFN_vkCmdBindIndexBuffer = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: VkDeviceSize,
    indexType: VkIndexType,
);
pub type PFN_vkCmdBindVertexBuffers = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    firstBinding: uint32_t,
    bindingCount: uint32_t,
    pBuffers: *const VkBuffer,
    pOffsets: *const VkDeviceSize,
);
pub type PFN_vkCmdDraw = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    vertexCount: uint32_t,
    instanceCount: uint32_t,
    firstVertex: uint32_t,
    firstInstance: uint32_t,
);
pub type PFN_vkCmdDrawIndexed = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    indexCount: uint32_t,
    instanceCount: uint32_t,
    firstIndex: uint32_t,
    vertexOffset: int32_t,
    firstInstance: uint32_t,
);
pub type PFN_vkCmdDrawIndirect = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: VkDeviceSize,
    drawCount: uint32_t,
    stride: uint32_t,
);
pub type PFN_vkCmdDrawIndexedIndirect = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: VkDeviceSize,
    drawCount: uint32_t,
    stride: uint32_t,
);
pub type PFN_vkCmdDispatch =
    extern "C" fn(commandBuffer: VkCommandBuffer, x: uint32_t, y: uint32_t, z: uint32_t);
pub type PFN_vkCmdDispatchIndirect =
    extern "C" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize);
pub type PFN_vkCmdCopyBuffer = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    srcBuffer: VkBuffer,
    dstBuffer: VkBuffer,
    regionCount: uint32_t,
    pRegions: *const VkBufferCopy,
);
pub type PFN_vkCmdCopyImage = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: uint32_t,
    pRegions: *const VkImageCopy,
);
pub type PFN_vkCmdBlitImage = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: uint32_t,
    pRegions: *const VkImageBlit,
    filter: VkFilter,
);
pub type PFN_vkCmdCopyBufferToImage = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    srcBuffer: VkBuffer,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: uint32_t,
    pRegions: *const VkBufferImageCopy,
);
pub type PFN_vkCmdCopyImageToBuffer = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstBuffer: VkBuffer,
    regionCount: uint32_t,
    pRegions: *const VkBufferImageCopy,
);
pub type PFN_vkCmdUpdateBuffer = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    dstBuffer: VkBuffer,
    dstOffset: VkDeviceSize,
    dataSize: VkDeviceSize,
    pData: *const uint32_t,
);
pub type PFN_vkCmdFillBuffer = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    dstBuffer: VkBuffer,
    dstOffset: VkDeviceSize,
    size: VkDeviceSize,
    data: uint32_t,
);
pub type PFN_vkCmdClearColorImage = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    image: VkImage,
    imageLayout: VkImageLayout,
    pColor: *const VkClearColorValue,
    rangeCount: uint32_t,
    pRanges: *const VkImageSubresourceRange,
);
pub type PFN_vkCmdClearDepthStencilImage =
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        image: VkImage,
        imageLayout: VkImageLayout,
        pDepthStencil: *const VkClearDepthStencilValue,
        rangeCount: uint32_t,
        pRanges: *const VkImageSubresourceRange,
    );
pub type PFN_vkCmdClearAttachments = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    attachmentCount: uint32_t,
    pAttachments: *const VkClearAttachment,
    rectCount: uint32_t,
    pRects: *const VkClearRect,
);
pub type PFN_vkCmdResolveImage = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    srcImage: VkImage,
    srcImageLayout: VkImageLayout,
    dstImage: VkImage,
    dstImageLayout: VkImageLayout,
    regionCount: uint32_t,
    pRegions: *const VkImageResolve,
);
pub type PFN_vkCmdSetEvent =
    extern "C" fn(commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags);
pub type PFN_vkCmdResetEvent =
    extern "C" fn(commandBuffer: VkCommandBuffer, event: VkEvent, stageMask: VkPipelineStageFlags);
pub type PFN_vkCmdWaitEvents =
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        eventCount: uint32_t,
        pEvents: *const VkEvent,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        memoryBarrierCount: uint32_t,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: uint32_t,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: uint32_t,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    );
pub type PFN_vkCmdPipelineBarrier =
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        dependencyFlags: VkDependencyFlags,
        memoryBarrierCount: uint32_t,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: uint32_t,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: uint32_t,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    );
pub type PFN_vkCmdBeginQuery = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    query: uint32_t,
    flags: VkQueryControlFlags,
);
pub type PFN_vkCmdEndQuery =
    extern "C" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: uint32_t);
pub type PFN_vkCmdResetQueryPool = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    firstQuery: uint32_t,
    queryCount: uint32_t,
);
pub type PFN_vkCmdWriteTimestamp = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    pipelineStage: VkPipelineStageFlagBits,
    queryPool: VkQueryPool,
    query: uint32_t,
);
pub type PFN_vkCmdCopyQueryPoolResults = extern "C" fn(
    commandBuffer: VkCommandBuffer,
    queryPool: VkQueryPool,
    firstQuery: uint32_t,
    queryCount: uint32_t,
    dstBuffer: VkBuffer,
    dstOffset: VkDeviceSize,
    stride: VkDeviceSize,
    flags: VkQueryResultFlags,
);
pub type PFN_vkCmdPushConstants = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    layout: VkPipelineLayout,
    stageFlags: VkShaderStageFlags,
    offset: uint32_t,
    size: uint32_t,
    pValues: *const c_void,
);
pub type PFN_vkCmdBeginRenderPass =
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        contents: VkSubpassContents,
    );
pub type PFN_vkCmdNextSubpass =
    extern "C" fn(commandBuffer: VkCommandBuffer, contents: VkSubpassContents);
pub type PFN_vkCmdEndRenderPass = extern "C" fn(commandBuffer: VkCommandBuffer);
pub type PFN_vkCmdExecuteCommands = unsafe extern "C" fn(
    commandBuffer: VkCommandBuffer,
    commandBufferCount: uint32_t,
    pCommandBuffers: *const VkCommandBuffer,
);

pub enum VkSurfaceKHR_T {}

pub type VkSurfaceKHR = *mut VkSurfaceKHR_T;

pub const VK_COLOR_SPACE_BEGIN_RANGE_KHR: VkColorSpaceKHR =
    VkColorSpaceKHR::VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
pub const VK_COLOR_SPACE_END_RANGE_KHR: VkColorSpaceKHR =
    VkColorSpaceKHR::VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLOR_SPACE_RANGE_SIZE_KHR = 1,
    VK_COLOR_SPACE_MAX_ENUM_KHR = 2147483647,
}

pub const VK_PRESENT_MODE_BEGIN_RANGE_KHR: VkPresentModeKHR =
    VkPresentModeKHR::VK_PRESENT_MODE_IMMEDIATE_KHR;
pub const VK_PRESENT_MODE_END_RANGE_KHR: VkPresentModeKHR =
    VkPresentModeKHR::VK_PRESENT_MODE_FIFO_RELAXED_KHR;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_RANGE_SIZE_KHR = 4,
    VK_PRESENT_MODE_MAX_ENUM_KHR = 2147483647,
}

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 1,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 2,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 4,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 8,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 16,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 32,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 64,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 128,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 256,
    VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}

pub type VkSurfaceTransformFlagsKHR = VkFlags;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 2,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 4,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 8,
    VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}

pub type VkCompositeAlphaFlagsKHR = VkFlags;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSurfaceCapabilitiesKHR {
    pub minImageCount: uint32_t,
    pub maxImageCount: uint32_t,
    pub currentExtent: VkExtent2D,
    pub minImageExtent: VkExtent2D,
    pub maxImageExtent: VkExtent2D,
    pub maxImageArrayLayers: uint32_t,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub currentTransform: VkSurfaceTransformFlagBitsKHR,
    pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
    pub supportedUsageFlags: VkImageUsageFlags,
}

impl Default for VkSurfaceCapabilitiesKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSurfaceFormatKHR {
    pub format: VkFormat,
    pub colorSpace: VkColorSpaceKHR,
}

impl Default for VkSurfaceFormatKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

pub type PFN_vkDestroySurfaceKHR = unsafe extern "C" fn(
    instance: VkInstance,
    surface: VkSurfaceKHR,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkGetPhysicalDeviceSurfaceSupportKHR =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        queueFamilyIndex: uint32_t,
        surface: VkSurfaceKHR,
        pSupported: *mut VkBool32,
    ) -> VkResult;
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilitiesKHR,
    ) -> VkResult;
pub type PFN_vkGetPhysicalDeviceSurfaceFormatsKHR =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceFormatCount: *mut uint32_t,
        pSurfaceFormats: *mut VkSurfaceFormatKHR,
    ) -> VkResult;
pub type PFN_vkGetPhysicalDeviceSurfacePresentModesKHR =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pPresentModeCount: *mut uint32_t,
        pPresentModes: *mut VkPresentModeKHR,
    ) -> VkResult;

pub enum VkSwapchainKHR_T {}

pub type VkSwapchainKHR = *mut VkSwapchainKHR_T;
pub type VkSwapchainCreateFlagsKHR = VkFlags;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkSwapchainCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkSwapchainCreateFlagsKHR,
    pub surface: VkSurfaceKHR,
    pub minImageCount: uint32_t,
    pub imageFormat: VkFormat,
    pub imageColorSpace: VkColorSpaceKHR,
    pub imageExtent: VkExtent2D,
    pub imageArrayLayers: uint32_t,
    pub imageUsage: VkImageUsageFlags,
    pub imageSharingMode: VkSharingMode,
    pub queueFamilyIndexCount: uint32_t,
    pub pQueueFamilyIndices: *const uint32_t,
    pub preTransform: VkSurfaceTransformFlagBitsKHR,
    pub compositeAlpha: VkCompositeAlphaFlagBitsKHR,
    pub presentMode: VkPresentModeKHR,
    pub clipped: VkBool32,
    pub oldSwapchain: VkSwapchainKHR,
}

impl Default for VkSwapchainCreateInfoKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub waitSemaphoreCount: uint32_t,
    pub pWaitSemaphores: *const VkSemaphore,
    pub swapchainCount: uint32_t,
    pub pSwapchains: *const VkSwapchainKHR,
    pub pImageIndices: *const uint32_t,
    pub pResults: *mut VkResult,
}

impl Default for VkPresentInfoKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

pub type PFN_vkCreateSwapchainKHR =
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchain: *mut VkSwapchainKHR,
    ) -> VkResult;
pub type PFN_vkDestroySwapchainKHR = unsafe extern "C" fn(
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pAllocator: *const VkAllocationCallbacks,
);
pub type PFN_vkGetSwapchainImagesKHR = unsafe extern "C" fn(
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    pSwapchainImageCount: *mut uint32_t,
    pSwapchainImages: *mut VkImage,
) -> VkResult;
pub type PFN_vkAcquireNextImageKHR = unsafe extern "C" fn(
    device: VkDevice,
    swapchain: VkSwapchainKHR,
    timeout: uint64_t,
    semaphore: VkSemaphore,
    fence: VkFence,
    pImageIndex: *mut uint32_t,
) -> VkResult;
pub type PFN_vkQueuePresentKHR =
    unsafe extern "C" fn(queue: VkQueue, pPresentInfo: *const VkPresentInfoKHR) -> VkResult;

pub enum VkDisplayKHR_T {}

pub type VkDisplayKHR = *mut VkDisplayKHR_T;

pub enum VkDisplayModeKHR_T {}

pub type VkDisplayModeKHR = *mut VkDisplayModeKHR_T;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 2,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 4,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 8,
    VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}

pub type VkDisplayPlaneAlphaFlagsKHR = VkFlags;
pub type VkDisplayModeCreateFlagsKHR = VkFlags;
pub type VkDisplaySurfaceCreateFlagsKHR = VkFlags;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDisplayPropertiesKHR {
    pub display: VkDisplayKHR,
    pub displayName: *const c_char,
    pub physicalDimensions: VkExtent2D,
    pub physicalResolution: VkExtent2D,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub planeReorderPossible: VkBool32,
    pub persistentContent: VkBool32,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkDisplayPropertiesKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDisplayModeParametersKHR {
    pub visibleRegion: VkExtent2D,
    pub refreshRate: uint32_t,
}

impl Default for VkDisplayModeParametersKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDisplayModePropertiesKHR {
    pub displayMode: VkDisplayModeKHR,
    pub parameters: VkDisplayModeParametersKHR,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkDisplayModePropertiesKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDisplayModeCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkDisplayModeCreateFlagsKHR,
    pub parameters: VkDisplayModeParametersKHR,
}

impl Default for VkDisplayModeCreateInfoKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDisplayPlaneCapabilitiesKHR {
    pub supportedAlpha: VkDisplayPlaneAlphaFlagsKHR,
    pub minSrcPosition: VkOffset2D,
    pub maxSrcPosition: VkOffset2D,
    pub minSrcExtent: VkExtent2D,
    pub maxSrcExtent: VkExtent2D,
    pub minDstPosition: VkOffset2D,
    pub maxDstPosition: VkOffset2D,
    pub minDstExtent: VkExtent2D,
    pub maxDstExtent: VkExtent2D,
}

impl Default for VkDisplayPlaneCapabilitiesKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDisplayPlanePropertiesKHR {
    pub currentDisplay: VkDisplayKHR,
    pub currentStackIndex: uint32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkDisplayPlanePropertiesKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDisplaySurfaceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkDisplaySurfaceCreateFlagsKHR,
    pub displayMode: VkDisplayModeKHR,
    pub planeIndex: uint32_t,
    pub planeStackIndex: uint32_t,
    pub transform: VkSurfaceTransformFlagBitsKHR,
    pub globalAlpha: f32,
    pub alphaMode: VkDisplayPlaneAlphaFlagBitsKHR,
    pub imageExtent: VkExtent2D,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkDisplaySurfaceCreateInfoKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

pub type PFN_vkGetPhysicalDeviceDisplayPropertiesKHR =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkDisplayPropertiesKHR,
    ) -> VkResult;
pub type PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkDisplayPlanePropertiesKHR,
    ) -> VkResult;
pub type PFN_vkGetDisplayPlaneSupportedDisplaysKHR =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        planeIndex: uint32_t,
        pDisplayCount: *mut uint32_t,
        pDisplays: *mut VkDisplayKHR,
    ) -> VkResult;
pub type PFN_vkGetDisplayModePropertiesKHR =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkDisplayModePropertiesKHR,
    ) -> VkResult;
pub type PFN_vkCreateDisplayModeKHR =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pCreateInfo: *const VkDisplayModeCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pMode: *mut VkDisplayModeKHR,
    ) -> VkResult;
pub type PFN_vkGetDisplayPlaneCapabilitiesKHR =
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        mode: VkDisplayModeKHR,
        planeIndex: uint32_t,
        pCapabilities: *mut VkDisplayPlaneCapabilitiesKHR,
    ) -> VkResult;
pub type PFN_vkCreateDisplayPlaneSurfaceKHR =
    unsafe extern "C" fn(
        instance: VkInstance,
        pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDisplayPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub srcRect: VkRect2D,
    pub dstRect: VkRect2D,
    pub persistent: VkBool32,
    _bindgen_padding_0_: [u8; 4usize],
}

impl Default for VkDisplayPresentInfoKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

pub type PFN_vkCreateSharedSwapchainsKHR =
    unsafe extern "C" fn(
        device: VkDevice,
        swapchainCount: uint32_t,
        pCreateInfos: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchains: *mut VkSwapchainKHR,
    ) -> VkResult;

pub enum VkDebugReportCallbackEXT_T {}

pub type VkDebugReportCallbackEXT = *mut VkDebugReportCallbackEXT_T;

pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT:
    VkDebugReportObjectTypeEXT = 0;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT:
    VkDebugReportObjectTypeEXT = 1;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT:
    VkDebugReportObjectTypeEXT = 2;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT:
    VkDebugReportObjectTypeEXT = 3;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT:
    VkDebugReportObjectTypeEXT = 4;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT:
    VkDebugReportObjectTypeEXT = 5;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT:
    VkDebugReportObjectTypeEXT = 6;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT:
    VkDebugReportObjectTypeEXT = 7;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT:
    VkDebugReportObjectTypeEXT = 8;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT:
    VkDebugReportObjectTypeEXT = 9;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT:
    VkDebugReportObjectTypeEXT = 10;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT:
    VkDebugReportObjectTypeEXT = 11;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT:
    VkDebugReportObjectTypeEXT = 12;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT:
    VkDebugReportObjectTypeEXT = 13;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT:
    VkDebugReportObjectTypeEXT = 14;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT:
    VkDebugReportObjectTypeEXT = 15;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT:
    VkDebugReportObjectTypeEXT = 16;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT:
    VkDebugReportObjectTypeEXT = 17;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT:
    VkDebugReportObjectTypeEXT = 18;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT:
    VkDebugReportObjectTypeEXT = 19;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT:
    VkDebugReportObjectTypeEXT = 20;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT:
    VkDebugReportObjectTypeEXT = 21;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT:
    VkDebugReportObjectTypeEXT = 22;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT:
    VkDebugReportObjectTypeEXT = 23;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT:
    VkDebugReportObjectTypeEXT = 24;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT:
    VkDebugReportObjectTypeEXT = 25;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT:
    VkDebugReportObjectTypeEXT = 26;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT:
    VkDebugReportObjectTypeEXT = 27;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT:
    VkDebugReportObjectTypeEXT = 28;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT:
    VkDebugReportObjectTypeEXT = 29;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT:
    VkDebugReportObjectTypeEXT = 30;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT:
    VkDebugReportObjectTypeEXT = 31;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT : VkDebugReportObjectTypeEXT = 32 ;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT:
    VkDebugReportObjectTypeEXT = 33;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT:
    VkDebugReportObjectTypeEXT = 1000156000;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT:
    VkDebugReportObjectTypeEXT = 1000085000;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT : VkDebugReportObjectTypeEXT = 1000085000 ;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT : VkDebugReportObjectTypeEXT = 1000156000 ;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT:
    VkDebugReportObjectTypeEXT = 0;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT:
    VkDebugReportObjectTypeEXT = 33;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT:
    VkDebugReportObjectTypeEXT = 34;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT:
    VkDebugReportObjectTypeEXT = 2147483647;

pub type VkDebugReportObjectTypeEXT = u32;

pub const VK_DEBUG_REPORT_ERROR_BEGIN_RANGE_EXT: VkDebugReportErrorEXT =
    VkDebugReportErrorEXT::VK_DEBUG_REPORT_ERROR_NONE_EXT;
pub const VK_DEBUG_REPORT_ERROR_END_RANGE_EXT: VkDebugReportErrorEXT =
    VkDebugReportErrorEXT::VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT;

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkDebugReportErrorEXT {
    VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
    VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
    VK_DEBUG_REPORT_ERROR_RANGE_SIZE_EXT = 2,
    VK_DEBUG_REPORT_ERROR_MAX_ENUM_EXT = 2147483647,
}

#[derive(Copy, Clone, Debug)]
#[repr(u32)]
pub enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 1,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 2,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 4,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 8,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 16,
    VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 2147483647,
}

pub type VkDebugReportFlagsEXT = VkFlags;
pub type PFN_vkDebugReportCallbackEXT =
    unsafe extern "C" fn(
        flags: VkDebugReportFlagsEXT,
        objectType: VkDebugReportObjectTypeEXT,
        object: uint64_t,
        location: size_t,
        messageCode: int32_t,
        pLayerPrefix: *const c_char,
        pMessage: *const c_char,
        pUserData: *mut c_void,
    ) -> VkBool32;

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkDebugReportCallbackCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkDebugReportFlagsEXT,
    pub pfnCallback: PFN_vkDebugReportCallbackEXT,
    pub pUserData: *mut c_void,
}

impl Default for VkDebugReportCallbackCreateInfoEXT {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

pub type PFN_vkCreateDebugReportCallbackEXT =
    unsafe extern "C" fn(
        instance: VkInstance,
        pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pCallback: *mut VkDebugReportCallbackEXT,
    ) -> VkResult;

pub type PFN_vkDestroyDebugReportCallbackEXT =
    unsafe extern "C" fn(
        instance: VkInstance,
        callback: VkDebugReportCallbackEXT,
        pAllocator: *const VkAllocationCallbacks,
    );

pub type PFN_vkDebugReportMessageEXT = unsafe extern "C" fn(
    instance: VkInstance,
    flags: VkDebugReportFlagsEXT,
    objectType: VkDebugReportObjectTypeEXT,
    object: uint64_t,
    location: size_t,
    messageCode: int32_t,
    pLayerPrefix: *const c_char,
    pMessage: *const c_char,
);

pub const VK_KHR_ANDROID_SURFACE_SPEC_VERSION: u32 = 6u32;
pub const VK_KHR_ANDROID_SURFACE_EXTENSION_NAME: &'static str = "VK_KHR_android_surface";

type VkAndroidSurfaceCreateFlagsKHR = VkFlags;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAndroidSurfaceCreateInfoKHR {
    pub structure_type: VkStructureType,
    pub pointer_next: *const c_void,
    pub flags: VkAndroidSurfaceCreateFlagsKHR,
    pub window: *mut c_void,
}

impl Default for VkAndroidSurfaceCreateInfoKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

pub type PFN_VkCreateAndroidSurfaceKhr =
    unsafe extern "C" fn(
        instance: VkInstance,
        p_create_info: *const VkAndroidSurfaceCreateInfoKHR,
        p_allocator: *const VkAllocationCallbacks,
        p_surface: *mut VkSurfaceKHR,
    ) -> VkResult;

type VkIOSSurfaceCreateFlagsMVK = VkFlags;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkIOSSurfaceCreateInfoMVK {
    pub structure_type: VkStructureType,
    pub pointer_next: *const c_void,
    pub flags: VkIOSSurfaceCreateFlagsMVK,
    pub view: *const c_void,
}

impl Default for VkIOSSurfaceCreateInfoMVK {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

pub type PFN_VkCreateIOSSurfaceMVK =
    unsafe extern "C" fn(
        instance: VkInstance,
        p_create_info: *const VkIOSSurfaceCreateInfoMVK,
        p_allocator: *const VkAllocationCallbacks,
        p_surface: *mut VkSurfaceKHR,
    ) -> VkResult;

type VkMacOSSurfaceCreateFlagsMVK = VkFlags;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMacOSSurfaceCreateInfoMVK {
    pub structure_type: VkStructureType,
    pub pointer_next: *const c_void,
    pub flags: VkMacOSSurfaceCreateFlagsMVK,
    pub view: *const c_void,
}

impl Default for VkMacOSSurfaceCreateInfoMVK {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

pub type PFN_VkCreateMacOSSurfaceMVK =
    unsafe extern "C" fn(
        instance: VkInstance,
        p_create_info: *const VkMacOSSurfaceCreateInfoMVK,
        p_allocator: *const VkAllocationCallbacks,
        p_surface: *mut VkSurfaceKHR,
    ) -> VkResult;

#[cfg(target_os = "linux")]
pub type VkXcbSurfaceCreateFlagsKHR = VkFlags;

#[cfg(target_os = "linux")]
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkXcbSurfaceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkXcbSurfaceCreateFlagsKHR,
    pub connection: *mut super::super::system::os::xcb::xcb_connection_t,
    pub window: super::super::system::os::xcb::xcb_window_t,
}
#[cfg(target_os = "linux")]
impl Default for VkXcbSurfaceCreateInfoKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

pub type VkWin32SurfaceCreateFlagsKHR = VkFlags;

#[cfg(target_os = "windows")]
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct VkWin32SurfaceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const c_void,
    pub flags: VkWin32SurfaceCreateFlagsKHR,
    pub hinstance: winapi::shared::minwindef::HINSTANCE,
    pub hwnd: winapi::shared::windef::HWND,
}

#[cfg(target_os = "windows")]
impl Default for VkWin32SurfaceCreateInfoKHR {
    fn default() -> Self {
        unsafe { zeroed() }
    }
}

#[cfg_attr(target_os = "linux", link(name = "vulkan", kind = "dylib"))]
#[cfg_attr(
    target_os = "windows",
    link(name = "vulkan-1", kind = "dylib")
)]
#[cfg_attr(target_os = "android", link(name = "vulkan", kind = "dylib"))]
#[cfg_attr(target_os = "macos", link(name = "vulkan", kind = "dylib"))]
extern "C" {
    pub fn vkCreateInstance(
        pCreateInfo: *const VkInstanceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pInstance: *mut VkInstance,
    ) -> VkResult;
    pub fn vkDestroyInstance(instance: VkInstance, pAllocator: *const VkAllocationCallbacks);
    pub fn vkEnumeratePhysicalDevices(
        instance: VkInstance,
        pPhysicalDeviceCount: *mut uint32_t,
        pPhysicalDevices: *mut VkPhysicalDevice,
    ) -> VkResult;
    pub fn vkGetPhysicalDeviceFeatures(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures,
    );
    pub fn vkGetPhysicalDeviceFormatProperties(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties,
    );
    pub fn vkGetPhysicalDeviceImageFormatProperties(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        tiling: VkImageTiling,
        usage: VkImageUsageFlags,
        flags: VkImageCreateFlags,
        pImageFormatProperties: *mut VkImageFormatProperties,
    ) -> VkResult;
    pub fn vkGetPhysicalDeviceProperties(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties,
    );
    pub fn vkGetPhysicalDeviceQueueFamilyProperties(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut uint32_t,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties,
    );
    pub fn vkGetPhysicalDeviceMemoryProperties(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties,
    );
    pub fn vkGetInstanceProcAddr(instance: VkInstance, pName: *const c_char) -> PFN_vkVoidFunction;
    pub fn vkGetDeviceProcAddr(device: VkDevice, pName: *const c_char) -> PFN_vkVoidFunction;
    pub fn vkCreateDevice(
        physicalDevice: VkPhysicalDevice,
        pCreateInfo: *const VkDeviceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDevice: *mut VkDevice,
    ) -> VkResult;
    pub fn vkDestroyDevice(device: VkDevice, pAllocator: *const VkAllocationCallbacks);
    pub fn vkEnumerateInstanceExtensionProperties(
        pLayerName: *const c_char,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult;
    pub fn vkEnumerateDeviceExtensionProperties(
        physicalDevice: VkPhysicalDevice,
        pLayerName: *const c_char,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult;
    pub fn vkEnumerateInstanceLayerProperties(
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkLayerProperties,
    ) -> VkResult;
    pub fn vkEnumerateDeviceLayerProperties(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkLayerProperties,
    ) -> VkResult;
    pub fn vkGetDeviceQueue(
        device: VkDevice,
        queueFamilyIndex: uint32_t,
        queueIndex: uint32_t,
        pQueue: *mut VkQueue,
    );
    pub fn vkQueueSubmit(
        queue: VkQueue,
        submitCount: uint32_t,
        pSubmits: *const VkSubmitInfo,
        fence: VkFence,
    ) -> VkResult;
    pub fn vkQueueWaitIdle(queue: VkQueue) -> VkResult;
    pub fn vkDeviceWaitIdle(device: VkDevice) -> VkResult;
    pub fn vkAllocateMemory(
        device: VkDevice,
        pAllocateInfo: *const VkMemoryAllocateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pMemory: *mut VkDeviceMemory,
    ) -> VkResult;
    pub fn vkFreeMemory(
        device: VkDevice,
        memory: VkDeviceMemory,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkMapMemory(
        device: VkDevice,
        memory: VkDeviceMemory,
        offset: VkDeviceSize,
        size: VkDeviceSize,
        flags: VkMemoryMapFlags,
        ppData: *mut *mut c_void,
    ) -> VkResult;
    pub fn vkUnmapMemory(device: VkDevice, memory: VkDeviceMemory);
    pub fn vkFlushMappedMemoryRanges(
        device: VkDevice,
        memoryRangeCount: uint32_t,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult;
    pub fn vkInvalidateMappedMemoryRanges(
        device: VkDevice,
        memoryRangeCount: uint32_t,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult;
    pub fn vkGetDeviceMemoryCommitment(
        device: VkDevice,
        memory: VkDeviceMemory,
        pCommittedMemoryInBytes: *mut VkDeviceSize,
    );
    pub fn vkBindBufferMemory(
        device: VkDevice,
        buffer: VkBuffer,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult;
    pub fn vkBindImageMemory(
        device: VkDevice,
        image: VkImage,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult;
    pub fn vkGetBufferMemoryRequirements(
        device: VkDevice,
        buffer: VkBuffer,
        pMemoryRequirements: *mut VkMemoryRequirements,
    );
    pub fn vkGetImageMemoryRequirements(
        device: VkDevice,
        image: VkImage,
        pMemoryRequirements: *mut VkMemoryRequirements,
    );
    pub fn vkGetImageSparseMemoryRequirements(
        device: VkDevice,
        image: VkImage,
        pSparseMemoryRequirementCount: *mut uint32_t,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements,
    );
    pub fn vkGetPhysicalDeviceSparseImageFormatProperties(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        samples: VkSampleCountFlagBits,
        usage: VkImageUsageFlags,
        tiling: VkImageTiling,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkSparseImageFormatProperties,
    );
    pub fn vkQueueBindSparse(
        queue: VkQueue,
        bindInfoCount: uint32_t,
        pBindInfo: *const VkBindSparseInfo,
        fence: VkFence,
    ) -> VkResult;
    pub fn vkCreateFence(
        device: VkDevice,
        pCreateInfo: *const VkFenceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult;
    pub fn vkDestroyFence(
        device: VkDevice,
        fence: VkFence,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkResetFences(
        device: VkDevice,
        fenceCount: uint32_t,
        pFences: *const VkFence,
    ) -> VkResult;
    pub fn vkGetFenceStatus(device: VkDevice, fence: VkFence) -> VkResult;
    pub fn vkWaitForFences(
        device: VkDevice,
        fenceCount: uint32_t,
        pFences: *const VkFence,
        waitAll: VkBool32,
        timeout: uint64_t,
    ) -> VkResult;
    pub fn vkCreateSemaphore(
        device: VkDevice,
        pCreateInfo: *const VkSemaphoreCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSemaphore: *mut VkSemaphore,
    ) -> VkResult;
    pub fn vkDestroySemaphore(
        device: VkDevice,
        semaphore: VkSemaphore,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkCreateEvent(
        device: VkDevice,
        pCreateInfo: *const VkEventCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pEvent: *mut VkEvent,
    ) -> VkResult;
    pub fn vkDestroyEvent(
        device: VkDevice,
        event: VkEvent,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkGetEventStatus(device: VkDevice, event: VkEvent) -> VkResult;
    pub fn vkSetEvent(device: VkDevice, event: VkEvent) -> VkResult;
    pub fn vkResetEvent(device: VkDevice, event: VkEvent) -> VkResult;
    pub fn vkCreateQueryPool(
        device: VkDevice,
        pCreateInfo: *const VkQueryPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pQueryPool: *mut VkQueryPool,
    ) -> VkResult;
    pub fn vkDestroyQueryPool(
        device: VkDevice,
        queryPool: VkQueryPool,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkGetQueryPoolResults(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: uint32_t,
        queryCount: uint32_t,
        dataSize: size_t,
        pData: *mut c_void,
        stride: VkDeviceSize,
        flags: VkQueryResultFlags,
    ) -> VkResult;
    pub fn vkCreateBuffer(
        device: VkDevice,
        pCreateInfo: *const VkBufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pBuffer: *mut VkBuffer,
    ) -> VkResult;
    pub fn vkDestroyBuffer(
        device: VkDevice,
        buffer: VkBuffer,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkCreateBufferView(
        device: VkDevice,
        pCreateInfo: *const VkBufferViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkBufferView,
    ) -> VkResult;
    pub fn vkDestroyBufferView(
        device: VkDevice,
        bufferView: VkBufferView,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkCreateImage(
        device: VkDevice,
        pCreateInfo: *const VkImageCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pImage: *mut VkImage,
    ) -> VkResult;
    pub fn vkDestroyImage(
        device: VkDevice,
        image: VkImage,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkGetImageSubresourceLayout(
        device: VkDevice,
        image: VkImage,
        pSubresource: *const VkImageSubresource,
        pLayout: *mut VkSubresourceLayout,
    );
    pub fn vkCreateImageView(
        device: VkDevice,
        pCreateInfo: *const VkImageViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkImageView,
    ) -> VkResult;
    pub fn vkDestroyImageView(
        device: VkDevice,
        imageView: VkImageView,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkCreateShaderModule(
        device: VkDevice,
        pCreateInfo: *const VkShaderModuleCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pShaderModule: *mut VkShaderModule,
    ) -> VkResult;
    pub fn vkDestroyShaderModule(
        device: VkDevice,
        shaderModule: VkShaderModule,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkCreatePipelineCache(
        device: VkDevice,
        pCreateInfo: *const VkPipelineCacheCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineCache: *mut VkPipelineCache,
    ) -> VkResult;
    pub fn vkDestroyPipelineCache(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkGetPipelineCacheData(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        pDataSize: *mut size_t,
        pData: *mut c_void,
    ) -> VkResult;
    pub fn vkMergePipelineCaches(
        device: VkDevice,
        dstCache: VkPipelineCache,
        srcCacheCount: uint32_t,
        pSrcCaches: *const VkPipelineCache,
    ) -> VkResult;
    pub fn vkCreateGraphicsPipelines(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: uint32_t,
        pCreateInfos: *const VkGraphicsPipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult;
    pub fn vkCreateComputePipelines(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: uint32_t,
        pCreateInfos: *const VkComputePipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult;
    pub fn vkDestroyPipeline(
        device: VkDevice,
        pipeline: VkPipeline,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkCreatePipelineLayout(
        device: VkDevice,
        pCreateInfo: *const VkPipelineLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineLayout: *mut VkPipelineLayout,
    ) -> VkResult;
    pub fn vkDestroyPipelineLayout(
        device: VkDevice,
        pipelineLayout: VkPipelineLayout,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkCreateSampler(
        device: VkDevice,
        pCreateInfo: *const VkSamplerCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSampler: *mut VkSampler,
    ) -> VkResult;
    pub fn vkDestroySampler(
        device: VkDevice,
        sampler: VkSampler,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkCreateDescriptorSetLayout(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSetLayout: *mut VkDescriptorSetLayout,
    ) -> VkResult;
    pub fn vkDestroyDescriptorSetLayout(
        device: VkDevice,
        descriptorSetLayout: VkDescriptorSetLayout,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkCreateDescriptorPool(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorPool: *mut VkDescriptorPool,
    ) -> VkResult;
    pub fn vkDestroyDescriptorPool(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkResetDescriptorPool(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        flags: VkDescriptorPoolResetFlags,
    ) -> VkResult;
    pub fn vkAllocateDescriptorSets(
        device: VkDevice,
        pAllocateInfo: *const VkDescriptorSetAllocateInfo,
        pDescriptorSets: *mut VkDescriptorSet,
    ) -> VkResult;
    pub fn vkFreeDescriptorSets(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        descriptorSetCount: uint32_t,
        pDescriptorSets: *const VkDescriptorSet,
    ) -> VkResult;
    pub fn vkUpdateDescriptorSets(
        device: VkDevice,
        descriptorWriteCount: uint32_t,
        pDescriptorWrites: *const VkWriteDescriptorSet,
        descriptorCopyCount: uint32_t,
        pDescriptorCopies: *const VkCopyDescriptorSet,
    );
    pub fn vkCreateFramebuffer(
        device: VkDevice,
        pCreateInfo: *const VkFramebufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pFramebuffer: *mut VkFramebuffer,
    ) -> VkResult;
    pub fn vkDestroyFramebuffer(
        device: VkDevice,
        framebuffer: VkFramebuffer,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkCreateRenderPass(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult;
    pub fn vkDestroyRenderPass(
        device: VkDevice,
        renderPass: VkRenderPass,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkGetRenderAreaGranularity(
        device: VkDevice,
        renderPass: VkRenderPass,
        pGranularity: *mut VkExtent2D,
    );
    pub fn vkCreateCommandPool(
        device: VkDevice,
        pCreateInfo: *const VkCommandPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pCommandPool: *mut VkCommandPool,
    ) -> VkResult;
    pub fn vkDestroyCommandPool(
        device: VkDevice,
        commandPool: VkCommandPool,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkResetCommandPool(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolResetFlags,
    ) -> VkResult;
    pub fn vkAllocateCommandBuffers(
        device: VkDevice,
        pAllocateInfo: *const VkCommandBufferAllocateInfo,
        pCommandBuffers: *mut VkCommandBuffer,
    ) -> VkResult;
    pub fn vkFreeCommandBuffers(
        device: VkDevice,
        commandPool: VkCommandPool,
        commandBufferCount: uint32_t,
        pCommandBuffers: *const VkCommandBuffer,
    );
    pub fn vkBeginCommandBuffer(
        commandBuffer: VkCommandBuffer,
        pBeginInfo: *const VkCommandBufferBeginInfo,
    ) -> VkResult;
    pub fn vkEndCommandBuffer(commandBuffer: VkCommandBuffer) -> VkResult;
    pub fn vkResetCommandBuffer(
        commandBuffer: VkCommandBuffer,
        flags: VkCommandBufferResetFlags,
    ) -> VkResult;
    pub fn vkCmdBindPipeline(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        pipeline: VkPipeline,
    );
    pub fn vkCmdSetViewport(
        commandBuffer: VkCommandBuffer,
        firstViewport: uint32_t,
        viewportCount: uint32_t,
        pViewports: *const VkViewport,
    );
    pub fn vkCmdSetScissor(
        commandBuffer: VkCommandBuffer,
        firstScissor: uint32_t,
        scissorCount: uint32_t,
        pScissors: *const VkRect2D,
    );
    pub fn vkCmdSetLineWidth(commandBuffer: VkCommandBuffer, lineWidth: f32);
    pub fn vkCmdSetDepthBias(
        commandBuffer: VkCommandBuffer,
        depthBiasConstantFactor: f32,
        depthBiasClamp: f32,
        depthBiasSlopeFactor: f32,
    );
    pub fn vkCmdSetBlendConstants(commandBuffer: VkCommandBuffer, blendConstants: *mut f32);
    pub fn vkCmdSetDepthBounds(
        commandBuffer: VkCommandBuffer,
        minDepthBounds: f32,
        maxDepthBounds: f32,
    );
    pub fn vkCmdSetStencilCompareMask(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        compareMask: uint32_t,
    );
    pub fn vkCmdSetStencilWriteMask(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        writeMask: uint32_t,
    );
    pub fn vkCmdSetStencilReference(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        reference: uint32_t,
    );
    pub fn vkCmdBindDescriptorSets(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        firstSet: uint32_t,
        descriptorSetCount: uint32_t,
        pDescriptorSets: *const VkDescriptorSet,
        dynamicOffsetCount: uint32_t,
        pDynamicOffsets: *const uint32_t,
    );
    pub fn vkCmdBindIndexBuffer(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        indexType: VkIndexType,
    );
    pub fn vkCmdBindVertexBuffers(
        commandBuffer: VkCommandBuffer,
        firstBinding: uint32_t,
        bindingCount: uint32_t,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
    );
    pub fn vkCmdDraw(
        commandBuffer: VkCommandBuffer,
        vertexCount: uint32_t,
        instanceCount: uint32_t,
        firstVertex: uint32_t,
        firstInstance: uint32_t,
    );
    pub fn vkCmdDrawIndexed(
        commandBuffer: VkCommandBuffer,
        indexCount: uint32_t,
        instanceCount: uint32_t,
        firstIndex: uint32_t,
        vertexOffset: int32_t,
        firstInstance: uint32_t,
    );
    pub fn vkCmdDrawIndirect(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: uint32_t,
        stride: uint32_t,
    );
    pub fn vkCmdDrawIndexedIndirect(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: uint32_t,
        stride: uint32_t,
    );
    pub fn vkCmdDispatch(commandBuffer: VkCommandBuffer, x: uint32_t, y: uint32_t, z: uint32_t);
    pub fn vkCmdDispatchIndirect(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
    );
    pub fn vkCmdCopyBuffer(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstBuffer: VkBuffer,
        regionCount: uint32_t,
        pRegions: *const VkBufferCopy,
    );
    pub fn vkCmdCopyImage(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: uint32_t,
        pRegions: *const VkImageCopy,
    );
    pub fn vkCmdBlitImage(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: uint32_t,
        pRegions: *const VkImageBlit,
        filter: VkFilter,
    );
    pub fn vkCmdCopyBufferToImage(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: uint32_t,
        pRegions: *const VkBufferImageCopy,
    );
    pub fn vkCmdCopyImageToBuffer(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstBuffer: VkBuffer,
        regionCount: uint32_t,
        pRegions: *const VkBufferImageCopy,
    );
    pub fn vkCmdUpdateBuffer(
        commandBuffer: VkCommandBuffer,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        dataSize: VkDeviceSize,
        pData: *const uint32_t,
    );
    pub fn vkCmdFillBuffer(
        commandBuffer: VkCommandBuffer,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        size: VkDeviceSize,
        data: uint32_t,
    );
    pub fn vkCmdClearColorImage(
        commandBuffer: VkCommandBuffer,
        image: VkImage,
        imageLayout: VkImageLayout,
        pColor: *const VkClearColorValue,
        rangeCount: uint32_t,
        pRanges: *const VkImageSubresourceRange,
    );
    pub fn vkCmdClearDepthStencilImage(
        commandBuffer: VkCommandBuffer,
        image: VkImage,
        imageLayout: VkImageLayout,
        pDepthStencil: *const VkClearDepthStencilValue,
        rangeCount: uint32_t,
        pRanges: *const VkImageSubresourceRange,
    );
    pub fn vkCmdClearAttachments(
        commandBuffer: VkCommandBuffer,
        attachmentCount: uint32_t,
        pAttachments: *const VkClearAttachment,
        rectCount: uint32_t,
        pRects: *const VkClearRect,
    );
    pub fn vkCmdResolveImage(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: uint32_t,
        pRegions: *const VkImageResolve,
    );
    pub fn vkCmdSetEvent(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags,
    );
    pub fn vkCmdResetEvent(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags,
    );
    pub fn vkCmdWaitEvents(
        commandBuffer: VkCommandBuffer,
        eventCount: uint32_t,
        pEvents: *const VkEvent,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        memoryBarrierCount: uint32_t,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: uint32_t,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: uint32_t,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    );
    pub fn vkCmdPipelineBarrier(
        commandBuffer: VkCommandBuffer,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        dependencyFlags: VkDependencyFlags,
        memoryBarrierCount: uint32_t,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: uint32_t,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: uint32_t,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    );
    pub fn vkCmdBeginQuery(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: uint32_t,
        flags: VkQueryControlFlags,
    );
    pub fn vkCmdEndQuery(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: uint32_t);
    pub fn vkCmdResetQueryPool(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        firstQuery: uint32_t,
        queryCount: uint32_t,
    );
    pub fn vkCmdWriteTimestamp(
        commandBuffer: VkCommandBuffer,
        pipelineStage: VkPipelineStageFlagBits,
        queryPool: VkQueryPool,
        query: uint32_t,
    );
    pub fn vkCmdCopyQueryPoolResults(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        firstQuery: uint32_t,
        queryCount: uint32_t,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        stride: VkDeviceSize,
        flags: VkQueryResultFlags,
    );
    pub fn vkCmdPushConstants(
        commandBuffer: VkCommandBuffer,
        layout: VkPipelineLayout,
        stageFlags: VkShaderStageFlags,
        offset: uint32_t,
        size: uint32_t,
        pValues: *const c_void,
    );
    pub fn vkCmdBeginRenderPass(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        contents: VkSubpassContents,
    );
    pub fn vkCmdNextSubpass(commandBuffer: VkCommandBuffer, contents: VkSubpassContents);
    pub fn vkCmdEndRenderPass(commandBuffer: VkCommandBuffer);
    pub fn vkCmdExecuteCommands(
        commandBuffer: VkCommandBuffer,
        commandBufferCount: uint32_t,
        pCommandBuffers: *const VkCommandBuffer,
    );
    pub fn vkDestroySurfaceKHR(
        instance: VkInstance,
        surface: VkSurfaceKHR,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkGetPhysicalDeviceSurfaceSupportKHR(
        physicalDevice: VkPhysicalDevice,
        queueFamilyIndex: uint32_t,
        surface: VkSurfaceKHR,
        pSupported: *mut VkBool32,
    ) -> VkResult;
    pub fn vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilitiesKHR,
    ) -> VkResult;
    pub fn vkGetPhysicalDeviceSurfaceFormatsKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceFormatCount: *mut uint32_t,
        pSurfaceFormats: *mut VkSurfaceFormatKHR,
    ) -> VkResult;
    pub fn vkGetPhysicalDeviceSurfacePresentModesKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pPresentModeCount: *mut uint32_t,
        pPresentModes: *mut VkPresentModeKHR,
    ) -> VkResult;
    pub fn vkCreateSwapchainKHR(
        device: VkDevice,
        pCreateInfo: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchain: *mut VkSwapchainKHR,
    ) -> VkResult;
    pub fn vkDestroySwapchainKHR(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkGetSwapchainImagesKHR(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pSwapchainImageCount: *mut uint32_t,
        pSwapchainImages: *mut VkImage,
    ) -> VkResult;
    pub fn vkAcquireNextImageKHR(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        timeout: uint64_t,
        semaphore: VkSemaphore,
        fence: VkFence,
        pImageIndex: *mut uint32_t,
    ) -> VkResult;
    pub fn vkQueuePresentKHR(queue: VkQueue, pPresentInfo: *const VkPresentInfoKHR) -> VkResult;
    pub fn vkGetPhysicalDeviceDisplayPropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkDisplayPropertiesKHR,
    ) -> VkResult;
    pub fn vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkDisplayPlanePropertiesKHR,
    ) -> VkResult;
    pub fn vkGetDisplayPlaneSupportedDisplaysKHR(
        physicalDevice: VkPhysicalDevice,
        planeIndex: uint32_t,
        pDisplayCount: *mut uint32_t,
        pDisplays: *mut VkDisplayKHR,
    ) -> VkResult;
    pub fn vkGetDisplayModePropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pPropertyCount: *mut uint32_t,
        pProperties: *mut VkDisplayModePropertiesKHR,
    ) -> VkResult;
    pub fn vkCreateDisplayModeKHR(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pCreateInfo: *const VkDisplayModeCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pMode: *mut VkDisplayModeKHR,
    ) -> VkResult;
    pub fn vkGetDisplayPlaneCapabilitiesKHR(
        physicalDevice: VkPhysicalDevice,
        mode: VkDisplayModeKHR,
        planeIndex: uint32_t,
        pCapabilities: *mut VkDisplayPlaneCapabilitiesKHR,
    ) -> VkResult;
    pub fn vkCreateDisplayPlaneSurfaceKHR(
        instance: VkInstance,
        pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult;
    pub fn vkCreateSharedSwapchainsKHR(
        device: VkDevice,
        swapchainCount: uint32_t,
        pCreateInfos: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchains: *mut VkSwapchainKHR,
    ) -> VkResult;
    pub fn vkCreateDebugReportCallbackEXT(
        instance: VkInstance,
        pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pCallback: *mut VkDebugReportCallbackEXT,
    ) -> VkResult;
    pub fn vkDestroyDebugReportCallbackEXT(
        instance: VkInstance,
        callback: VkDebugReportCallbackEXT,
        pAllocator: *const VkAllocationCallbacks,
    );
    pub fn vkDebugReportMessageEXT(
        instance: VkInstance,
        flags: VkDebugReportFlagsEXT,
        objectType: VkDebugReportObjectTypeEXT,
        object: uint64_t,
        location: size_t,
        messageCode: int32_t,
        pLayerPrefix: *const c_char,
        pMessage: *const c_char,
    );
    #[cfg(target_os = "ios")]
    pub fn vkCreateIOSSurfaceMVK(
        instance: VkInstance,
        p_create_info: *const VkIOSSurfaceCreateInfoMVK,
        p_allocator: *const VkAllocationCallbacks,
        p_surface: *mut VkSurfaceKHR,
    ) -> VkResult;
    #[cfg(target_os = "macos")]
    pub fn vkCreateMacOSSurfaceMVK(
        instance: VkInstance,
        p_create_info: *const VkMacOSSurfaceCreateInfoMVK,
        p_allocator: *const VkAllocationCallbacks,
        p_surface: *mut VkSurfaceKHR,
    ) -> VkResult;
    #[cfg(target_os = "android")]
    pub fn vkCreateAndroidSurfaceKHR(
        instance: VkInstance,
        p_create_info: *const VkAndroidSurfaceCreateInfoKHR,
        p_allocator: *const VkAllocationCallbacks,
        p_surface: *mut VkSurfaceKHR,
    ) -> VkResult;
    #[cfg(target_os = "linux")]
    pub fn vkCreateXcbSurfaceKHR(
        instance: VkInstance,
        pCreateInfo: *const VkXcbSurfaceCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult;
    #[cfg(target_os = "windows")]
    pub fn vkCreateWin32SurfaceKHR(
        instance: VkInstance,
        pCreateInfo: *const VkWin32SurfaceCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult;
}

pub fn vkMakeVersion(major: u32, minor: u32, patch: u32) -> u32 {
    (major << 22) | (minor << 12) | patch
}

pub const VK_SUBPASS_EXTERNAL: u32 = !0u32;
