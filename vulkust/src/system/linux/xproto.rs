#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201605;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 24;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const _SYS_UIO_H: ::std::os::raw::c_uint = 1;
pub const _BITS_UIO_H: ::std::os::raw::c_uint = 1;
pub const UIO_MAXIOV: ::std::os::raw::c_uint = 1024;
pub const _PTHREAD_H: ::std::os::raw::c_uint = 1;
pub const _SCHED_H: ::std::os::raw::c_uint = 1;
pub const SCHED_OTHER: ::std::os::raw::c_uint = 0;
pub const SCHED_FIFO: ::std::os::raw::c_uint = 1;
pub const SCHED_RR: ::std::os::raw::c_uint = 2;
pub const __defined_schedparam: ::std::os::raw::c_uint = 1;
pub const __CPU_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _TIME_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TIME_H: ::std::os::raw::c_uint = 1;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 2;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 3;
pub const CLOCK_MONOTONIC_RAW: ::std::os::raw::c_uint = 4;
pub const CLOCK_REALTIME_COARSE: ::std::os::raw::c_uint = 5;
pub const CLOCK_MONOTONIC_COARSE: ::std::os::raw::c_uint = 6;
pub const CLOCK_BOOTTIME: ::std::os::raw::c_uint = 7;
pub const CLOCK_REALTIME_ALARM: ::std::os::raw::c_uint = 8;
pub const CLOCK_BOOTTIME_ALARM: ::std::os::raw::c_uint = 9;
pub const CLOCK_TAI: ::std::os::raw::c_uint = 11;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const TIME_UTC: ::std::os::raw::c_uint = 1;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const _BITS_SETJMP_H: ::std::os::raw::c_uint = 1;
pub const PTHREAD_ONCE_INIT: ::std::os::raw::c_uint = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: ::std::os::raw::c_int = -1;
pub const X_PROTOCOL: ::std::os::raw::c_uint = 11;
pub const X_PROTOCOL_REVISION: ::std::os::raw::c_uint = 0;
pub const X_TCP_PORT: ::std::os::raw::c_uint = 6000;
pub const XCB_CONN_ERROR: ::std::os::raw::c_uint = 1;
pub const XCB_CONN_CLOSED_EXT_NOTSUPPORTED: ::std::os::raw::c_uint = 2;
pub const XCB_CONN_CLOSED_MEM_INSUFFICIENT: ::std::os::raw::c_uint = 3;
pub const XCB_CONN_CLOSED_REQ_LEN_EXCEED: ::std::os::raw::c_uint = 4;
pub const XCB_CONN_CLOSED_PARSE_ERR: ::std::os::raw::c_uint = 5;
pub const XCB_CONN_CLOSED_INVALID_SCREEN: ::std::os::raw::c_uint = 6;
pub const XCB_CONN_CLOSED_FDPASSING_FAILED: ::std::os::raw::c_uint = 7;
pub const XCB_NONE: ::std::os::raw::c_uint = 0;
pub const XCB_COPY_FROM_PARENT: ::std::os::raw::c_uint = 0;
pub const XCB_CURRENT_TIME: ::std::os::raw::c_uint = 0;
pub const XCB_NO_SYMBOL: ::std::os::raw::c_uint = 0;
pub const XCB_KEY_PRESS: ::std::os::raw::c_uint = 2;
pub const XCB_KEY_RELEASE: ::std::os::raw::c_uint = 3;
pub const XCB_BUTTON_PRESS: ::std::os::raw::c_uint = 4;
pub const XCB_BUTTON_RELEASE: ::std::os::raw::c_uint = 5;
pub const XCB_MOTION_NOTIFY: ::std::os::raw::c_uint = 6;
pub const XCB_ENTER_NOTIFY: ::std::os::raw::c_uint = 7;
pub const XCB_LEAVE_NOTIFY: ::std::os::raw::c_uint = 8;
pub const XCB_FOCUS_IN: ::std::os::raw::c_uint = 9;
pub const XCB_FOCUS_OUT: ::std::os::raw::c_uint = 10;
pub const XCB_KEYMAP_NOTIFY: ::std::os::raw::c_uint = 11;
pub const XCB_EXPOSE: ::std::os::raw::c_uint = 12;
pub const XCB_GRAPHICS_EXPOSURE: ::std::os::raw::c_uint = 13;
pub const XCB_NO_EXPOSURE: ::std::os::raw::c_uint = 14;
pub const XCB_VISIBILITY_NOTIFY: ::std::os::raw::c_uint = 15;
pub const XCB_CREATE_NOTIFY: ::std::os::raw::c_uint = 16;
pub const XCB_DESTROY_NOTIFY: ::std::os::raw::c_uint = 17;
pub const XCB_UNMAP_NOTIFY: ::std::os::raw::c_uint = 18;
pub const XCB_MAP_NOTIFY: ::std::os::raw::c_uint = 19;
pub const XCB_MAP_REQUEST: ::std::os::raw::c_uint = 20;
pub const XCB_REPARENT_NOTIFY: ::std::os::raw::c_uint = 21;
pub const XCB_CONFIGURE_NOTIFY: ::std::os::raw::c_uint = 22;
pub const XCB_CONFIGURE_REQUEST: ::std::os::raw::c_uint = 23;
pub const XCB_GRAVITY_NOTIFY: ::std::os::raw::c_uint = 24;
pub const XCB_RESIZE_REQUEST: ::std::os::raw::c_uint = 25;
pub const XCB_CIRCULATE_NOTIFY: ::std::os::raw::c_uint = 26;
pub const XCB_CIRCULATE_REQUEST: ::std::os::raw::c_uint = 27;
pub const XCB_PROPERTY_NOTIFY: ::std::os::raw::c_uint = 28;
pub const XCB_SELECTION_CLEAR: ::std::os::raw::c_uint = 29;
pub const XCB_SELECTION_REQUEST: ::std::os::raw::c_uint = 30;
pub const XCB_SELECTION_NOTIFY: ::std::os::raw::c_uint = 31;
pub const XCB_COLORMAP_NOTIFY: ::std::os::raw::c_uint = 32;
pub const XCB_CLIENT_MESSAGE: ::std::os::raw::c_uint = 33;
pub const XCB_MAPPING_NOTIFY: ::std::os::raw::c_uint = 34;
pub const XCB_GE_GENERIC: ::std::os::raw::c_uint = 35;
pub const XCB_REQUEST: ::std::os::raw::c_uint = 1;
pub const XCB_VALUE: ::std::os::raw::c_uint = 2;
pub const XCB_WINDOW: ::std::os::raw::c_uint = 3;
pub const XCB_PIXMAP: ::std::os::raw::c_uint = 4;
pub const XCB_ATOM: ::std::os::raw::c_uint = 5;
pub const XCB_CURSOR: ::std::os::raw::c_uint = 6;
pub const XCB_FONT: ::std::os::raw::c_uint = 7;
pub const XCB_MATCH: ::std::os::raw::c_uint = 8;
pub const XCB_DRAWABLE: ::std::os::raw::c_uint = 9;
pub const XCB_ACCESS: ::std::os::raw::c_uint = 10;
pub const XCB_ALLOC: ::std::os::raw::c_uint = 11;
pub const XCB_COLORMAP: ::std::os::raw::c_uint = 12;
pub const XCB_G_CONTEXT: ::std::os::raw::c_uint = 13;
pub const XCB_ID_CHOICE: ::std::os::raw::c_uint = 14;
pub const XCB_NAME: ::std::os::raw::c_uint = 15;
pub const XCB_LENGTH: ::std::os::raw::c_uint = 16;
pub const XCB_IMPLEMENTATION: ::std::os::raw::c_uint = 17;
pub const XCB_CREATE_WINDOW: ::std::os::raw::c_uint = 1;
pub const XCB_CHANGE_WINDOW_ATTRIBUTES: ::std::os::raw::c_uint = 2;
pub const XCB_GET_WINDOW_ATTRIBUTES: ::std::os::raw::c_uint = 3;
pub const XCB_DESTROY_WINDOW: ::std::os::raw::c_uint = 4;
pub const XCB_DESTROY_SUBWINDOWS: ::std::os::raw::c_uint = 5;
pub const XCB_CHANGE_SAVE_SET: ::std::os::raw::c_uint = 6;
pub const XCB_REPARENT_WINDOW: ::std::os::raw::c_uint = 7;
pub const XCB_MAP_WINDOW: ::std::os::raw::c_uint = 8;
pub const XCB_MAP_SUBWINDOWS: ::std::os::raw::c_uint = 9;
pub const XCB_UNMAP_WINDOW: ::std::os::raw::c_uint = 10;
pub const XCB_UNMAP_SUBWINDOWS: ::std::os::raw::c_uint = 11;
pub const XCB_CONFIGURE_WINDOW: ::std::os::raw::c_uint = 12;
pub const XCB_CIRCULATE_WINDOW: ::std::os::raw::c_uint = 13;
pub const XCB_GET_GEOMETRY: ::std::os::raw::c_uint = 14;
pub const XCB_QUERY_TREE: ::std::os::raw::c_uint = 15;
pub const XCB_INTERN_ATOM: ::std::os::raw::c_uint = 16;
pub const XCB_GET_ATOM_NAME: ::std::os::raw::c_uint = 17;
pub const XCB_CHANGE_PROPERTY: ::std::os::raw::c_uint = 18;
pub const XCB_DELETE_PROPERTY: ::std::os::raw::c_uint = 19;
pub const XCB_GET_PROPERTY: ::std::os::raw::c_uint = 20;
pub const XCB_LIST_PROPERTIES: ::std::os::raw::c_uint = 21;
pub const XCB_SET_SELECTION_OWNER: ::std::os::raw::c_uint = 22;
pub const XCB_GET_SELECTION_OWNER: ::std::os::raw::c_uint = 23;
pub const XCB_CONVERT_SELECTION: ::std::os::raw::c_uint = 24;
pub const XCB_SEND_EVENT: ::std::os::raw::c_uint = 25;
pub const XCB_GRAB_POINTER: ::std::os::raw::c_uint = 26;
pub const XCB_UNGRAB_POINTER: ::std::os::raw::c_uint = 27;
pub const XCB_GRAB_BUTTON: ::std::os::raw::c_uint = 28;
pub const XCB_UNGRAB_BUTTON: ::std::os::raw::c_uint = 29;
pub const XCB_CHANGE_ACTIVE_POINTER_GRAB: ::std::os::raw::c_uint = 30;
pub const XCB_GRAB_KEYBOARD: ::std::os::raw::c_uint = 31;
pub const XCB_UNGRAB_KEYBOARD: ::std::os::raw::c_uint = 32;
pub const XCB_GRAB_KEY: ::std::os::raw::c_uint = 33;
pub const XCB_UNGRAB_KEY: ::std::os::raw::c_uint = 34;
pub const XCB_ALLOW_EVENTS: ::std::os::raw::c_uint = 35;
pub const XCB_GRAB_SERVER: ::std::os::raw::c_uint = 36;
pub const XCB_UNGRAB_SERVER: ::std::os::raw::c_uint = 37;
pub const XCB_QUERY_POINTER: ::std::os::raw::c_uint = 38;
pub const XCB_GET_MOTION_EVENTS: ::std::os::raw::c_uint = 39;
pub const XCB_TRANSLATE_COORDINATES: ::std::os::raw::c_uint = 40;
pub const XCB_WARP_POINTER: ::std::os::raw::c_uint = 41;
pub const XCB_SET_INPUT_FOCUS: ::std::os::raw::c_uint = 42;
pub const XCB_GET_INPUT_FOCUS: ::std::os::raw::c_uint = 43;
pub const XCB_QUERY_KEYMAP: ::std::os::raw::c_uint = 44;
pub const XCB_OPEN_FONT: ::std::os::raw::c_uint = 45;
pub const XCB_CLOSE_FONT: ::std::os::raw::c_uint = 46;
pub const XCB_QUERY_FONT: ::std::os::raw::c_uint = 47;
pub const XCB_QUERY_TEXT_EXTENTS: ::std::os::raw::c_uint = 48;
pub const XCB_LIST_FONTS: ::std::os::raw::c_uint = 49;
pub const XCB_LIST_FONTS_WITH_INFO: ::std::os::raw::c_uint = 50;
pub const XCB_SET_FONT_PATH: ::std::os::raw::c_uint = 51;
pub const XCB_GET_FONT_PATH: ::std::os::raw::c_uint = 52;
pub const XCB_CREATE_PIXMAP: ::std::os::raw::c_uint = 53;
pub const XCB_FREE_PIXMAP: ::std::os::raw::c_uint = 54;
pub const XCB_CREATE_GC: ::std::os::raw::c_uint = 55;
pub const XCB_CHANGE_GC: ::std::os::raw::c_uint = 56;
pub const XCB_COPY_GC: ::std::os::raw::c_uint = 57;
pub const XCB_SET_DASHES: ::std::os::raw::c_uint = 58;
pub const XCB_SET_CLIP_RECTANGLES: ::std::os::raw::c_uint = 59;
pub const XCB_FREE_GC: ::std::os::raw::c_uint = 60;
pub const XCB_CLEAR_AREA: ::std::os::raw::c_uint = 61;
pub const XCB_COPY_AREA: ::std::os::raw::c_uint = 62;
pub const XCB_COPY_PLANE: ::std::os::raw::c_uint = 63;
pub const XCB_POLY_POINT: ::std::os::raw::c_uint = 64;
pub const XCB_POLY_LINE: ::std::os::raw::c_uint = 65;
pub const XCB_POLY_SEGMENT: ::std::os::raw::c_uint = 66;
pub const XCB_POLY_RECTANGLE: ::std::os::raw::c_uint = 67;
pub const XCB_POLY_ARC: ::std::os::raw::c_uint = 68;
pub const XCB_FILL_POLY: ::std::os::raw::c_uint = 69;
pub const XCB_POLY_FILL_RECTANGLE: ::std::os::raw::c_uint = 70;
pub const XCB_POLY_FILL_ARC: ::std::os::raw::c_uint = 71;
pub const XCB_PUT_IMAGE: ::std::os::raw::c_uint = 72;
pub const XCB_GET_IMAGE: ::std::os::raw::c_uint = 73;
pub const XCB_POLY_TEXT_8: ::std::os::raw::c_uint = 74;
pub const XCB_POLY_TEXT_16: ::std::os::raw::c_uint = 75;
pub const XCB_IMAGE_TEXT_8: ::std::os::raw::c_uint = 76;
pub const XCB_IMAGE_TEXT_16: ::std::os::raw::c_uint = 77;
pub const XCB_CREATE_COLORMAP: ::std::os::raw::c_uint = 78;
pub const XCB_FREE_COLORMAP: ::std::os::raw::c_uint = 79;
pub const XCB_COPY_COLORMAP_AND_FREE: ::std::os::raw::c_uint = 80;
pub const XCB_INSTALL_COLORMAP: ::std::os::raw::c_uint = 81;
pub const XCB_UNINSTALL_COLORMAP: ::std::os::raw::c_uint = 82;
pub const XCB_LIST_INSTALLED_COLORMAPS: ::std::os::raw::c_uint = 83;
pub const XCB_ALLOC_COLOR: ::std::os::raw::c_uint = 84;
pub const XCB_ALLOC_NAMED_COLOR: ::std::os::raw::c_uint = 85;
pub const XCB_ALLOC_COLOR_CELLS: ::std::os::raw::c_uint = 86;
pub const XCB_ALLOC_COLOR_PLANES: ::std::os::raw::c_uint = 87;
pub const XCB_FREE_COLORS: ::std::os::raw::c_uint = 88;
pub const XCB_STORE_COLORS: ::std::os::raw::c_uint = 89;
pub const XCB_STORE_NAMED_COLOR: ::std::os::raw::c_uint = 90;
pub const XCB_QUERY_COLORS: ::std::os::raw::c_uint = 91;
pub const XCB_LOOKUP_COLOR: ::std::os::raw::c_uint = 92;
pub const XCB_CREATE_CURSOR: ::std::os::raw::c_uint = 93;
pub const XCB_CREATE_GLYPH_CURSOR: ::std::os::raw::c_uint = 94;
pub const XCB_FREE_CURSOR: ::std::os::raw::c_uint = 95;
pub const XCB_RECOLOR_CURSOR: ::std::os::raw::c_uint = 96;
pub const XCB_QUERY_BEST_SIZE: ::std::os::raw::c_uint = 97;
pub const XCB_QUERY_EXTENSION: ::std::os::raw::c_uint = 98;
pub const XCB_LIST_EXTENSIONS: ::std::os::raw::c_uint = 99;
pub const XCB_CHANGE_KEYBOARD_MAPPING: ::std::os::raw::c_uint = 100;
pub const XCB_GET_KEYBOARD_MAPPING: ::std::os::raw::c_uint = 101;
pub const XCB_CHANGE_KEYBOARD_CONTROL: ::std::os::raw::c_uint = 102;
pub const XCB_GET_KEYBOARD_CONTROL: ::std::os::raw::c_uint = 103;
pub const XCB_BELL: ::std::os::raw::c_uint = 104;
pub const XCB_CHANGE_POINTER_CONTROL: ::std::os::raw::c_uint = 105;
pub const XCB_GET_POINTER_CONTROL: ::std::os::raw::c_uint = 106;
pub const XCB_SET_SCREEN_SAVER: ::std::os::raw::c_uint = 107;
pub const XCB_GET_SCREEN_SAVER: ::std::os::raw::c_uint = 108;
pub const XCB_CHANGE_HOSTS: ::std::os::raw::c_uint = 109;
pub const XCB_LIST_HOSTS: ::std::os::raw::c_uint = 110;
pub const XCB_SET_ACCESS_CONTROL: ::std::os::raw::c_uint = 111;
pub const XCB_SET_CLOSE_DOWN_MODE: ::std::os::raw::c_uint = 112;
pub const XCB_KILL_CLIENT: ::std::os::raw::c_uint = 113;
pub const XCB_ROTATE_PROPERTIES: ::std::os::raw::c_uint = 114;
pub const XCB_FORCE_SCREEN_SAVER: ::std::os::raw::c_uint = 115;
pub const XCB_SET_POINTER_MAPPING: ::std::os::raw::c_uint = 116;
pub const XCB_GET_POINTER_MAPPING: ::std::os::raw::c_uint = 117;
pub const XCB_SET_MODIFIER_MAPPING: ::std::os::raw::c_uint = 118;
pub const XCB_GET_MODIFIER_MAPPING: ::std::os::raw::c_uint = 119;
pub const XCB_NO_OPERATION: ::std::os::raw::c_uint = 127;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
// #[repr(C)]
// pub union pthread_attr_t {
//     pub __size: [::std::os::raw::c_char; 56usize],
//     pub __align: ::std::os::raw::c_long,
// }
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
// #[repr(C)]
// pub union pthread_mutex_t {
//     pub __data: pthread_mutex_t___pthread_mutex_s,
//     pub __size: [::std::os::raw::c_char; 40usize],
//     pub __align: ::std::os::raw::c_long,
// }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
// #[repr(C)]
// #[derive(Copy)]
// pub union pthread_mutexattr_t {
//     pub __size: [::std::os::raw::c_char; 4usize],
//     pub __align: ::std::os::raw::c_int,
// }
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
// impl Clone for pthread_mutexattr_t {
//     fn clone(&self) -> Self { *self }
// }
// #[repr(C)]
// pub union pthread_cond_t {
//     pub __data: pthread_cond_t__bindgen_ty_1,
//     pub __size: [::std::os::raw::c_char; 48usize],
//     pub __align: ::std::os::raw::c_longlong,
// }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
// #[repr(C)]
// #[derive(Copy)]
// pub union pthread_condattr_t {
//     pub __size: [::std::os::raw::c_char; 4usize],
//     pub __align: ::std::os::raw::c_int,
// }
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
// impl Clone for pthread_condattr_t {
//     fn clone(&self) -> Self { *self }
// }
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
// #[repr(C)]
// pub union pthread_rwlock_t {
//     pub __data: pthread_rwlock_t__bindgen_ty_1,
//     pub __size: [::std::os::raw::c_char; 56usize],
//     pub __align: ::std::os::raw::c_long,
// }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_char,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers_queued as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_writers_queued as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
// #[repr(C)]
// #[derive(Copy)]
// pub union pthread_rwlockattr_t {
//     pub __size: [::std::os::raw::c_char; 8usize],
//     pub __align: ::std::os::raw::c_long,
// }
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
// impl Clone for pthread_rwlockattr_t {
//     fn clone(&self) -> Self { *self }
// }
pub type pthread_spinlock_t = ::std::os::raw::c_int;
// #[repr(C)]
// #[derive(Copy)]
// pub union pthread_barrier_t {
//     pub __size: [::std::os::raw::c_char; 32usize],
//     pub __align: ::std::os::raw::c_long,
// }
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
// impl Clone for pthread_barrier_t {
//     fn clone(&self) -> Self { *self }
// }
// #[repr(C)]
// #[derive(Copy)]
// pub union pthread_barrierattr_t {
//     pub __size: [::std::os::raw::c_char; 4usize],
//     pub __align: ::std::os::raw::c_int,
// }
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
// impl Clone for pthread_barrierattr_t {
//     fn clone(&self) -> Self { *self }
// }
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::std::mem::size_of::<iovec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( iovec ) ));
    assert_eq! (::std::mem::align_of::<iovec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( iovec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_len as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_len ) ));
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn readv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                 __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn writev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn preadv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int, __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pwritev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                   __count: ::std::os::raw::c_int, __offset: __off_t)
     -> isize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(::std::mem::size_of::<sched_param>() , 4usize , concat ! (
               "Size of: " , stringify ! ( sched_param ) ));
    assert_eq! (::std::mem::align_of::<sched_param>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sched_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sched_param ) ) . __sched_priority as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sched_param ) , "::" ,
                stringify ! ( __sched_priority ) ));
}
impl Clone for sched_param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_param() {
    assert_eq!(::std::mem::size_of::<__sched_param>() , 4usize , concat ! (
               "Size of: " , stringify ! ( __sched_param ) ));
    assert_eq! (::std::mem::align_of::<__sched_param>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sched_param ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sched_param ) ) . __sched_priority as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sched_param ) , "::"
                , stringify ! ( __sched_priority ) ));
}
impl Clone for __sched_param {
    fn clone(&self) -> Self { *self }
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(::std::mem::size_of::<cpu_set_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( cpu_set_t ) ));
    assert_eq! (::std::mem::align_of::<cpu_set_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpu_set_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_set_t ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_set_t ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for cpu_set_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(__pid: __pid_t, __policy: ::std::os::raw::c_int,
                              __param: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent([u8; 0]);
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                    __format: *const ::std::os::raw::c_char, __tp: *const tm)
     -> usize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strftime_l(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                      __format: *const ::std::os::raw::c_char,
                      __tp: *const tm, __loc: __locale_t) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__tzname"]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "__daylight"]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__timezone"]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec,
                     __remaining: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(__clock_id: clockid_t,
                           __flags: ::std::os::raw::c_int,
                           __req: *const timespec, __rem: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent,
                        __timerid: *mut timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(__timerid: timer_t, __flags: ::std::os::raw::c_int,
                         __value: *const itimerspec,
                         __ovalue: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 =
    _bindgen_ty_1::PTHREAD_CREATE_JOINABLE;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 =
    _bindgen_ty_1::PTHREAD_CREATE_DETACHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
}
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_ADAPTIVE_NP;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 =
    _bindgen_ty_2::PTHREAD_MUTEX_TIMED_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
}
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 =
    _bindgen_ty_3::PTHREAD_MUTEX_ROBUST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
}
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = _bindgen_ty_4::PTHREAD_PRIO_NONE;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 =
    _bindgen_ty_4::PTHREAD_PRIO_INHERIT;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 =
    _bindgen_ty_4::PTHREAD_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2,
}
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 =
    _bindgen_ty_5::PTHREAD_RWLOCK_PREFER_READER_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
}
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 =
    _bindgen_ty_6::PTHREAD_INHERIT_SCHED;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 =
    _bindgen_ty_6::PTHREAD_EXPLICIT_SCHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
}
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 =
    _bindgen_ty_7::PTHREAD_SCOPE_SYSTEM;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 =
    _bindgen_ty_7::PTHREAD_SCOPE_PROCESS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1,
}
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 =
    _bindgen_ty_8::PTHREAD_PROCESS_PRIVATE;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 =
    _bindgen_ty_8::PTHREAD_PROCESS_SHARED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(::std::mem::size_of::<_pthread_cleanup_buffer>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( _pthread_cleanup_buffer ) ));
    assert_eq! (::std::mem::align_of::<_pthread_cleanup_buffer>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _pthread_cleanup_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __routine
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __arg as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) .
                __canceltype as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __canceltype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _pthread_cleanup_buffer ) ) . __prev as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _pthread_cleanup_buffer
                ) , "::" , stringify ! ( __prev ) ));
}
impl Clone for _pthread_cleanup_buffer {
    fn clone(&self) -> Self { *self }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_CANCEL_ENABLE;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 =
    _bindgen_ty_9::PTHREAD_CANCEL_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
}
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 =
    _bindgen_ty_10::PTHREAD_CANCEL_DEFERRED;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 =
    _bindgen_ty_10::PTHREAD_CANCEL_ASYNCHRONOUS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
}
// extern "C" {
//     pub fn pthread_create(__newthread: *mut pthread_t,
//                           __attr: *const pthread_attr_t,
//                           __start_routine:
//                               ::std::option::Option<unsafe extern "C" fn(arg1:
//                                                                              *mut ::std::os::raw::c_void)
//                                                         ->
//                                                             *mut ::std::os::raw::c_void>,
//                           __arg: *mut ::std::os::raw::c_void)
//      -> ::std::os::raw::c_int;
// }
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(__th: pthread_t,
                        __thread_return: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t)
     -> ::std::os::raw::c_int;
}
// extern "C" {
//     pub fn pthread_attr_init(__attr: *mut pthread_attr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_getdetachstate(__attr: *const pthread_attr_t,
//                                        __detachstate:
//                                            *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_setdetachstate(__attr: *mut pthread_attr_t,
//                                        __detachstate: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_getguardsize(__attr: *const pthread_attr_t,
//                                      __guardsize: *mut usize)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_setguardsize(__attr: *mut pthread_attr_t,
//                                      __guardsize: usize)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_getschedparam(__attr: *const pthread_attr_t,
//                                       __param: *mut sched_param)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_setschedparam(__attr: *mut pthread_attr_t,
//                                       __param: *const sched_param)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_getschedpolicy(__attr: *const pthread_attr_t,
//                                        __policy: *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_setschedpolicy(__attr: *mut pthread_attr_t,
//                                        __policy: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_getinheritsched(__attr: *const pthread_attr_t,
//                                         __inherit: *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_setinheritsched(__attr: *mut pthread_attr_t,
//                                         __inherit: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_getscope(__attr: *const pthread_attr_t,
//                                  __scope: *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t,
//                                  __scope: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_getstackaddr(__attr: *const pthread_attr_t,
//                                      __stackaddr:
//                                          *mut *mut ::std::os::raw::c_void)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_setstackaddr(__attr: *mut pthread_attr_t,
//                                      __stackaddr: *mut ::std::os::raw::c_void)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_getstacksize(__attr: *const pthread_attr_t,
//                                      __stacksize: *mut usize)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t,
//                                      __stacksize: usize)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_getstack(__attr: *const pthread_attr_t,
//                                  __stackaddr:
//                                      *mut *mut ::std::os::raw::c_void,
//                                  __stacksize: *mut usize)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_attr_setstack(__attr: *mut pthread_attr_t,
//                                  __stackaddr: *mut ::std::os::raw::c_void,
//                                  __stacksize: usize) -> ::std::os::raw::c_int;
// }
extern "C" {
    pub fn pthread_setschedparam(__target_thread: pthread_t,
                                 __policy: ::std::os::raw::c_int,
                                 __param: *const sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(__target_thread: pthread_t,
                                 __policy: *mut ::std::os::raw::c_int,
                                 __param: *mut sched_param)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t,
                                __prio: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(__once_control: *mut pthread_once_t,
                        __init_routine:
                            ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(__state: ::std::os::raw::c_int,
                                  __oldstate: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(__type: ::std::os::raw::c_int,
                                 __oldtype: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>() ,
               72usize , concat ! (
               "Size of: " , stringify ! (
               __pthread_unwind_buf_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t__bindgen_ty_1 ) )
                . __cancel_jmp_buf as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) , "::" , stringify ! (
                __cancel_jmp_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t__bindgen_ty_1 ) )
                . __mask_was_saved as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                __pthread_unwind_buf_t__bindgen_ty_1 ) , "::" , stringify ! (
                __mask_was_saved ) ));
}
impl Clone for __pthread_unwind_buf_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(::std::mem::size_of::<__pthread_unwind_buf_t>() , 104usize ,
               concat ! ( "Size of: " , stringify ! ( __pthread_unwind_buf_t )
               ));
    assert_eq! (::std::mem::align_of::<__pthread_unwind_buf_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_unwind_buf_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t ) ) .
                __cancel_jmp_buf as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_unwind_buf_t
                ) , "::" , stringify ! ( __cancel_jmp_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_unwind_buf_t ) ) . __pad as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_unwind_buf_t
                ) , "::" , stringify ! ( __pad ) ));
}
impl Clone for __pthread_unwind_buf_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(::std::mem::size_of::<__pthread_cleanup_frame>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_cleanup_frame ) ));
    assert_eq! (::std::mem::align_of::<__pthread_cleanup_frame>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_cleanup_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
                __cancel_routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
                __cancel_arg as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) . __do_it as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __do_it ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cleanup_frame ) ) .
                __cancel_type as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cleanup_frame
                ) , "::" , stringify ! ( __cancel_type ) ));
}
impl Clone for __pthread_cleanup_frame {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag([u8; 0]);
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag,
                       __savemask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
// extern "C" {
//     pub fn pthread_mutex_init(__mutex: *mut pthread_mutex_t,
//                               __mutexattr: *const pthread_mutexattr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutex_timedlock(__mutex: *mut pthread_mutex_t,
//                                    __abstime: *const timespec)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutex_getprioceiling(__mutex: *const pthread_mutex_t,
//                                         __prioceiling:
//                                             *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutex_setprioceiling(__mutex: *mut pthread_mutex_t,
//                                         __prioceiling: ::std::os::raw::c_int,
//                                         __old_ceiling:
//                                             *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_getpshared(__attr: *const pthread_mutexattr_t,
//                                         __pshared: *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_setpshared(__attr: *mut pthread_mutexattr_t,
//                                         __pshared: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_gettype(__attr: *const pthread_mutexattr_t,
//                                      __kind: *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_settype(__attr: *mut pthread_mutexattr_t,
//                                      __kind: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_getprotocol(__attr: *const pthread_mutexattr_t,
//                                          __protocol:
//                                              *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_setprotocol(__attr: *mut pthread_mutexattr_t,
//                                          __protocol: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_getprioceiling(__attr:
//                                                 *const pthread_mutexattr_t,
//                                             __prioceiling:
//                                                 *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_setprioceiling(__attr: *mut pthread_mutexattr_t,
//                                             __prioceiling:
//                                                 ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_getrobust(__attr: *const pthread_mutexattr_t,
//                                        __robustness:
//                                            *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_mutexattr_setrobust(__attr: *mut pthread_mutexattr_t,
//                                        __robustness: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlock_init(__rwlock: *mut pthread_rwlock_t,
//                                __attr: *const pthread_rwlockattr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlock_timedrdlock(__rwlock: *mut pthread_rwlock_t,
//                                       __abstime: *const timespec)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlock_timedwrlock(__rwlock: *mut pthread_rwlock_t,
//                                       __abstime: *const timespec)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlockattr_getpshared(__attr: *const pthread_rwlockattr_t,
//                                          __pshared:
//                                              *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlockattr_setpshared(__attr: *mut pthread_rwlockattr_t,
//                                          __pshared: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlockattr_getkind_np(__attr: *const pthread_rwlockattr_t,
//                                          __pref: *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_rwlockattr_setkind_np(__attr: *mut pthread_rwlockattr_t,
//                                          __pref: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_cond_init(__cond: *mut pthread_cond_t,
//                              __cond_attr: *const pthread_condattr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_cond_signal(__cond: *mut pthread_cond_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_cond_wait(__cond: *mut pthread_cond_t,
//                              __mutex: *mut pthread_mutex_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_cond_timedwait(__cond: *mut pthread_cond_t,
//                                   __mutex: *mut pthread_mutex_t,
//                                   __abstime: *const timespec)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_condattr_getpshared(__attr: *const pthread_condattr_t,
//                                        __pshared: *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_condattr_setpshared(__attr: *mut pthread_condattr_t,
//                                        __pshared: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_condattr_getclock(__attr: *const pthread_condattr_t,
//                                      __clock_id: *mut __clockid_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_condattr_setclock(__attr: *mut pthread_condattr_t,
//                                      __clock_id: __clockid_t)
//      -> ::std::os::raw::c_int;
// }
extern "C" {
    pub fn pthread_spin_init(__lock: *mut pthread_spinlock_t,
                             __pshared: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t)
     -> ::std::os::raw::c_int;
}
// extern "C" {
//     pub fn pthread_barrier_init(__barrier: *mut pthread_barrier_t,
//                                 __attr: *const pthread_barrierattr_t,
//                                 __count: ::std::os::raw::c_uint)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_barrierattr_getpshared(__attr:
//                                               *const pthread_barrierattr_t,
//                                           __pshared:
//                                               *mut ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
// extern "C" {
//     pub fn pthread_barrierattr_setpshared(__attr: *mut pthread_barrierattr_t,
//                                           __pshared: ::std::os::raw::c_int)
//      -> ::std::os::raw::c_int;
// }
extern "C" {
    pub fn pthread_key_create(__key: *mut pthread_key_t,
                              __destr_function:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut ::std::os::raw::c_void)>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(__key: pthread_key_t,
                               __pointer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(__thread_id: pthread_t,
                                 __clock_id: *mut __clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(__prepare:
                              ::std::option::Option<unsafe extern "C" fn()>,
                          __parent:
                              ::std::option::Option<unsafe extern "C" fn()>,
                          __child:
                              ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_connection_t([u8; 0]);
/**
 * @brief Generic iterator.
 *
 * A generic iterator structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_generic_iterator_t {
    /**< Data of the current iterator */
    pub data: *mut ::std::os::raw::c_void,
    /**< remaining elements */
    pub rem: ::std::os::raw::c_int,
    /**< index of the current iterator */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_generic_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_generic_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_generic_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_generic_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_generic_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_iterator_t
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_iterator_t
                ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_iterator_t
                ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_generic_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief Generic reply.
 *
 * A generic reply structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_generic_reply_t {
    /**< Type of the response */
    pub response_type: u8,
    /**< Padding */
    pub pad0: u8,
    /**< Sequence number */
    pub sequence: u16,
    /**< Length of the response */
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_generic_reply_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( xcb_generic_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_generic_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_generic_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_reply_t ) ) . response_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_reply_t ) ,
                "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_reply_t ) ) . pad0 as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_reply_t ) ,
                "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_reply_t ) ) . sequence as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_reply_t ) ,
                "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_reply_t ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_reply_t ) ,
                "::" , stringify ! ( length ) ));
}
impl Clone for xcb_generic_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief Generic event.
 *
 * A generic event structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_generic_event_t {
    /**< Type of the response */
    pub response_type: u8,
    /**< Padding */
    pub pad0: u8,
    /**< Sequence number */
    pub sequence: u16,
    /**< Padding */
    pub pad: [u32; 7usize],
    /**< full sequence */
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_generic_event_t>() , 36usize , concat
               ! ( "Size of: " , stringify ! ( xcb_generic_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_generic_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_generic_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_event_t ) ) . response_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_event_t ) ,
                "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_event_t ) ) . pad0 as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_event_t ) ,
                "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_event_t ) ) . sequence as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_event_t ) ,
                "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_event_t ) ) . pad as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_event_t ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_event_t ) ) . full_sequence
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_event_t ) ,
                "::" , stringify ! ( full_sequence ) ));
}
impl Clone for xcb_generic_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief GE event
 *
 * An event as sent by the XGE extension. The length field specifies the
 * number of 4-byte blocks trailing the struct.
 *
 * @deprecated Since some fields in this struct have unfortunate names, it is
 * recommended to use xcb_ge_generic_event_t instead.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ge_event_t {
    /**< Type of the response */
    pub response_type: u8,
    /**< Padding */
    pub pad0: u8,
    /**< Sequence number */
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad1: u16,
    /**< Padding */
    pub pad: [u32; 5usize],
    /**< full sequence */
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_ge_event_t>() , 36usize , concat ! (
               "Size of: " , stringify ! ( xcb_ge_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_ge_event_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_ge_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_event_t ) ) . response_type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_event_t ) , "::"
                , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_event_t ) ) . pad0 as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_event_t ) , "::"
                , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_event_t ) ) . sequence as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_event_t ) , "::"
                , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_event_t ) ) . length as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_event_t ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_event_t ) ) . event_type as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_event_t ) , "::"
                , stringify ! ( event_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_event_t ) ) . pad1 as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_event_t ) , "::"
                , stringify ! ( pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_event_t ) ) . pad as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_event_t ) , "::"
                , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_event_t ) ) . full_sequence as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_event_t ) , "::"
                , stringify ! ( full_sequence ) ));
}
impl Clone for xcb_ge_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief Generic error.
 *
 * A generic error structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_generic_error_t {
    /**< Type of the response */
    pub response_type: u8,
    /**< Error code */
    pub error_code: u8,
    /**< Sequence number */
    pub sequence: u16,
    pub resource_id: u32,
    /** < Resource ID for requests with side effects only */
    pub minor_code: u16,
    /** < Minor opcode of the failed request */
    pub major_code: u8,
    /** < Major opcode of the failed request */
    pub pad0: u8,
    /**< Padding */
    pub pad: [u32; 5usize],
    /**< full sequence */
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_generic_error_t>() , 36usize , concat
               ! ( "Size of: " , stringify ! ( xcb_generic_error_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_generic_error_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_generic_error_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_error_t ) ) . response_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_error_t ) ,
                "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_error_t ) ) . error_code as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_error_t ) ,
                "::" , stringify ! ( error_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_error_t ) ) . sequence as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_error_t ) ,
                "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_error_t ) ) . resource_id as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_error_t ) ,
                "::" , stringify ! ( resource_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_error_t ) ) . minor_code as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_error_t ) ,
                "::" , stringify ! ( minor_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_error_t ) ) . major_code as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_error_t ) ,
                "::" , stringify ! ( major_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_error_t ) ) . pad0 as * const
                _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_error_t ) ,
                "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_error_t ) ) . pad as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_error_t ) ,
                "::" , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_generic_error_t ) ) . full_sequence
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_generic_error_t ) ,
                "::" , stringify ! ( full_sequence ) ));
}
impl Clone for xcb_generic_error_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief Generic cookie.
 *
 * A generic cookie structure.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_void_cookie_t {
    /**< Sequence number */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_void_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_void_cookie_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( xcb_void_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_void_cookie_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( xcb_void_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_void_cookie_t ) ) . sequence as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_void_cookie_t ) ,
                "::" , stringify ! ( sequence ) ));
}
impl Clone for xcb_void_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief Container for authorization information.
 *
 * A container for authorization information to be sent to the X server.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_auth_info_t {
    /**< Length of the string name (as returned by strlen). */
    pub namelen: ::std::os::raw::c_int,
    /**< String containing the authentication protocol name, such as "MIT-MAGIC-COOKIE-1" or "XDM-AUTHORIZATION-1". */
    pub name: *mut ::std::os::raw::c_char,
    /**< Length of the data member. */
    pub datalen: ::std::os::raw::c_int,
    /**< Data interpreted in a protocol-specific manner. */
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_xcb_auth_info_t() {
    assert_eq!(::std::mem::size_of::<xcb_auth_info_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( xcb_auth_info_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_auth_info_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( xcb_auth_info_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_auth_info_t ) ) . namelen as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_auth_info_t ) ,
                "::" , stringify ! ( namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_auth_info_t ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_auth_info_t ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_auth_info_t ) ) . datalen as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_auth_info_t ) ,
                "::" , stringify ! ( datalen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_auth_info_t ) ) . data as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_auth_info_t ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for xcb_auth_info_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * @brief Forces any buffered output to be written to the server.
 * @param c: The connection to the X server.
 * @return > @c 0 on success, <= @c 0 otherwise.
 *
 * Forces any buffered output to be written to the server. Blocks
 * until the write is complete.
 */
    pub fn xcb_flush(c: *mut xcb_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Returns the maximum request length that this server accepts.
 * @param c: The connection to the X server.
 * @return The maximum request length field.
 *
 * In the absence of the BIG-REQUESTS extension, returns the
 * maximum request length field from the connection setup data, which
 * may be as much as 65535. If the server supports BIG-REQUESTS, then
 * the maximum request length field from the reply to the
 * BigRequestsEnable request will be returned instead.
 *
 * Note that this length is measured in four-byte units, making the
 * theoretical maximum lengths roughly 256kB without BIG-REQUESTS and
 * 16GB with.
 */
    pub fn xcb_get_maximum_request_length(c: *mut xcb_connection_t) -> u32;
}
extern "C" {
    /**
 * @brief Prefetch the maximum request length without blocking.
 * @param c: The connection to the X server.
 *
 * Without blocking, does as much work as possible toward computing
 * the maximum request length accepted by the X server.
 *
 * Invoking this function may cause a call to xcb_big_requests_enable,
 * but will not block waiting for the reply.
 * xcb_get_maximum_request_length will return the prefetched data
 * after possibly blocking while the reply is retrieved.
 *
 * Note that in order for this function to be fully non-blocking, the
 * application must previously have called
 * xcb_prefetch_extension_data(c, &xcb_big_requests_id) and the reply
 * must have already arrived.
 */
    pub fn xcb_prefetch_maximum_request_length(c: *mut xcb_connection_t);
}
extern "C" {
    /**
 * @brief Returns the next event or error from the server.
 * @param c: The connection to the X server.
 * @return The next event from the server.
 *
 * Returns the next event or error from the server, or returns null in
 * the event of an I/O error. Blocks until either an event or error
 * arrive, or an I/O error occurs.
 */
    pub fn xcb_wait_for_event(c: *mut xcb_connection_t)
     -> *mut xcb_generic_event_t;
}
extern "C" {
    /**
 * @brief Returns the next event or error from the server.
 * @param c: The connection to the X server.
 * @return The next event from the server.
 *
 * Returns the next event or error from the server, if one is
 * available, or returns @c NULL otherwise. If no event is available, that
 * might be because an I/O error like connection close occurred while
 * attempting to read the next event, in which case the connection is
 * shut down when this function returns.
 */
    pub fn xcb_poll_for_event(c: *mut xcb_connection_t)
     -> *mut xcb_generic_event_t;
}
extern "C" {
    /**
 * @brief Returns the next event without reading from the connection.
 * @param c: The connection to the X server.
 * @return The next already queued event from the server.
 *
 * This is a version of xcb_poll_for_event that only examines the
 * event queue for new events. The function doesn't try to read new
 * events from the connection if no queued events are found.
 *
 * This function is useful for callers that know in advance that all
 * interesting events have already been read from the connection. For
 * example, callers might use xcb_wait_for_reply and be interested
 * only of events that preceded a specific reply.
 */
    pub fn xcb_poll_for_queued_event(c: *mut xcb_connection_t)
     -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_special_event([u8; 0]);
pub type xcb_special_event_t = xcb_special_event;
extern "C" {
    /**
 * @brief Returns the next event from a special queue
 */
    pub fn xcb_poll_for_special_event(c: *mut xcb_connection_t,
                                      se: *mut xcb_special_event_t)
     -> *mut xcb_generic_event_t;
}
extern "C" {
    /**
 * @brief Returns the next event from a special queue, blocking until one arrives
 */
    pub fn xcb_wait_for_special_event(c: *mut xcb_connection_t,
                                      se: *mut xcb_special_event_t)
     -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_extension_t([u8; 0]);
extern "C" {
    /**
 * @brief Listen for a special event
 */
    pub fn xcb_register_for_special_xge(c: *mut xcb_connection_t,
                                        ext: *mut xcb_extension_t, eid: u32,
                                        stamp: *mut u32)
     -> *mut xcb_special_event_t;
}
extern "C" {
    /**
 * @brief Stop listening for a special event
 */
    pub fn xcb_unregister_for_special_event(c: *mut xcb_connection_t,
                                            se: *mut xcb_special_event_t);
}
extern "C" {
    /**
 * @brief Return the error for a request, or NULL if none can ever arrive.
 * @param c: The connection to the X server.
 * @param cookie: The request cookie.
 * @return The error for the request, or NULL if none can ever arrive.
 *
 * The xcb_void_cookie_t cookie supplied to this function must have resulted
 * from a call to xcb_[request_name]_checked().  This function will block
 * until one of two conditions happens.  If an error is received, it will be
 * returned.  If a reply to a subsequent request has already arrived, no error
 * can arrive for this request, so this function will return NULL.
 *
 * Note that this function will perform a sync if needed to ensure that the
 * sequence number will advance beyond that provided in cookie; this is a
 * convenience to avoid races in determining whether the sync is needed.
 */
    pub fn xcb_request_check(c: *mut xcb_connection_t,
                             cookie: xcb_void_cookie_t)
     -> *mut xcb_generic_error_t;
}
extern "C" {
    /**
 * @brief Discards the reply for a request.
 * @param c: The connection to the X server.
 * @param sequence: The request sequence number from a cookie.
 *
 * Discards the reply for a request. Additionally, any error generated
 * by the request is also discarded (unless it was an _unchecked request
 * and the error has already arrived).
 *
 * This function will not block even if the reply is not yet available.
 *
 * Note that the sequence really does have to come from an xcb cookie;
 * this function is not designed to operate on socket-handoff replies.
 */
    pub fn xcb_discard_reply(c: *mut xcb_connection_t,
                             sequence: ::std::os::raw::c_uint);
}
extern "C" {
    /**
 * @brief Discards the reply for a request, given by a 64bit sequence number
 * @param c: The connection to the X server.
 * @param sequence: 64-bit sequence number as returned by xcb_send_request64().
 *
 * Discards the reply for a request. Additionally, any error generated
 * by the request is also discarded (unless it was an _unchecked request
 * and the error has already arrived).
 *
 * This function will not block even if the reply is not yet available.
 *
 * Note that the sequence really does have to come from xcb_send_request64();
 * the cookie sequence number is defined as "unsigned" int and therefore
 * not 64-bit on all platforms.
 * This function is not designed to operate on socket-handoff replies.
 *
 * Unlike its xcb_discard_reply() counterpart, the given sequence number is not
 * automatically "widened" to 64-bit.
 */
    pub fn xcb_discard_reply64(c: *mut xcb_connection_t, sequence: u64);
}
/**
 * @brief xcb_query_extension_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_extension_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub present: u8,
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub first_event: u8,
    /**<  */
    pub first_error: u8,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_extension_reply_t>() , 12usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_query_extension_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_extension_reply_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_query_extension_reply_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_reply_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_reply_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_reply_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_reply_t ) ) . length
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_reply_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_reply_t ) ) . present
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_reply_t ) , "::" , stringify ! ( present )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_reply_t ) ) .
                major_opcode as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_reply_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_reply_t ) ) .
                first_event as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_reply_t ) , "::" , stringify ! (
                first_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_reply_t ) ) .
                first_error as * const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_reply_t ) , "::" , stringify ! (
                first_error ) ));
}
impl Clone for xcb_query_extension_reply_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * @brief Caches reply information from QueryExtension requests.
 * @param c: The connection.
 * @param ext: The extension data.
 * @return A pointer to the xcb_query_extension_reply_t for the extension.
 *
 * This function is the primary interface to the "extension cache",
 * which caches reply information from QueryExtension
 * requests. Invoking this function may cause a call to
 * xcb_query_extension to retrieve extension information from the
 * server, and may block until extension data is received from the
 * server.
 *
 * The result must not be freed. This storage is managed by the cache
 * itself.
 */
    pub fn xcb_get_extension_data(c: *mut xcb_connection_t,
                                  ext: *mut xcb_extension_t)
     -> *const xcb_query_extension_reply_t;
}
extern "C" {
    /**
 * @brief Prefetch of extension data into the extension cache
 * @param c: The connection.
 * @param ext: The extension data.
 *
 * This function allows a "prefetch" of extension data into the
 * extension cache. Invoking the function may cause a call to
 * xcb_query_extension, but will not block waiting for the
 * reply. xcb_get_extension_data will return the prefetched data after
 * possibly blocking while it is retrieved.
 */
    pub fn xcb_prefetch_extension_data(c: *mut xcb_connection_t,
                                       ext: *mut xcb_extension_t);
}
/**
 * @brief xcb_setup_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_t {
    /**<  */
    pub status: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub protocol_major_version: u16,
    /**<  */
    pub protocol_minor_version: u16,
    /**<  */
    pub length: u16,
    /**<  */
    pub release_number: u32,
    /**<  */
    pub resource_id_base: u32,
    /**<  */
    pub resource_id_mask: u32,
    /**<  */
    pub motion_buffer_size: u32,
    /**<  */
    pub vendor_len: u16,
    /**<  */
    pub maximum_request_length: u16,
    /**<  */
    pub roots_len: u8,
    /**<  */
    pub pixmap_formats_len: u8,
    /**<  */
    pub image_byte_order: u8,
    /**<  */
    pub bitmap_format_bit_order: u8,
    /**<  */
    pub bitmap_format_scanline_unit: u8,
    /**<  */
    pub bitmap_format_scanline_pad: u8,
    /**<  */
    pub min_keycode: xcb_keycode_t,
    /**<  */
    pub max_keycode: xcb_keycode_t,
    /**<  */
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( xcb_setup_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_setup_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_setup_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . status as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . pad0 as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . protocol_major_version
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( protocol_major_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . protocol_minor_version
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( protocol_minor_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . length as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . release_number as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( release_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . resource_id_base as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( resource_id_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . resource_id_mask as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( resource_id_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . motion_buffer_size as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( motion_buffer_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . vendor_len as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( vendor_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . maximum_request_length
                as * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( maximum_request_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . roots_len as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( roots_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . pixmap_formats_len as *
                const _ as usize } , 29usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( pixmap_formats_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . image_byte_order as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( image_byte_order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . bitmap_format_bit_order
                as * const _ as usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( bitmap_format_bit_order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) .
                bitmap_format_scanline_unit as * const _ as usize } , 32usize
                , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( bitmap_format_scanline_unit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) .
                bitmap_format_scanline_pad as * const _ as usize } , 33usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( bitmap_format_scanline_pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . min_keycode as * const
                _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( min_keycode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . max_keycode as * const
                _ as usize } , 35usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( max_keycode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_t ) ) . pad1 as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_t ) , "::" ,
                stringify ! ( pad1 ) ));
}
impl Clone for xcb_setup_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * @brief Access the data returned by the server.
 * @param c: The connection.
 * @return A pointer to an xcb_setup_t structure.
 *
 * Accessor for the data returned by the server when the xcb_connection_t
 * was initialized. This data includes
 * - the server's required format for images,
 * - a list of available visuals,
 * - a list of available screens,
 * - the server's maximum request length (in the absence of the
 * BIG-REQUESTS extension),
 * - and other assorted information.
 *
 * See the X protocol specification for more details.
 *
 * The result must not be freed.
 */
    pub fn xcb_get_setup(c: *mut xcb_connection_t) -> *const xcb_setup_t;
}
extern "C" {
    /**
 * @brief Access the file descriptor of the connection.
 * @param c: The connection.
 * @return The file descriptor.
 *
 * Accessor for the file descriptor that was passed to the
 * xcb_connect_to_fd call that returned @p c.
 */
    pub fn xcb_get_file_descriptor(c: *mut xcb_connection_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Test whether the connection has shut down due to a fatal error.
 * @param c: The connection.
 * @return > 0 if the connection is in an error state; 0 otherwise.
 *
 * Some errors that occur in the context of an xcb_connection_t
 * are unrecoverable. When such an error occurs, the
 * connection is shut down and further operations on the
 * xcb_connection_t have no effect, but memory will not be freed until
 * xcb_disconnect() is called on the xcb_connection_t.
 *
 * @return XCB_CONN_ERROR, because of socket errors, pipe errors or other stream errors.
 * @return XCB_CONN_CLOSED_EXT_NOTSUPPORTED, when extension not supported.
 * @return XCB_CONN_CLOSED_MEM_INSUFFICIENT, when memory not available.
 * @return XCB_CONN_CLOSED_REQ_LEN_EXCEED, exceeding request length that server accepts.
 * @return XCB_CONN_CLOSED_PARSE_ERR, error during parsing display string.
 * @return XCB_CONN_CLOSED_INVALID_SCREEN, because the server does not have a screen matching the display.
 */
    pub fn xcb_connection_has_error(c: *mut xcb_connection_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Connects to the X server.
 * @param fd: The file descriptor.
 * @param auth_info: Authentication data.
 * @return A newly allocated xcb_connection_t structure.
 *
 * Connects to an X server, given the open socket @p fd and the
 * xcb_auth_info_t @p auth_info. The file descriptor @p fd is
 * bidirectionally connected to an X server. If the connection
 * should be unauthenticated, @p auth_info must be @c
 * NULL.
 *
 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.
 * Callers need to use xcb_connection_has_error() to check for failure.
 * When finished, use xcb_disconnect() to close the connection and free
 * the structure.
 */
    pub fn xcb_connect_to_fd(fd: ::std::os::raw::c_int,
                             auth_info: *mut xcb_auth_info_t)
     -> *mut xcb_connection_t;
}
extern "C" {
    /**
 * @brief Closes the connection.
 * @param c: The connection.
 *
 * Closes the file descriptor and frees all memory associated with the
 * connection @c c. If @p c is @c NULL, nothing is done.
 */
    pub fn xcb_disconnect(c: *mut xcb_connection_t);
}
extern "C" {
    /**
 * @brief Parses a display string name in the form documented by X(7x).
 * @param name: The name of the display.
 * @param host: A pointer to a malloc'd copy of the hostname.
 * @param display: A pointer to the display number.
 * @param screen: A pointer to the screen number.
 * @return 0 on failure, non 0 otherwise.
 *
 * Parses the display string name @p display_name in the form
 * documented by X(7x). Has no side effects on failure. If
 * @p displayname is @c NULL or empty, it uses the environment
 * variable DISPLAY. @p hostp is a pointer to a newly allocated string
 * that contain the host name. @p displayp is set to the display
 * number and @p screenp to the preferred screen number. @p screenp
 * can be @c NULL. If @p displayname does not contain a screen number,
 * it is set to @c 0.
 */
    pub fn xcb_parse_display(name: *const ::std::os::raw::c_char,
                             host: *mut *mut ::std::os::raw::c_char,
                             display: *mut ::std::os::raw::c_int,
                             screen: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Connects to the X server.
 * @param displayname: The name of the display.
 * @param screenp: A pointer to a preferred screen number.
 * @return A newly allocated xcb_connection_t structure.
 *
 * Connects to the X server specified by @p displayname. If @p
 * displayname is @c NULL, uses the value of the DISPLAY environment
 * variable. If a particular screen on that server is preferred, the
 * int pointed to by @p screenp (if not @c NULL) will be set to that
 * screen; otherwise the screen will be set to 0.
 *
 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.
 * Callers need to use xcb_connection_has_error() to check for failure.
 * When finished, use xcb_disconnect() to close the connection and free
 * the structure.
 */
    pub fn xcb_connect(displayname: *const ::std::os::raw::c_char,
                       screenp: *mut ::std::os::raw::c_int)
     -> *mut xcb_connection_t;
}
extern "C" {
    /**
 * @brief Connects to the X server, using an authorization information.
 * @param display: The name of the display.
 * @param auth: The authorization information.
 * @param screen: A pointer to a preferred screen number.
 * @return A newly allocated xcb_connection_t structure.
 *
 * Connects to the X server specified by @p displayname, using the
 * authorization @p auth. If a particular screen on that server is
 * preferred, the int pointed to by @p screenp (if not @c NULL) will
 * be set to that screen; otherwise @p screenp will be set to 0.
 *
 * Always returns a non-NULL pointer to a xcb_connection_t, even on failure.
 * Callers need to use xcb_connection_has_error() to check for failure.
 * When finished, use xcb_disconnect() to close the connection and free
 * the structure.
 */
    pub fn xcb_connect_to_display_with_auth_info(display:
                                                     *const ::std::os::raw::c_char,
                                                 auth: *mut xcb_auth_info_t,
                                                 screen:
                                                     *mut ::std::os::raw::c_int)
     -> *mut xcb_connection_t;
}
extern "C" {
    /**
 * @brief Allocates an XID for a new object.
 * @param c: The connection.
 * @return A newly allocated XID.
 *
 * Allocates an XID for a new object. Typically used just prior to
 * various object creation functions, such as xcb_create_window.
 */
    pub fn xcb_generate_id(c: *mut xcb_connection_t) -> u32;
}
/**
 * @brief xcb_char2b_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_char2b_t {
    /**<  */
    pub byte1: u8,
    /**<  */
    pub byte2: u8,
}
#[test]
fn bindgen_test_layout_xcb_char2b_t() {
    assert_eq!(::std::mem::size_of::<xcb_char2b_t>() , 2usize , concat ! (
               "Size of: " , stringify ! ( xcb_char2b_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_char2b_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( xcb_char2b_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_char2b_t ) ) . byte1 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_char2b_t ) , "::" ,
                stringify ! ( byte1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_char2b_t ) ) . byte2 as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_char2b_t ) , "::" ,
                stringify ! ( byte2 ) ));
}
impl Clone for xcb_char2b_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_char2b_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_char2b_iterator_t {
    /**<  */
    pub data: *mut xcb_char2b_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_char2b_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_char2b_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_char2b_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_char2b_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_char2b_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_char2b_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_char2b_iterator_t )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_char2b_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_char2b_iterator_t )
                , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_char2b_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_char2b_iterator_t )
                , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_char2b_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_window_t = u32;
/**
 * @brief xcb_window_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_window_iterator_t {
    /**<  */
    pub data: *mut xcb_window_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_window_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_window_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_window_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_window_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_window_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_window_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_window_iterator_t )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_window_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_window_iterator_t )
                , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_window_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_window_iterator_t )
                , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_window_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_pixmap_t = u32;
/**
 * @brief xcb_pixmap_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_pixmap_iterator_t {
    /**<  */
    pub data: *mut xcb_pixmap_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_pixmap_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_pixmap_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_pixmap_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_pixmap_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_pixmap_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_pixmap_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_pixmap_iterator_t )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_pixmap_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_pixmap_iterator_t )
                , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_pixmap_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_pixmap_iterator_t )
                , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_pixmap_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_cursor_t = u32;
/**
 * @brief xcb_cursor_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_cursor_iterator_t {
    /**<  */
    pub data: *mut xcb_cursor_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_cursor_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_cursor_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_cursor_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_cursor_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_cursor_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_cursor_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_cursor_iterator_t )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_cursor_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_cursor_iterator_t )
                , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_cursor_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_cursor_iterator_t )
                , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_cursor_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_font_t = u32;
/**
 * @brief xcb_font_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_font_iterator_t {
    /**<  */
    pub data: *mut xcb_font_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_font_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_font_iterator_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( xcb_font_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_font_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_font_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_font_iterator_t ) ) . data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_font_iterator_t ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_font_iterator_t ) ) . rem as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_font_iterator_t ) ,
                "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_font_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_font_iterator_t ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for xcb_font_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_gcontext_t = u32;
/**
 * @brief xcb_gcontext_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_gcontext_iterator_t {
    /**<  */
    pub data: *mut xcb_gcontext_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_gcontext_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_gcontext_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_gcontext_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_gcontext_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_gcontext_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_gcontext_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_gcontext_iterator_t
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_gcontext_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_gcontext_iterator_t
                ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_gcontext_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_gcontext_iterator_t
                ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_gcontext_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_colormap_t = u32;
/**
 * @brief xcb_colormap_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_colormap_iterator_t {
    /**<  */
    pub data: *mut xcb_colormap_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_colormap_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_colormap_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_colormap_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_colormap_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_colormap_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_colormap_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_colormap_iterator_t
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_colormap_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_colormap_iterator_t
                ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_colormap_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_colormap_iterator_t
                ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_colormap_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_atom_t = u32;
/**
 * @brief xcb_atom_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_atom_iterator_t {
    /**<  */
    pub data: *mut xcb_atom_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_atom_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_atom_iterator_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( xcb_atom_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_atom_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_atom_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_atom_iterator_t ) ) . data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_atom_iterator_t ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_atom_iterator_t ) ) . rem as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_atom_iterator_t ) ,
                "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_atom_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_atom_iterator_t ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for xcb_atom_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_drawable_t = u32;
/**
 * @brief xcb_drawable_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_drawable_iterator_t {
    /**<  */
    pub data: *mut xcb_drawable_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_drawable_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_drawable_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_drawable_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_drawable_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_drawable_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_drawable_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_drawable_iterator_t
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_drawable_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_drawable_iterator_t
                ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_drawable_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_drawable_iterator_t
                ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_drawable_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_fontable_t = u32;
/**
 * @brief xcb_fontable_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fontable_iterator_t {
    /**<  */
    pub data: *mut xcb_fontable_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontable_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_fontable_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_fontable_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_fontable_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_fontable_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fontable_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fontable_iterator_t
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fontable_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fontable_iterator_t
                ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fontable_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fontable_iterator_t
                ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_fontable_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_visualid_t = u32;
/**
 * @brief xcb_visualid_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visualid_iterator_t {
    /**<  */
    pub data: *mut xcb_visualid_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualid_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_visualid_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_visualid_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_visualid_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_visualid_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualid_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_visualid_iterator_t
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualid_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_visualid_iterator_t
                ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualid_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_visualid_iterator_t
                ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_visualid_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_timestamp_t = u32;
/**
 * @brief xcb_timestamp_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_timestamp_iterator_t {
    /**<  */
    pub data: *mut xcb_timestamp_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timestamp_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_timestamp_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_timestamp_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_timestamp_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_timestamp_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_timestamp_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_timestamp_iterator_t ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_timestamp_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_timestamp_iterator_t ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_timestamp_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_timestamp_iterator_t ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_timestamp_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_keysym_t = u32;
/**
 * @brief xcb_keysym_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_keysym_iterator_t {
    /**<  */
    pub data: *mut xcb_keysym_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keysym_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_keysym_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_keysym_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_keysym_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_keysym_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_keysym_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_keysym_iterator_t )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_keysym_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_keysym_iterator_t )
                , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_keysym_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_keysym_iterator_t )
                , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_keysym_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_keycode_t = u8;
/**
 * @brief xcb_keycode_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_keycode_iterator_t {
    /**<  */
    pub data: *mut xcb_keycode_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_keycode_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_keycode_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_keycode_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_keycode_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_keycode_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_keycode_iterator_t
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_keycode_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_keycode_iterator_t
                ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_keycode_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_keycode_iterator_t
                ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_keycode_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_button_t = u8;
/**
 * @brief xcb_button_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_button_iterator_t {
    /**<  */
    pub data: *mut xcb_button_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_button_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_button_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_button_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_button_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_button_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_button_iterator_t )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_button_iterator_t )
                , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_button_iterator_t )
                , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_button_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_point_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_point_t {
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_point_t() {
    assert_eq!(::std::mem::size_of::<xcb_point_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( xcb_point_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_point_t>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_point_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_point_t ) ) . x as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_point_t ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_point_t ) ) . y as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_point_t ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for xcb_point_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_point_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_point_iterator_t {
    /**<  */
    pub data: *mut xcb_point_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_point_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_point_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_point_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_point_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_point_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_point_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_point_iterator_t )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_point_iterator_t ) ) . rem as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_point_iterator_t )
                , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_point_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_point_iterator_t )
                , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_point_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_rectangle_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rectangle_t {
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_t() {
    assert_eq!(::std::mem::size_of::<xcb_rectangle_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( xcb_rectangle_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_rectangle_t>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( xcb_rectangle_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rectangle_t ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_rectangle_t ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rectangle_t ) ) . y as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_rectangle_t ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rectangle_t ) ) . width as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_rectangle_t ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rectangle_t ) ) . height as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_rectangle_t ) ,
                "::" , stringify ! ( height ) ));
}
impl Clone for xcb_rectangle_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_rectangle_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rectangle_iterator_t {
    /**<  */
    pub data: *mut xcb_rectangle_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_rectangle_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_rectangle_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_rectangle_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_rectangle_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rectangle_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_rectangle_iterator_t ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rectangle_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_rectangle_iterator_t ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rectangle_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_rectangle_iterator_t ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_rectangle_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_arc_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_arc_t {
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
    /**<  */
    pub angle1: i16,
    /**<  */
    pub angle2: i16,
}
#[test]
fn bindgen_test_layout_xcb_arc_t() {
    assert_eq!(::std::mem::size_of::<xcb_arc_t>() , 12usize , concat ! (
               "Size of: " , stringify ! ( xcb_arc_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_arc_t>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_arc_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_arc_t ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_arc_t ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_arc_t ) ) . y as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_arc_t ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_arc_t ) ) . width as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_arc_t ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_arc_t ) ) . height as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_arc_t ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_arc_t ) ) . angle1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_arc_t ) , "::" ,
                stringify ! ( angle1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_arc_t ) ) . angle2 as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_arc_t ) , "::" ,
                stringify ! ( angle2 ) ));
}
impl Clone for xcb_arc_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_arc_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_arc_iterator_t {
    /**<  */
    pub data: *mut xcb_arc_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_arc_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_arc_iterator_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( xcb_arc_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_arc_iterator_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( xcb_arc_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_arc_iterator_t ) ) . data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_arc_iterator_t ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_arc_iterator_t ) ) . rem as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_arc_iterator_t ) ,
                "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_arc_iterator_t ) ) . index as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_arc_iterator_t ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for xcb_arc_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_format_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_format_t {
    /**<  */
    pub depth: u8,
    /**<  */
    pub bits_per_pixel: u8,
    /**<  */
    pub scanline_pad: u8,
    /**<  */
    pub pad0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_format_t() {
    assert_eq!(::std::mem::size_of::<xcb_format_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( xcb_format_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_format_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( xcb_format_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_format_t ) ) . depth as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_format_t ) , "::" ,
                stringify ! ( depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_format_t ) ) . bits_per_pixel as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_format_t ) , "::" ,
                stringify ! ( bits_per_pixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_format_t ) ) . scanline_pad as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_format_t ) , "::" ,
                stringify ! ( scanline_pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_format_t ) ) . pad0 as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_format_t ) , "::" ,
                stringify ! ( pad0 ) ));
}
impl Clone for xcb_format_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_format_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_format_iterator_t {
    /**<  */
    pub data: *mut xcb_format_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_format_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_format_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_format_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_format_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_format_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_format_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_format_iterator_t )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_format_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_format_iterator_t )
                , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_format_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_format_iterator_t )
                , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_format_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_visual_class_t {
    XCB_VISUAL_CLASS_STATIC_GRAY = 0,
    XCB_VISUAL_CLASS_GRAY_SCALE = 1,
    XCB_VISUAL_CLASS_STATIC_COLOR = 2,
    XCB_VISUAL_CLASS_PSEUDO_COLOR = 3,
    XCB_VISUAL_CLASS_TRUE_COLOR = 4,
    XCB_VISUAL_CLASS_DIRECT_COLOR = 5,
}
/**
 * @brief xcb_visualtype_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visualtype_t {
    /**<  */
    pub visual_id: xcb_visualid_t,
    /**<  */
    pub _class: u8,
    /**<  */
    pub bits_per_rgb_value: u8,
    /**<  */
    pub colormap_entries: u16,
    /**<  */
    pub red_mask: u32,
    /**<  */
    pub green_mask: u32,
    /**<  */
    pub blue_mask: u32,
    /**<  */
    pub pad0: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_visualtype_t() {
    assert_eq!(::std::mem::size_of::<xcb_visualtype_t>() , 24usize , concat !
               ( "Size of: " , stringify ! ( xcb_visualtype_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_visualtype_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( xcb_visualtype_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualtype_t ) ) . visual_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_visualtype_t ) ,
                "::" , stringify ! ( visual_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualtype_t ) ) . _class as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_visualtype_t ) ,
                "::" , stringify ! ( _class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualtype_t ) ) . bits_per_rgb_value
                as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_visualtype_t ) ,
                "::" , stringify ! ( bits_per_rgb_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualtype_t ) ) . colormap_entries
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_visualtype_t ) ,
                "::" , stringify ! ( colormap_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualtype_t ) ) . red_mask as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_visualtype_t ) ,
                "::" , stringify ! ( red_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualtype_t ) ) . green_mask as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_visualtype_t ) ,
                "::" , stringify ! ( green_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualtype_t ) ) . blue_mask as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_visualtype_t ) ,
                "::" , stringify ! ( blue_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualtype_t ) ) . pad0 as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_visualtype_t ) ,
                "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_visualtype_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_visualtype_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visualtype_iterator_t {
    /**<  */
    pub data: *mut xcb_visualtype_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualtype_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_visualtype_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_visualtype_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_visualtype_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_visualtype_iterator_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualtype_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_visualtype_iterator_t ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualtype_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_visualtype_iterator_t ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visualtype_iterator_t ) ) . index as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_visualtype_iterator_t ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_visualtype_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_depth_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_depth_t {
    /**<  */
    pub depth: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub visuals_len: u16,
    /**<  */
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_depth_t() {
    assert_eq!(::std::mem::size_of::<xcb_depth_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( xcb_depth_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_depth_t>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_depth_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_depth_t ) ) . depth as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_depth_t ) , "::" ,
                stringify ! ( depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_depth_t ) ) . pad0 as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_depth_t ) , "::" ,
                stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_depth_t ) ) . visuals_len as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_depth_t ) , "::" ,
                stringify ! ( visuals_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_depth_t ) ) . pad1 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_depth_t ) , "::" ,
                stringify ! ( pad1 ) ));
}
impl Clone for xcb_depth_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_depth_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_depth_iterator_t {
    /**<  */
    pub data: *mut xcb_depth_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_depth_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_depth_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_depth_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_depth_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_depth_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_depth_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_depth_iterator_t )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_depth_iterator_t ) ) . rem as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_depth_iterator_t )
                , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_depth_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_depth_iterator_t )
                , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_depth_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_event_mask_t {
    XCB_EVENT_MASK_NO_EVENT = 0,
    XCB_EVENT_MASK_KEY_PRESS = 1,
    XCB_EVENT_MASK_KEY_RELEASE = 2,
    XCB_EVENT_MASK_BUTTON_PRESS = 4,
    XCB_EVENT_MASK_BUTTON_RELEASE = 8,
    XCB_EVENT_MASK_ENTER_WINDOW = 16,
    XCB_EVENT_MASK_LEAVE_WINDOW = 32,
    XCB_EVENT_MASK_POINTER_MOTION = 64,
    XCB_EVENT_MASK_POINTER_MOTION_HINT = 128,
    XCB_EVENT_MASK_BUTTON_1_MOTION = 256,
    XCB_EVENT_MASK_BUTTON_2_MOTION = 512,
    XCB_EVENT_MASK_BUTTON_3_MOTION = 1024,
    XCB_EVENT_MASK_BUTTON_4_MOTION = 2048,
    XCB_EVENT_MASK_BUTTON_5_MOTION = 4096,
    XCB_EVENT_MASK_BUTTON_MOTION = 8192,
    XCB_EVENT_MASK_KEYMAP_STATE = 16384,
    XCB_EVENT_MASK_EXPOSURE = 32768,
    XCB_EVENT_MASK_VISIBILITY_CHANGE = 65536,
    XCB_EVENT_MASK_STRUCTURE_NOTIFY = 131072,
    XCB_EVENT_MASK_RESIZE_REDIRECT = 262144,
    XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY = 524288,
    XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT = 1048576,
    XCB_EVENT_MASK_FOCUS_CHANGE = 2097152,
    XCB_EVENT_MASK_PROPERTY_CHANGE = 4194304,
    XCB_EVENT_MASK_COLOR_MAP_CHANGE = 8388608,
    XCB_EVENT_MASK_OWNER_GRAB_BUTTON = 16777216,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_backing_store_t {
    XCB_BACKING_STORE_NOT_USEFUL = 0,
    XCB_BACKING_STORE_WHEN_MAPPED = 1,
    XCB_BACKING_STORE_ALWAYS = 2,
}
/**
 * @brief xcb_screen_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_screen_t {
    /**<  */
    pub root: xcb_window_t,
    /**<  */
    pub default_colormap: xcb_colormap_t,
    /**<  */
    pub white_pixel: u32,
    /**<  */
    pub black_pixel: u32,
    /**<  */
    pub current_input_masks: u32,
    /**<  */
    pub width_in_pixels: u16,
    /**<  */
    pub height_in_pixels: u16,
    /**<  */
    pub width_in_millimeters: u16,
    /**<  */
    pub height_in_millimeters: u16,
    /**<  */
    pub min_installed_maps: u16,
    /**<  */
    pub max_installed_maps: u16,
    /**<  */
    pub root_visual: xcb_visualid_t,
    /**<  */
    pub backing_stores: u8,
    /**<  */
    pub save_unders: u8,
    /**<  */
    pub root_depth: u8,
    /**<  */
    pub allowed_depths_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_screen_t() {
    assert_eq!(::std::mem::size_of::<xcb_screen_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( xcb_screen_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_screen_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_screen_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . root as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . default_colormap as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( default_colormap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . white_pixel as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( white_pixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . black_pixel as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( black_pixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . current_input_masks as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( current_input_masks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . width_in_pixels as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( width_in_pixels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . height_in_pixels as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( height_in_pixels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . width_in_millimeters
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( width_in_millimeters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . height_in_millimeters
                as * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( height_in_millimeters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . min_installed_maps as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( min_installed_maps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . max_installed_maps as
                * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( max_installed_maps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . root_visual as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( root_visual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . backing_stores as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( backing_stores ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . save_unders as * const
                _ as usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( save_unders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . root_depth as * const
                _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( root_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_t ) ) . allowed_depths_len as
                * const _ as usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_t ) , "::" ,
                stringify ! ( allowed_depths_len ) ));
}
impl Clone for xcb_screen_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_screen_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_screen_iterator_t {
    /**<  */
    pub data: *mut xcb_screen_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_screen_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_screen_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_screen_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_screen_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_screen_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_iterator_t )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_iterator_t )
                , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_screen_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_screen_iterator_t )
                , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_screen_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_setup_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_request_t {
    /**<  */
    pub byte_order: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub protocol_major_version: u16,
    /**<  */
    pub protocol_minor_version: u16,
    /**<  */
    pub authorization_protocol_name_len: u16,
    /**<  */
    pub authorization_protocol_data_len: u16,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_request_t>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( xcb_setup_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_setup_request_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_setup_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_request_t ) ) . byte_order as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_request_t ) ,
                "::" , stringify ! ( byte_order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_request_t ) ) . pad0 as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_request_t ) ,
                "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_request_t ) ) .
                protocol_major_version as * const _ as usize } , 2usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_request_t ) ,
                "::" , stringify ! ( protocol_major_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_request_t ) ) .
                protocol_minor_version as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_request_t ) ,
                "::" , stringify ! ( protocol_minor_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_request_t ) ) .
                authorization_protocol_name_len as * const _ as usize } ,
                6usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_request_t ) ,
                "::" , stringify ! ( authorization_protocol_name_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_request_t ) ) .
                authorization_protocol_data_len as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_request_t ) ,
                "::" , stringify ! ( authorization_protocol_data_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_request_t ) ) . pad1 as * const
                _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_request_t ) ,
                "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_setup_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_setup_request_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_request_iterator_t {
    /**<  */
    pub data: *mut xcb_setup_request_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_request_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_request_iterator_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_setup_request_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_setup_request_iterator_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( xcb_setup_request_iterator_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_request_iterator_t ) ) . data
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_request_iterator_t ) , "::" , stringify ! ( data )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_request_iterator_t ) ) . rem as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_request_iterator_t ) , "::" , stringify ! ( rem )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_request_iterator_t ) ) . index
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_request_iterator_t ) , "::" , stringify ! ( index )
                ));
}
impl Clone for xcb_setup_request_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_setup_failed_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_failed_t {
    /**<  */
    pub status: u8,
    /**<  */
    pub reason_len: u8,
    /**<  */
    pub protocol_major_version: u16,
    /**<  */
    pub protocol_minor_version: u16,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_failed_t>() , 8usize , concat !
               ( "Size of: " , stringify ! ( xcb_setup_failed_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_setup_failed_t>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( xcb_setup_failed_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_failed_t ) ) . status as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_failed_t ) ,
                "::" , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_failed_t ) ) . reason_len as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_failed_t ) ,
                "::" , stringify ! ( reason_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_failed_t ) ) .
                protocol_major_version as * const _ as usize } , 2usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_failed_t ) ,
                "::" , stringify ! ( protocol_major_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_failed_t ) ) .
                protocol_minor_version as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_failed_t ) ,
                "::" , stringify ! ( protocol_minor_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_failed_t ) ) . length as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_failed_t ) ,
                "::" , stringify ! ( length ) ));
}
impl Clone for xcb_setup_failed_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_setup_failed_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_failed_iterator_t {
    /**<  */
    pub data: *mut xcb_setup_failed_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_failed_iterator_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_setup_failed_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_setup_failed_iterator_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_setup_failed_iterator_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_failed_iterator_t ) ) . data as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_failed_iterator_t ) , "::" , stringify ! ( data )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_failed_iterator_t ) ) . rem as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_failed_iterator_t ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_failed_iterator_t ) ) . index
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_failed_iterator_t ) , "::" , stringify ! ( index )
                ));
}
impl Clone for xcb_setup_failed_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_setup_authenticate_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_authenticate_t {
    /**<  */
    pub status: u8,
    /**<  */
    pub pad0: [u8; 5usize],
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_authenticate_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_setup_authenticate_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_setup_authenticate_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_setup_authenticate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_authenticate_t ) ) . status as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_authenticate_t ) , "::" , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_authenticate_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_authenticate_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_authenticate_t ) ) . length as
                * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_authenticate_t ) , "::" , stringify ! ( length ) ));
}
impl Clone for xcb_setup_authenticate_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_setup_authenticate_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_authenticate_iterator_t {
    /**<  */
    pub data: *mut xcb_setup_authenticate_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_authenticate_iterator_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( xcb_setup_authenticate_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_setup_authenticate_iterator_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_setup_authenticate_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_authenticate_iterator_t ) ) .
                data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_authenticate_iterator_t ) , "::" , stringify ! (
                data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_authenticate_iterator_t ) ) .
                rem as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_authenticate_iterator_t ) , "::" , stringify ! ( rem
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_authenticate_iterator_t ) ) .
                index as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_setup_authenticate_iterator_t ) , "::" , stringify ! (
                index ) ));
}
impl Clone for xcb_setup_authenticate_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_image_order_t {
    XCB_IMAGE_ORDER_LSB_FIRST = 0,
    XCB_IMAGE_ORDER_MSB_FIRST = 1,
}
/**
 * @brief xcb_setup_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_iterator_t {
    /**<  */
    pub data: *mut xcb_setup_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_setup_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_setup_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_setup_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_iterator_t )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_iterator_t ) ) . rem as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_iterator_t )
                , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_setup_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_setup_iterator_t )
                , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_setup_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_mod_mask_t {
    XCB_MOD_MASK_SHIFT = 1,
    XCB_MOD_MASK_LOCK = 2,
    XCB_MOD_MASK_CONTROL = 4,
    XCB_MOD_MASK_1 = 8,
    XCB_MOD_MASK_2 = 16,
    XCB_MOD_MASK_3 = 32,
    XCB_MOD_MASK_4 = 64,
    XCB_MOD_MASK_5 = 128,
    XCB_MOD_MASK_ANY = 32768,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_key_but_mask_t {
    XCB_KEY_BUT_MASK_SHIFT = 1,
    XCB_KEY_BUT_MASK_LOCK = 2,
    XCB_KEY_BUT_MASK_CONTROL = 4,
    XCB_KEY_BUT_MASK_MOD_1 = 8,
    XCB_KEY_BUT_MASK_MOD_2 = 16,
    XCB_KEY_BUT_MASK_MOD_3 = 32,
    XCB_KEY_BUT_MASK_MOD_4 = 64,
    XCB_KEY_BUT_MASK_MOD_5 = 128,
    XCB_KEY_BUT_MASK_BUTTON_1 = 256,
    XCB_KEY_BUT_MASK_BUTTON_2 = 512,
    XCB_KEY_BUT_MASK_BUTTON_3 = 1024,
    XCB_KEY_BUT_MASK_BUTTON_4 = 2048,
    XCB_KEY_BUT_MASK_BUTTON_5 = 4096,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_window_enum_t { XCB_WINDOW_NONE = 0, }
/**
 * @brief xcb_key_press_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_key_press_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub detail: xcb_keycode_t,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub time: xcb_timestamp_t,
    /**<  */
    pub root: xcb_window_t,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub child: xcb_window_t,
    /**<  */
    pub root_x: i16,
    /**<  */
    pub root_y: i16,
    /**<  */
    pub event_x: i16,
    /**<  */
    pub event_y: i16,
    /**<  */
    pub state: u16,
    /**<  */
    pub same_screen: u8,
    /**<  */
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_key_press_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_key_press_event_t>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_key_press_event_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_key_press_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_key_press_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . response_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . detail as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( detail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . sequence as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . time as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . root as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . event as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . child as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . root_x as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( root_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . root_y as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( root_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . event_x as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( event_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . event_y as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( event_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . state as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . same_screen
                as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( same_screen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_key_press_event_t ) ) . pad0 as *
                const _ as usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_key_press_event_t )
                , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_key_press_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_key_release_event_t = xcb_key_press_event_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_button_mask_t {
    XCB_BUTTON_MASK_1 = 256,
    XCB_BUTTON_MASK_2 = 512,
    XCB_BUTTON_MASK_3 = 1024,
    XCB_BUTTON_MASK_4 = 2048,
    XCB_BUTTON_MASK_5 = 4096,
    XCB_BUTTON_MASK_ANY = 32768,
}
/**
 * @brief xcb_button_press_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_button_press_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub detail: xcb_button_t,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub time: xcb_timestamp_t,
    /**<  */
    pub root: xcb_window_t,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub child: xcb_window_t,
    /**<  */
    pub root_x: i16,
    /**<  */
    pub root_y: i16,
    /**<  */
    pub event_x: i16,
    /**<  */
    pub event_y: i16,
    /**<  */
    pub state: u16,
    /**<  */
    pub same_screen: u8,
    /**<  */
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_button_press_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_button_press_event_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_button_press_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_button_press_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_button_press_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . detail as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( detail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . time as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . root as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . event as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . child as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . root_x as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( root_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . root_y as
                * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( root_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . event_x as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( event_x )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . event_y as
                * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( event_y )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . state as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) .
                same_screen as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( same_screen
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_button_press_event_t ) ) . pad0 as *
                const _ as usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_button_press_event_t ) , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_button_press_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_button_release_event_t = xcb_button_press_event_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_motion_t { XCB_MOTION_NORMAL = 0, XCB_MOTION_HINT = 1, }
/**
 * @brief xcb_motion_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_motion_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub detail: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub time: xcb_timestamp_t,
    /**<  */
    pub root: xcb_window_t,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub child: xcb_window_t,
    /**<  */
    pub root_x: i16,
    /**<  */
    pub root_y: i16,
    /**<  */
    pub event_x: i16,
    /**<  */
    pub event_y: i16,
    /**<  */
    pub state: u16,
    /**<  */
    pub same_screen: u8,
    /**<  */
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_motion_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_motion_notify_event_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_motion_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_motion_notify_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_motion_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . detail as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( detail )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . time as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . root as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . event as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . child as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . root_x as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( root_x )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . root_y as
                * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( root_y )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . event_x
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( event_x )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . event_y
                as * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( event_y )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . state as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) .
                same_screen as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( same_screen
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_motion_notify_event_t ) ) . pad0 as *
                const _ as usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_motion_notify_event_t ) , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_motion_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_notify_detail_t {
    XCB_NOTIFY_DETAIL_ANCESTOR = 0,
    XCB_NOTIFY_DETAIL_VIRTUAL = 1,
    XCB_NOTIFY_DETAIL_INFERIOR = 2,
    XCB_NOTIFY_DETAIL_NONLINEAR = 3,
    XCB_NOTIFY_DETAIL_NONLINEAR_VIRTUAL = 4,
    XCB_NOTIFY_DETAIL_POINTER = 5,
    XCB_NOTIFY_DETAIL_POINTER_ROOT = 6,
    XCB_NOTIFY_DETAIL_NONE = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_notify_mode_t {
    XCB_NOTIFY_MODE_NORMAL = 0,
    XCB_NOTIFY_MODE_GRAB = 1,
    XCB_NOTIFY_MODE_UNGRAB = 2,
    XCB_NOTIFY_MODE_WHILE_GRABBED = 3,
}
/**
 * @brief xcb_enter_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_enter_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub detail: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub time: xcb_timestamp_t,
    /**<  */
    pub root: xcb_window_t,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub child: xcb_window_t,
    /**<  */
    pub root_x: i16,
    /**<  */
    pub root_y: i16,
    /**<  */
    pub event_x: i16,
    /**<  */
    pub event_y: i16,
    /**<  */
    pub state: u16,
    /**<  */
    pub mode: u8,
    /**<  */
    pub same_screen_focus: u8,
}
#[test]
fn bindgen_test_layout_xcb_enter_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_enter_notify_event_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_enter_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_enter_notify_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_enter_notify_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . detail as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( detail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . time as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . root as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . event as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . child as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . root_x as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( root_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . root_y as
                * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( root_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . event_x as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( event_x )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . event_y as
                * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( event_y )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . state as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) . mode as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_enter_notify_event_t ) ) .
                same_screen_focus as * const _ as usize } , 31usize , concat !
                (
                "Alignment of field: " , stringify ! (
                xcb_enter_notify_event_t ) , "::" , stringify ! (
                same_screen_focus ) ));
}
impl Clone for xcb_enter_notify_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_leave_notify_event_t = xcb_enter_notify_event_t;
/**
 * @brief xcb_focus_in_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_focus_in_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub detail: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub mode: u8,
    /**<  */
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_focus_in_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_focus_in_event_t>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_focus_in_event_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_focus_in_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_focus_in_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_focus_in_event_t ) ) . response_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_focus_in_event_t )
                , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_focus_in_event_t ) ) . detail as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_focus_in_event_t )
                , "::" , stringify ! ( detail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_focus_in_event_t ) ) . sequence as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_focus_in_event_t )
                , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_focus_in_event_t ) ) . event as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_focus_in_event_t )
                , "::" , stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_focus_in_event_t ) ) . mode as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_focus_in_event_t )
                , "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_focus_in_event_t ) ) . pad0 as *
                const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_focus_in_event_t )
                , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_focus_in_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_focus_out_event_t = xcb_focus_in_event_t;
/**
 * @brief xcb_keymap_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_keymap_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub keys: [u8; 31usize],
}
#[test]
fn bindgen_test_layout_xcb_keymap_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_keymap_notify_event_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_keymap_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_keymap_notify_event_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_keymap_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_keymap_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_keymap_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_keymap_notify_event_t ) ) . keys as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_keymap_notify_event_t ) , "::" , stringify ! ( keys ) ));
}
impl Clone for xcb_keymap_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_expose_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_expose_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub x: u16,
    /**<  */
    pub y: u16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
    /**<  */
    pub count: u16,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_expose_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_expose_event_t>() , 20usize , concat
               ! ( "Size of: " , stringify ! ( xcb_expose_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_expose_event_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( xcb_expose_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_expose_event_t ) ) . response_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_expose_event_t ) ,
                "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_expose_event_t ) ) . pad0 as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_expose_event_t ) ,
                "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_expose_event_t ) ) . sequence as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_expose_event_t ) ,
                "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_expose_event_t ) ) . window as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_expose_event_t ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_expose_event_t ) ) . x as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_expose_event_t ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_expose_event_t ) ) . y as * const _
                as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_expose_event_t ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_expose_event_t ) ) . width as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_expose_event_t ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_expose_event_t ) ) . height as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_expose_event_t ) ,
                "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_expose_event_t ) ) . count as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_expose_event_t ) ,
                "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_expose_event_t ) ) . pad1 as * const
                _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_expose_event_t ) ,
                "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_expose_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_graphics_exposure_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_graphics_exposure_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub x: u16,
    /**<  */
    pub y: u16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
    /**<  */
    pub minor_opcode: u16,
    /**<  */
    pub count: u16,
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_graphics_exposure_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_graphics_exposure_event_t>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( xcb_graphics_exposure_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_graphics_exposure_event_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_graphics_exposure_event_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) .
                drawable as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! (
                drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) . x as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) . y as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) . width
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! ( width )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) .
                height as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! ( height
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) .
                minor_opcode as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! (
                minor_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) . count
                as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! ( count )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) .
                major_opcode as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_graphics_exposure_event_t ) ) . pad1
                as * const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_graphics_exposure_event_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_graphics_exposure_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_no_exposure_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_no_exposure_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub minor_opcode: u16,
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_no_exposure_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_no_exposure_event_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_no_exposure_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_no_exposure_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_no_exposure_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_no_exposure_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_no_exposure_event_t
                ) , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_no_exposure_event_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_no_exposure_event_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_no_exposure_event_t ) ) . sequence as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_no_exposure_event_t
                ) , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_no_exposure_event_t ) ) . drawable as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_no_exposure_event_t
                ) , "::" , stringify ! ( drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_no_exposure_event_t ) ) .
                minor_opcode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_no_exposure_event_t
                ) , "::" , stringify ! ( minor_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_no_exposure_event_t ) ) .
                major_opcode as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_no_exposure_event_t
                ) , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_no_exposure_event_t ) ) . pad1 as *
                const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_no_exposure_event_t
                ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_no_exposure_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_visibility_t {
    XCB_VISIBILITY_UNOBSCURED = 0,
    XCB_VISIBILITY_PARTIALLY_OBSCURED = 1,
    XCB_VISIBILITY_FULLY_OBSCURED = 2,
}
/**
 * @brief xcb_visibility_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visibility_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub state: u8,
    /**<  */
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_visibility_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_visibility_notify_event_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( xcb_visibility_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_visibility_notify_event_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_visibility_notify_event_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visibility_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_visibility_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visibility_notify_event_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_visibility_notify_event_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visibility_notify_event_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_visibility_notify_event_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visibility_notify_event_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_visibility_notify_event_t ) , "::" , stringify ! ( window
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visibility_notify_event_t ) ) . state
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_visibility_notify_event_t ) , "::" , stringify ! ( state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_visibility_notify_event_t ) ) . pad1
                as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_visibility_notify_event_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_visibility_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_create_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub parent: xcb_window_t,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
    /**<  */
    pub border_width: u16,
    /**<  */
    pub override_redirect: u8,
    /**<  */
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_create_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_notify_event_t>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_create_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_create_notify_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_create_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) . parent as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! ( parent )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) . window as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! ( window )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) . x as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) . y as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) . width as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) . height as
                * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! ( height )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) .
                border_width as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! (
                border_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) .
                override_redirect as * const _ as usize } , 22usize , concat !
                (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! (
                override_redirect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_notify_event_t ) ) . pad1 as *
                const _ as usize } , 23usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_notify_event_t ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_create_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_destroy_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_destroy_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_destroy_notify_event_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_destroy_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_destroy_notify_event_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_destroy_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_notify_event_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_notify_event_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_notify_event_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_notify_event_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_notify_event_t ) ) . event as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_notify_event_t ) , "::" , stringify ! ( event )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_notify_event_t ) ) . window
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_notify_event_t ) , "::" , stringify ! ( window )
                ));
}
impl Clone for xcb_destroy_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_unmap_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_unmap_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub from_configure: u8,
    /**<  */
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_unmap_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_unmap_notify_event_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_unmap_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_unmap_notify_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_unmap_notify_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_notify_event_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_notify_event_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_notify_event_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_notify_event_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_notify_event_t ) ) . event as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_notify_event_t ) , "::" , stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_notify_event_t ) ) . window as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_notify_event_t ) , "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_notify_event_t ) ) .
                from_configure as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_notify_event_t ) , "::" , stringify ! (
                from_configure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_notify_event_t ) ) . pad1 as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_notify_event_t ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_unmap_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_map_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub override_redirect: u8,
    /**<  */
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_map_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_notify_event_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_map_notify_event_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_map_notify_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_map_notify_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_map_notify_event_t
                ) , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_notify_event_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_map_notify_event_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_notify_event_t ) ) . sequence as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_map_notify_event_t
                ) , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_notify_event_t ) ) . event as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_map_notify_event_t
                ) , "::" , stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_notify_event_t ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_map_notify_event_t
                ) , "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_notify_event_t ) ) .
                override_redirect as * const _ as usize } , 12usize , concat !
                (
                "Alignment of field: " , stringify ! ( xcb_map_notify_event_t
                ) , "::" , stringify ! ( override_redirect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_notify_event_t ) ) . pad1 as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_map_notify_event_t
                ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_map_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_map_request_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_request_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub parent: xcb_window_t,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_request_event_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_map_request_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_map_request_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_map_request_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_request_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_map_request_event_t
                ) , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_request_event_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_map_request_event_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_request_event_t ) ) . sequence as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_map_request_event_t
                ) , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_request_event_t ) ) . parent as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_map_request_event_t
                ) , "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_request_event_t ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_map_request_event_t
                ) , "::" , stringify ! ( window ) ));
}
impl Clone for xcb_map_request_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_reparent_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_reparent_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub parent: xcb_window_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
    /**<  */
    pub override_redirect: u8,
    /**<  */
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_reparent_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_reparent_notify_event_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_reparent_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_reparent_notify_event_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_reparent_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_notify_event_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_notify_event_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_notify_event_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_notify_event_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_notify_event_t ) ) . event
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_notify_event_t ) , "::" , stringify ! ( event )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_notify_event_t ) ) . window
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_notify_event_t ) , "::" , stringify ! ( window )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_notify_event_t ) ) . parent
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_notify_event_t ) , "::" , stringify ! ( parent )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_notify_event_t ) ) . x as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_notify_event_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_notify_event_t ) ) . y as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_notify_event_t ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_notify_event_t ) ) .
                override_redirect as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! (
                xcb_reparent_notify_event_t ) , "::" , stringify ! (
                override_redirect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_notify_event_t ) ) . pad1 as
                * const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_notify_event_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_reparent_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_configure_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_configure_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub above_sibling: xcb_window_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
    /**<  */
    pub border_width: u16,
    /**<  */
    pub override_redirect: u8,
    /**<  */
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_configure_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_configure_notify_event_t>() , 28usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_configure_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_configure_notify_event_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_configure_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) . event
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! ( event )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) . window
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! ( window )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) .
                above_sibling as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! (
                above_sibling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) . x as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) . y as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) . width
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! ( width )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) . height
                as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! ( height )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) .
                border_width as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! (
                border_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) .
                override_redirect as * const _ as usize } , 26usize , concat !
                (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! (
                override_redirect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_notify_event_t ) ) . pad1
                as * const _ as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_notify_event_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_configure_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_configure_request_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_configure_request_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub stack_mode: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub parent: xcb_window_t,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub sibling: xcb_window_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
    /**<  */
    pub border_width: u16,
    /**<  */
    pub value_mask: u16,
}
#[test]
fn bindgen_test_layout_xcb_configure_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_configure_request_event_t>() ,
               28usize , concat ! (
               "Size of: " , stringify ! ( xcb_configure_request_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_configure_request_event_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_configure_request_event_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) .
                stack_mode as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! (
                stack_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) .
                parent as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! ( parent
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) .
                window as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! ( window
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) .
                sibling as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! ( sibling
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) . x as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) . y as
                * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) . width
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! ( width )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) .
                height as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! ( height
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) .
                border_width as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! (
                border_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_request_event_t ) ) .
                value_mask as * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_request_event_t ) , "::" , stringify ! (
                value_mask ) ));
}
impl Clone for xcb_configure_request_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_gravity_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_gravity_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_gravity_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_gravity_notify_event_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_gravity_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_gravity_notify_event_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_gravity_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_gravity_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_gravity_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_gravity_notify_event_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_gravity_notify_event_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_gravity_notify_event_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_gravity_notify_event_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_gravity_notify_event_t ) ) . event as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_gravity_notify_event_t ) , "::" , stringify ! ( event )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_gravity_notify_event_t ) ) . window
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_gravity_notify_event_t ) , "::" , stringify ! ( window )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_gravity_notify_event_t ) ) . x as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_gravity_notify_event_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_gravity_notify_event_t ) ) . y as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_gravity_notify_event_t ) , "::" , stringify ! ( y ) ));
}
impl Clone for xcb_gravity_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_resize_request_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_resize_request_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_resize_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_resize_request_event_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_resize_request_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_resize_request_event_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_resize_request_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_resize_request_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_resize_request_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_resize_request_event_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_resize_request_event_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_resize_request_event_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_resize_request_event_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_resize_request_event_t ) ) . window
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_resize_request_event_t ) , "::" , stringify ! ( window )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_resize_request_event_t ) ) . width as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_resize_request_event_t ) , "::" , stringify ! ( width )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_resize_request_event_t ) ) . height
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_resize_request_event_t ) , "::" , stringify ! ( height )
                ));
}
impl Clone for xcb_resize_request_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_place_t { XCB_PLACE_ON_TOP = 0, XCB_PLACE_ON_BOTTOM = 1, }
/**
 * @brief xcb_circulate_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_circulate_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub event: xcb_window_t,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub pad1: [u8; 4usize],
    /**<  */
    pub place: u8,
    /**<  */
    pub pad2: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_circulate_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_circulate_notify_event_t>() , 20usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_circulate_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_circulate_notify_event_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_circulate_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_notify_event_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_notify_event_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_notify_event_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_notify_event_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_notify_event_t ) ) . event
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_notify_event_t ) , "::" , stringify ! ( event )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_notify_event_t ) ) . window
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_notify_event_t ) , "::" , stringify ! ( window )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_notify_event_t ) ) . pad1
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_notify_event_t ) , "::" , stringify ! ( pad1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_notify_event_t ) ) . place
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_notify_event_t ) , "::" , stringify ! ( place )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_notify_event_t ) ) . pad2
                as * const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_notify_event_t ) , "::" , stringify ! ( pad2 )
                ));
}
impl Clone for xcb_circulate_notify_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_circulate_request_event_t = xcb_circulate_notify_event_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_property_t {
    XCB_PROPERTY_NEW_VALUE = 0,
    XCB_PROPERTY_DELETE = 1,
}
/**
 * @brief xcb_property_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_property_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub atom: xcb_atom_t,
    /**<  */
    pub time: xcb_timestamp_t,
    /**<  */
    pub state: u8,
    /**<  */
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_property_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_property_notify_event_t>() , 20usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_property_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_property_notify_event_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_property_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_property_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_property_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_property_notify_event_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_property_notify_event_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_property_notify_event_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_property_notify_event_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_property_notify_event_t ) ) . window
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_property_notify_event_t ) , "::" , stringify ! ( window )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_property_notify_event_t ) ) . atom as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_property_notify_event_t ) , "::" , stringify ! ( atom )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_property_notify_event_t ) ) . time as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_property_notify_event_t ) , "::" , stringify ! ( time )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_property_notify_event_t ) ) . state
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_property_notify_event_t ) , "::" , stringify ! ( state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_property_notify_event_t ) ) . pad1 as
                * const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_property_notify_event_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_property_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_selection_clear_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_selection_clear_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub time: xcb_timestamp_t,
    /**<  */
    pub owner: xcb_window_t,
    /**<  */
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_clear_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_selection_clear_event_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_selection_clear_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_selection_clear_event_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_selection_clear_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_clear_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_clear_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_clear_event_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_clear_event_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_clear_event_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_clear_event_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_clear_event_t ) ) . time as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_clear_event_t ) , "::" , stringify ! ( time )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_clear_event_t ) ) . owner
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_clear_event_t ) , "::" , stringify ! ( owner )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_clear_event_t ) ) .
                selection as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_clear_event_t ) , "::" , stringify ! ( selection
                ) ));
}
impl Clone for xcb_selection_clear_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_time_t { XCB_TIME_CURRENT_TIME = 0, }
pub const xcb_atom_enum_t_XCB_ATOM_ANY: xcb_atom_enum_t =
    xcb_atom_enum_t::XCB_ATOM_NONE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_atom_enum_t {
    XCB_ATOM_NONE = 0,
    XCB_ATOM_PRIMARY = 1,
    XCB_ATOM_SECONDARY = 2,
    XCB_ATOM_ARC = 3,
    XCB_ATOM_ATOM = 4,
    XCB_ATOM_BITMAP = 5,
    XCB_ATOM_CARDINAL = 6,
    XCB_ATOM_COLORMAP = 7,
    XCB_ATOM_CURSOR = 8,
    XCB_ATOM_CUT_BUFFER0 = 9,
    XCB_ATOM_CUT_BUFFER1 = 10,
    XCB_ATOM_CUT_BUFFER2 = 11,
    XCB_ATOM_CUT_BUFFER3 = 12,
    XCB_ATOM_CUT_BUFFER4 = 13,
    XCB_ATOM_CUT_BUFFER5 = 14,
    XCB_ATOM_CUT_BUFFER6 = 15,
    XCB_ATOM_CUT_BUFFER7 = 16,
    XCB_ATOM_DRAWABLE = 17,
    XCB_ATOM_FONT = 18,
    XCB_ATOM_INTEGER = 19,
    XCB_ATOM_PIXMAP = 20,
    XCB_ATOM_POINT = 21,
    XCB_ATOM_RECTANGLE = 22,
    XCB_ATOM_RESOURCE_MANAGER = 23,
    XCB_ATOM_RGB_COLOR_MAP = 24,
    XCB_ATOM_RGB_BEST_MAP = 25,
    XCB_ATOM_RGB_BLUE_MAP = 26,
    XCB_ATOM_RGB_DEFAULT_MAP = 27,
    XCB_ATOM_RGB_GRAY_MAP = 28,
    XCB_ATOM_RGB_GREEN_MAP = 29,
    XCB_ATOM_RGB_RED_MAP = 30,
    XCB_ATOM_STRING = 31,
    XCB_ATOM_VISUALID = 32,
    XCB_ATOM_WINDOW = 33,
    XCB_ATOM_WM_COMMAND = 34,
    XCB_ATOM_WM_HINTS = 35,
    XCB_ATOM_WM_CLIENT_MACHINE = 36,
    XCB_ATOM_WM_ICON_NAME = 37,
    XCB_ATOM_WM_ICON_SIZE = 38,
    XCB_ATOM_WM_NAME = 39,
    XCB_ATOM_WM_NORMAL_HINTS = 40,
    XCB_ATOM_WM_SIZE_HINTS = 41,
    XCB_ATOM_WM_ZOOM_HINTS = 42,
    XCB_ATOM_MIN_SPACE = 43,
    XCB_ATOM_NORM_SPACE = 44,
    XCB_ATOM_MAX_SPACE = 45,
    XCB_ATOM_END_SPACE = 46,
    XCB_ATOM_SUPERSCRIPT_X = 47,
    XCB_ATOM_SUPERSCRIPT_Y = 48,
    XCB_ATOM_SUBSCRIPT_X = 49,
    XCB_ATOM_SUBSCRIPT_Y = 50,
    XCB_ATOM_UNDERLINE_POSITION = 51,
    XCB_ATOM_UNDERLINE_THICKNESS = 52,
    XCB_ATOM_STRIKEOUT_ASCENT = 53,
    XCB_ATOM_STRIKEOUT_DESCENT = 54,
    XCB_ATOM_ITALIC_ANGLE = 55,
    XCB_ATOM_X_HEIGHT = 56,
    XCB_ATOM_QUAD_WIDTH = 57,
    XCB_ATOM_WEIGHT = 58,
    XCB_ATOM_POINT_SIZE = 59,
    XCB_ATOM_RESOLUTION = 60,
    XCB_ATOM_COPYRIGHT = 61,
    XCB_ATOM_NOTICE = 62,
    XCB_ATOM_FONT_NAME = 63,
    XCB_ATOM_FAMILY_NAME = 64,
    XCB_ATOM_FULL_NAME = 65,
    XCB_ATOM_CAP_HEIGHT = 66,
    XCB_ATOM_WM_CLASS = 67,
    XCB_ATOM_WM_TRANSIENT_FOR = 68,
}
/**
 * @brief xcb_selection_request_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_selection_request_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub time: xcb_timestamp_t,
    /**<  */
    pub owner: xcb_window_t,
    /**<  */
    pub requestor: xcb_window_t,
    /**<  */
    pub selection: xcb_atom_t,
    /**<  */
    pub target: xcb_atom_t,
    /**<  */
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_selection_request_event_t>() ,
               28usize , concat ! (
               "Size of: " , stringify ! ( xcb_selection_request_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_selection_request_event_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_selection_request_event_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_request_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_request_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_request_event_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_request_event_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_request_event_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_request_event_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_request_event_t ) ) . time
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_request_event_t ) , "::" , stringify ! ( time )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_request_event_t ) ) . owner
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_request_event_t ) , "::" , stringify ! ( owner )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_request_event_t ) ) .
                requestor as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_request_event_t ) , "::" , stringify ! (
                requestor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_request_event_t ) ) .
                selection as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_request_event_t ) , "::" , stringify ! (
                selection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_request_event_t ) ) .
                target as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_request_event_t ) , "::" , stringify ! ( target
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_request_event_t ) ) .
                property as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_request_event_t ) , "::" , stringify ! (
                property ) ));
}
impl Clone for xcb_selection_request_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_selection_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_selection_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub time: xcb_timestamp_t,
    /**<  */
    pub requestor: xcb_window_t,
    /**<  */
    pub selection: xcb_atom_t,
    /**<  */
    pub target: xcb_atom_t,
    /**<  */
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_selection_notify_event_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_selection_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_selection_notify_event_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_selection_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_notify_event_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_notify_event_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_notify_event_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_notify_event_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_notify_event_t ) ) . time
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_notify_event_t ) , "::" , stringify ! ( time )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_notify_event_t ) ) .
                requestor as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_notify_event_t ) , "::" , stringify ! (
                requestor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_notify_event_t ) ) .
                selection as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_notify_event_t ) , "::" , stringify ! (
                selection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_notify_event_t ) ) . target
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_notify_event_t ) , "::" , stringify ! ( target )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_selection_notify_event_t ) ) .
                property as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_selection_notify_event_t ) , "::" , stringify ! ( property
                ) ));
}
impl Clone for xcb_selection_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_colormap_state_t {
    XCB_COLORMAP_STATE_UNINSTALLED = 0,
    XCB_COLORMAP_STATE_INSTALLED = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_colormap_enum_t { XCB_COLORMAP_NONE = 0, }
/**
 * @brief xcb_colormap_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_colormap_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub colormap: xcb_colormap_t,
    /**<  */
    pub _new: u8,
    /**<  */
    pub state: u8,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_colormap_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_colormap_notify_event_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_colormap_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_colormap_notify_event_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_colormap_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_colormap_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_colormap_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_colormap_notify_event_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_colormap_notify_event_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_colormap_notify_event_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_colormap_notify_event_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_colormap_notify_event_t ) ) . window
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_colormap_notify_event_t ) , "::" , stringify ! ( window )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_colormap_notify_event_t ) ) .
                colormap as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_colormap_notify_event_t ) , "::" , stringify ! ( colormap
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_colormap_notify_event_t ) ) . _new as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_colormap_notify_event_t ) , "::" , stringify ! ( _new )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_colormap_notify_event_t ) ) . state
                as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_colormap_notify_event_t ) , "::" , stringify ! ( state )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_colormap_notify_event_t ) ) . pad1 as
                * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_colormap_notify_event_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_colormap_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_client_message_data_t
 **/
#[repr(C)]
#[derive(Copy)]
pub struct xcb_client_message_data_t {
    pub data32: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_t() {
    assert_eq!(::std::mem::size_of::<xcb_client_message_data_t>() , 20usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_client_message_data_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_client_message_data_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_client_message_data_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_data_t ) ) . data8 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_data_t ) , "::" , stringify ! ( data8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_data_t ) ) . data16 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_data_t ) , "::" , stringify ! ( data16 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_data_t ) ) . data32 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_data_t ) , "::" , stringify ! ( data32 )
                ));
}
impl Clone for xcb_client_message_data_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_client_message_data_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_client_message_data_iterator_t {
    /**<  */
    pub data: *mut xcb_client_message_data_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_client_message_data_iterator_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( xcb_client_message_data_iterator_t
               ) ));
    assert_eq! (::std::mem::align_of::<xcb_client_message_data_iterator_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_client_message_data_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_data_iterator_t ) ) .
                data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_data_iterator_t ) , "::" , stringify ! (
                data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_data_iterator_t ) ) .
                rem as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_data_iterator_t ) , "::" , stringify ! (
                rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_data_iterator_t ) ) .
                index as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_data_iterator_t ) , "::" , stringify ! (
                index ) ));
}
impl Clone for xcb_client_message_data_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_client_message_event_t
 **/
#[repr(C)]
#[derive(Copy)]
pub struct xcb_client_message_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub format: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub type_: xcb_atom_t,
    /**<  */
    pub data: xcb_client_message_data_t,
}
#[test]
fn bindgen_test_layout_xcb_client_message_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_client_message_event_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_client_message_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_client_message_event_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_client_message_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_event_t ) ) . format
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_event_t ) , "::" , stringify ! ( format )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_event_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_event_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_event_t ) ) . window
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_event_t ) , "::" , stringify ! ( window )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_event_t ) ) . type_ as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_event_t ) , "::" , stringify ! ( type_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_client_message_event_t ) ) . data as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_client_message_event_t ) , "::" , stringify ! ( data ) ));
}
impl Clone for xcb_client_message_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_mapping_t {
    XCB_MAPPING_MODIFIER = 0,
    XCB_MAPPING_KEYBOARD = 1,
    XCB_MAPPING_POINTER = 2,
}
/**
 * @brief xcb_mapping_notify_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_mapping_notify_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub request: u8,
    /**<  */
    pub first_keycode: xcb_keycode_t,
    /**<  */
    pub count: u8,
    /**<  */
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_mapping_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_mapping_notify_event_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_mapping_notify_event_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_mapping_notify_event_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_mapping_notify_event_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_mapping_notify_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_mapping_notify_event_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_mapping_notify_event_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_mapping_notify_event_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_mapping_notify_event_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_mapping_notify_event_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_mapping_notify_event_t ) ) . request
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_mapping_notify_event_t ) , "::" , stringify ! ( request )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_mapping_notify_event_t ) ) .
                first_keycode as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_mapping_notify_event_t ) , "::" , stringify ! (
                first_keycode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_mapping_notify_event_t ) ) . count as
                * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_mapping_notify_event_t ) , "::" , stringify ! ( count )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_mapping_notify_event_t ) ) . pad1 as
                * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_mapping_notify_event_t ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_mapping_notify_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_ge_generic_event_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ge_generic_event_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub extension: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub event_type: u16,
    /**<  */
    pub pad0: [u8; 22usize],
    /**<  */
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_generic_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_ge_generic_event_t>() , 36usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_ge_generic_event_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_ge_generic_event_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_ge_generic_event_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_generic_event_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_generic_event_t
                ) , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_generic_event_t ) ) . extension as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_generic_event_t
                ) , "::" , stringify ! ( extension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_generic_event_t ) ) . sequence as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_generic_event_t
                ) , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_generic_event_t ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_generic_event_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_generic_event_t ) ) . event_type
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_generic_event_t
                ) , "::" , stringify ! ( event_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_generic_event_t ) ) . pad0 as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_generic_event_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ge_generic_event_t ) ) .
                full_sequence as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_ge_generic_event_t
                ) , "::" , stringify ! ( full_sequence ) ));
}
impl Clone for xcb_ge_generic_event_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_request_error_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_request_error_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub error_code: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub bad_value: u32,
    /**<  */
    pub minor_opcode: u16,
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_request_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_request_error_t>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( xcb_request_error_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_request_error_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_request_error_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_request_error_t ) ) . response_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_request_error_t ) ,
                "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_request_error_t ) ) . error_code as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_request_error_t ) ,
                "::" , stringify ! ( error_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_request_error_t ) ) . sequence as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_request_error_t ) ,
                "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_request_error_t ) ) . bad_value as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_request_error_t ) ,
                "::" , stringify ! ( bad_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_request_error_t ) ) . minor_opcode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_request_error_t ) ,
                "::" , stringify ! ( minor_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_request_error_t ) ) . major_opcode as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_request_error_t ) ,
                "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_request_error_t ) ) . pad0 as * const
                _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_request_error_t ) ,
                "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_request_error_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_value_error_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_value_error_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub error_code: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub bad_value: u32,
    /**<  */
    pub minor_opcode: u16,
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_value_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_value_error_t>() , 12usize , concat !
               ( "Size of: " , stringify ! ( xcb_value_error_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_value_error_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( xcb_value_error_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_value_error_t ) ) . response_type as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_value_error_t ) ,
                "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_value_error_t ) ) . error_code as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_value_error_t ) ,
                "::" , stringify ! ( error_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_value_error_t ) ) . sequence as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_value_error_t ) ,
                "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_value_error_t ) ) . bad_value as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_value_error_t ) ,
                "::" , stringify ! ( bad_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_value_error_t ) ) . minor_opcode as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_value_error_t ) ,
                "::" , stringify ! ( minor_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_value_error_t ) ) . major_opcode as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_value_error_t ) ,
                "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_value_error_t ) ) . pad0 as * const _
                as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_value_error_t ) ,
                "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_value_error_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_window_error_t = xcb_value_error_t;
pub type xcb_pixmap_error_t = xcb_value_error_t;
pub type xcb_atom_error_t = xcb_value_error_t;
pub type xcb_cursor_error_t = xcb_value_error_t;
pub type xcb_font_error_t = xcb_value_error_t;
pub type xcb_match_error_t = xcb_request_error_t;
pub type xcb_drawable_error_t = xcb_value_error_t;
pub type xcb_access_error_t = xcb_request_error_t;
pub type xcb_alloc_error_t = xcb_request_error_t;
pub type xcb_colormap_error_t = xcb_value_error_t;
pub type xcb_g_context_error_t = xcb_value_error_t;
pub type xcb_id_choice_error_t = xcb_value_error_t;
pub type xcb_name_error_t = xcb_request_error_t;
pub type xcb_length_error_t = xcb_request_error_t;
pub type xcb_implementation_error_t = xcb_request_error_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_window_class_t {
    XCB_WINDOW_CLASS_COPY_FROM_PARENT = 0,
    XCB_WINDOW_CLASS_INPUT_OUTPUT = 1,
    XCB_WINDOW_CLASS_INPUT_ONLY = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_cw_t {
    XCB_CW_BACK_PIXMAP = 1,
    XCB_CW_BACK_PIXEL = 2,
    XCB_CW_BORDER_PIXMAP = 4,
    XCB_CW_BORDER_PIXEL = 8,
    XCB_CW_BIT_GRAVITY = 16,
    XCB_CW_WIN_GRAVITY = 32,
    XCB_CW_BACKING_STORE = 64,
    XCB_CW_BACKING_PLANES = 128,
    XCB_CW_BACKING_PIXEL = 256,
    XCB_CW_OVERRIDE_REDIRECT = 512,
    XCB_CW_SAVE_UNDER = 1024,
    XCB_CW_EVENT_MASK = 2048,
    XCB_CW_DONT_PROPAGATE = 4096,
    XCB_CW_COLORMAP = 8192,
    XCB_CW_CURSOR = 16384,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_back_pixmap_t {
    XCB_BACK_PIXMAP_NONE = 0,
    XCB_BACK_PIXMAP_PARENT_RELATIVE = 1,
}
pub const xcb_gravity_t_XCB_GRAVITY_WIN_UNMAP: xcb_gravity_t =
    xcb_gravity_t::XCB_GRAVITY_BIT_FORGET;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_gravity_t {
    XCB_GRAVITY_BIT_FORGET = 0,
    XCB_GRAVITY_NORTH_WEST = 1,
    XCB_GRAVITY_NORTH = 2,
    XCB_GRAVITY_NORTH_EAST = 3,
    XCB_GRAVITY_WEST = 4,
    XCB_GRAVITY_CENTER = 5,
    XCB_GRAVITY_EAST = 6,
    XCB_GRAVITY_SOUTH_WEST = 7,
    XCB_GRAVITY_SOUTH = 8,
    XCB_GRAVITY_SOUTH_EAST = 9,
    XCB_GRAVITY_STATIC = 10,
}
/**
 * @brief xcb_create_window_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_window_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub depth: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub wid: xcb_window_t,
    /**<  */
    pub parent: xcb_window_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
    /**<  */
    pub border_width: u16,
    /**<  */
    pub _class: u16,
    /**<  */
    pub visual: xcb_visualid_t,
    /**<  */
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_window_request_t>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_create_window_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_create_window_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_create_window_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) . depth
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! ( depth )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) . wid as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! ( wid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) . parent
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! ( parent )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) . x as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) . y as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) . width
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! ( width )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) . height
                as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! ( height )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) .
                border_width as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! (
                border_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) . _class
                as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! ( _class )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) . visual
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! ( visual )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_window_request_t ) ) .
                value_mask as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_window_request_t ) , "::" , stringify ! (
                value_mask ) ));
}
impl Clone for xcb_create_window_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_change_window_attributes_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_window_attributes_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_window_attributes_request_t>()
               , 12usize , concat ! (
               "Size of: " , stringify ! (
               xcb_change_window_attributes_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_change_window_attributes_request_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_change_window_attributes_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_window_attributes_request_t )
                ) . major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_window_attributes_request_t ) , "::" , stringify !
                ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_window_attributes_request_t )
                ) . pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_window_attributes_request_t ) , "::" , stringify !
                ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_window_attributes_request_t )
                ) . length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_window_attributes_request_t ) , "::" , stringify !
                ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_window_attributes_request_t )
                ) . window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_window_attributes_request_t ) , "::" , stringify !
                ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_window_attributes_request_t )
                ) . value_mask as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_window_attributes_request_t ) , "::" , stringify !
                ( value_mask ) ));
}
impl Clone for xcb_change_window_attributes_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_map_state_t {
    XCB_MAP_STATE_UNMAPPED = 0,
    XCB_MAP_STATE_UNVIEWABLE = 1,
    XCB_MAP_STATE_VIEWABLE = 2,
}
/**
 * @brief xcb_get_window_attributes_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_window_attributes_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_window_attributes_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_window_attributes_cookie_t
               ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_window_attributes_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_window_attributes_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_get_window_attributes_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_window_attributes_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_window_attributes_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_window_attributes_request_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_window_attributes_request_t
               ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_window_attributes_request_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_window_attributes_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_request_t ) , "::" , stringify ! (
                window ) ));
}
impl Clone for xcb_get_window_attributes_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_window_attributes_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_window_attributes_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub backing_store: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub visual: xcb_visualid_t,
    /**<  */
    pub _class: u16,
    /**<  */
    pub bit_gravity: u8,
    /**<  */
    pub win_gravity: u8,
    /**<  */
    pub backing_planes: u32,
    /**<  */
    pub backing_pixel: u32,
    /**<  */
    pub save_under: u8,
    /**<  */
    pub map_is_installed: u8,
    /**<  */
    pub map_state: u8,
    /**<  */
    pub override_redirect: u8,
    /**<  */
    pub colormap: xcb_colormap_t,
    /**<  */
    pub all_event_masks: u32,
    /**<  */
    pub your_event_mask: u32,
    /**<  */
    pub do_not_propagate_mask: u16,
    /**<  */
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_window_attributes_reply_t>() ,
               44usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_window_attributes_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_window_attributes_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_window_attributes_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                backing_store as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                backing_store ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                visual as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                visual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                _class as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                _class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                bit_gravity as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                bit_gravity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                win_gravity as * const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                win_gravity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                backing_planes as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                backing_planes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                backing_pixel as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                backing_pixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                save_under as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                save_under ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                map_is_installed as * const _ as usize } , 25usize , concat !
                (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                map_is_installed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                map_state as * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                map_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                override_redirect as * const _ as usize } , 27usize , concat !
                (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                override_redirect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                colormap as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                colormap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                all_event_masks as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                all_event_masks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                your_event_mask as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                your_event_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                do_not_propagate_mask as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                do_not_propagate_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_window_attributes_reply_t ) ) .
                pad0 as * const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_window_attributes_reply_t ) , "::" , stringify ! (
                pad0 ) ));
}
impl Clone for xcb_get_window_attributes_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_destroy_window_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_destroy_window_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_destroy_window_request_t>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_destroy_window_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_destroy_window_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_destroy_window_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_window_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_window_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_window_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_window_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_window_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_window_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_window_request_t ) ) . window
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_window_request_t ) , "::" , stringify ! ( window )
                ));
}
impl Clone for xcb_destroy_window_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_destroy_subwindows_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_destroy_subwindows_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_subwindows_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_destroy_subwindows_request_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( xcb_destroy_subwindows_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_destroy_subwindows_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_destroy_subwindows_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_subwindows_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_subwindows_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_subwindows_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_subwindows_request_t ) , "::" , stringify ! ( pad0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_subwindows_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_subwindows_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_destroy_subwindows_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_destroy_subwindows_request_t ) , "::" , stringify ! (
                window ) ));
}
impl Clone for xcb_destroy_subwindows_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_set_mode_t { XCB_SET_MODE_INSERT = 0, XCB_SET_MODE_DELETE = 1, }
/**
 * @brief xcb_change_save_set_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_save_set_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub mode: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_change_save_set_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_save_set_request_t>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_change_save_set_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_change_save_set_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_change_save_set_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_save_set_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_save_set_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_save_set_request_t ) ) . mode
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_save_set_request_t ) , "::" , stringify ! ( mode )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_save_set_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_save_set_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_save_set_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_save_set_request_t ) , "::" , stringify ! ( window
                ) ));
}
impl Clone for xcb_change_save_set_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_reparent_window_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_reparent_window_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub parent: xcb_window_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_reparent_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_reparent_window_request_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( xcb_reparent_window_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_reparent_window_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_reparent_window_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_window_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_window_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_window_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_window_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_window_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_window_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_window_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_window_request_t ) , "::" , stringify ! ( window
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_window_request_t ) ) .
                parent as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_window_request_t ) , "::" , stringify ! ( parent
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_window_request_t ) ) . x as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_window_request_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_reparent_window_request_t ) ) . y as
                * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_reparent_window_request_t ) , "::" , stringify ! ( y ) ));
}
impl Clone for xcb_reparent_window_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_map_window_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_window_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_window_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_map_window_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_map_window_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_map_window_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_window_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_map_window_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_window_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_map_window_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_window_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_map_window_request_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_window_request_t ) ) . window as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_map_window_request_t ) , "::" , stringify ! ( window ) ));
}
impl Clone for xcb_map_window_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_map_subwindows_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_subwindows_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_subwindows_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_subwindows_request_t>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_map_subwindows_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_map_subwindows_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_map_subwindows_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_subwindows_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_map_subwindows_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_subwindows_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_map_subwindows_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_subwindows_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_map_subwindows_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_map_subwindows_request_t ) ) . window
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_map_subwindows_request_t ) , "::" , stringify ! ( window )
                ));
}
impl Clone for xcb_map_subwindows_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_unmap_window_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_unmap_window_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_unmap_window_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_unmap_window_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_unmap_window_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_unmap_window_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_window_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_window_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_window_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_window_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_window_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_window_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_window_request_t ) ) . window
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_window_request_t ) , "::" , stringify ! ( window )
                ));
}
impl Clone for xcb_unmap_window_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_unmap_subwindows_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_unmap_subwindows_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_subwindows_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_unmap_subwindows_request_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( xcb_unmap_subwindows_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_unmap_subwindows_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_unmap_subwindows_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_subwindows_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_subwindows_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_subwindows_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_subwindows_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_subwindows_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_subwindows_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_unmap_subwindows_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_unmap_subwindows_request_t ) , "::" , stringify ! ( window
                ) ));
}
impl Clone for xcb_unmap_subwindows_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_config_window_t {
    XCB_CONFIG_WINDOW_X = 1,
    XCB_CONFIG_WINDOW_Y = 2,
    XCB_CONFIG_WINDOW_WIDTH = 4,
    XCB_CONFIG_WINDOW_HEIGHT = 8,
    XCB_CONFIG_WINDOW_BORDER_WIDTH = 16,
    XCB_CONFIG_WINDOW_SIBLING = 32,
    XCB_CONFIG_WINDOW_STACK_MODE = 64,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_stack_mode_t {
    XCB_STACK_MODE_ABOVE = 0,
    XCB_STACK_MODE_BELOW = 1,
    XCB_STACK_MODE_TOP_IF = 2,
    XCB_STACK_MODE_BOTTOM_IF = 3,
    XCB_STACK_MODE_OPPOSITE = 4,
}
/**
 * @brief xcb_configure_window_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_configure_window_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub value_mask: u16,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_configure_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_configure_window_request_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( xcb_configure_window_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_configure_window_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_configure_window_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_window_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_window_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_window_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_window_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_window_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_window_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_window_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_window_request_t ) , "::" , stringify ! ( window
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_window_request_t ) ) .
                value_mask as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_window_request_t ) , "::" , stringify ! (
                value_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_configure_window_request_t ) ) . pad1
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_configure_window_request_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_configure_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_circulate_t {
    XCB_CIRCULATE_RAISE_LOWEST = 0,
    XCB_CIRCULATE_LOWER_HIGHEST = 1,
}
/**
 * @brief xcb_circulate_window_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_circulate_window_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub direction: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_circulate_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_circulate_window_request_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( xcb_circulate_window_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_circulate_window_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_circulate_window_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_window_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_window_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_window_request_t ) ) .
                direction as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_window_request_t ) , "::" , stringify ! (
                direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_window_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_window_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_circulate_window_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_circulate_window_request_t ) , "::" , stringify ! ( window
                ) ));
}
impl Clone for xcb_circulate_window_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_geometry_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_geometry_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_geometry_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_geometry_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_geometry_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_get_geometry_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_get_geometry_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_geometry_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_geometry_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_geometry_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_geometry_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_geometry_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_get_geometry_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_request_t ) ) . drawable
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_request_t ) , "::" , stringify ! ( drawable )
                ));
}
impl Clone for xcb_get_geometry_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_geometry_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_geometry_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub depth: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub root: xcb_window_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
    /**<  */
    pub border_width: u16,
    /**<  */
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_geometry_reply_t>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_geometry_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_geometry_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_get_geometry_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_reply_t ) ) . depth as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_reply_t ) , "::" , stringify ! ( depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_reply_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_reply_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_reply_t ) ) . length as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_reply_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_reply_t ) ) . root as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_reply_t ) , "::" , stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_reply_t ) ) . x as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_reply_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_reply_t ) ) . y as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_reply_t ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_reply_t ) ) . width as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_reply_t ) , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_reply_t ) ) . height as
                * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_reply_t ) , "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_reply_t ) ) .
                border_width as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_reply_t ) , "::" , stringify ! ( border_width
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_geometry_reply_t ) ) . pad0 as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_geometry_reply_t ) , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_get_geometry_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_tree_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_tree_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_tree_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_tree_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_tree_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_query_tree_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_cookie_t ) ) . sequence as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_tree_cookie_t
                ) , "::" , stringify ! ( sequence ) ));
}
impl Clone for xcb_query_tree_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_tree_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_tree_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_tree_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_tree_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_tree_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_query_tree_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_tree_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_tree_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_tree_request_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_request_t ) ) . window as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_tree_request_t ) , "::" , stringify ! ( window ) ));
}
impl Clone for xcb_query_tree_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_tree_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_tree_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub root: xcb_window_t,
    /**<  */
    pub parent: xcb_window_t,
    /**<  */
    pub children_len: u16,
    /**<  */
    pub pad1: [u8; 14usize],
}
#[test]
fn bindgen_test_layout_xcb_query_tree_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_tree_reply_t>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_query_tree_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_query_tree_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_query_tree_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_tree_reply_t
                ) , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_reply_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_tree_reply_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_reply_t ) ) . sequence as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_tree_reply_t
                ) , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_reply_t ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_tree_reply_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_reply_t ) ) . root as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_tree_reply_t
                ) , "::" , stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_reply_t ) ) . parent as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_tree_reply_t
                ) , "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_reply_t ) ) . children_len
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_tree_reply_t
                ) , "::" , stringify ! ( children_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_tree_reply_t ) ) . pad1 as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_tree_reply_t
                ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_query_tree_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_intern_atom_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_intern_atom_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_intern_atom_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_intern_atom_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_intern_atom_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_intern_atom_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_intern_atom_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_intern_atom_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_intern_atom_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_intern_atom_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_intern_atom_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub only_if_exists: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub name_len: u16,
    /**<  */
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_intern_atom_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_intern_atom_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_intern_atom_request_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_intern_atom_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_intern_atom_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_intern_atom_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_intern_atom_request_t ) ) .
                only_if_exists as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_intern_atom_request_t ) , "::" , stringify ! (
                only_if_exists ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_intern_atom_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_intern_atom_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_intern_atom_request_t ) ) . name_len
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_intern_atom_request_t ) , "::" , stringify ! ( name_len )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_intern_atom_request_t ) ) . pad0 as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_intern_atom_request_t ) , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_intern_atom_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_intern_atom_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_intern_atom_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_intern_atom_reply_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_intern_atom_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_intern_atom_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_intern_atom_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_intern_atom_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_intern_atom_reply_t
                ) , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_intern_atom_reply_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_intern_atom_reply_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_intern_atom_reply_t ) ) . sequence as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_intern_atom_reply_t
                ) , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_intern_atom_reply_t ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_intern_atom_reply_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_intern_atom_reply_t ) ) . atom as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_intern_atom_reply_t
                ) , "::" , stringify ! ( atom ) ));
}
impl Clone for xcb_intern_atom_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_atom_name_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_atom_name_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_atom_name_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_atom_name_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_atom_name_cookie_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_get_atom_name_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_atom_name_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_atom_name_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_get_atom_name_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_atom_name_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_atom_name_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_atom_name_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_atom_name_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_atom_name_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_get_atom_name_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_atom_name_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_atom_name_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_atom_name_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_atom_name_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_atom_name_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_atom_name_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_atom_name_request_t ) ) . atom as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_atom_name_request_t ) , "::" , stringify ! ( atom )
                ));
}
impl Clone for xcb_get_atom_name_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_atom_name_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_atom_name_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub name_len: u16,
    /**<  */
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_atom_name_reply_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_atom_name_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_atom_name_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_get_atom_name_reply_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_atom_name_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_atom_name_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_atom_name_reply_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_atom_name_reply_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_atom_name_reply_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_atom_name_reply_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_atom_name_reply_t ) ) . length as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_atom_name_reply_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_atom_name_reply_t ) ) . name_len
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_atom_name_reply_t ) , "::" , stringify ! ( name_len )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_atom_name_reply_t ) ) . pad1 as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_atom_name_reply_t ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_get_atom_name_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_prop_mode_t {
    XCB_PROP_MODE_REPLACE = 0,
    XCB_PROP_MODE_PREPEND = 1,
    XCB_PROP_MODE_APPEND = 2,
}
/**
 * @brief xcb_change_property_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_property_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub mode: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub property: xcb_atom_t,
    /**<  */
    pub type_: xcb_atom_t,
    /**<  */
    pub format: u8,
    /**<  */
    pub pad0: [u8; 3usize],
    /**<  */
    pub data_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_property_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_property_request_t>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( xcb_change_property_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_change_property_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_change_property_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_property_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_property_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_property_request_t ) ) . mode
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_property_request_t ) , "::" , stringify ! ( mode )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_property_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_property_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_property_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_property_request_t ) , "::" , stringify ! ( window
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_property_request_t ) ) .
                property as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_property_request_t ) , "::" , stringify ! (
                property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_property_request_t ) ) . type_
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_property_request_t ) , "::" , stringify ! ( type_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_property_request_t ) ) .
                format as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_property_request_t ) , "::" , stringify ! ( format
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_property_request_t ) ) . pad0
                as * const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_property_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_property_request_t ) ) .
                data_len as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_property_request_t ) , "::" , stringify ! (
                data_len ) ));
}
impl Clone for xcb_change_property_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_delete_property_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_delete_property_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_delete_property_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_delete_property_request_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( xcb_delete_property_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_delete_property_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_delete_property_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_delete_property_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_delete_property_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_delete_property_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_delete_property_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_delete_property_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_delete_property_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_delete_property_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_delete_property_request_t ) , "::" , stringify ! ( window
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_delete_property_request_t ) ) .
                property as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_delete_property_request_t ) , "::" , stringify ! (
                property ) ));
}
impl Clone for xcb_delete_property_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_get_property_type_t { XCB_GET_PROPERTY_TYPE_ANY = 0, }
/**
 * @brief xcb_get_property_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_property_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_property_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_property_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_property_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_property_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_get_property_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_get_property_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_property_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_property_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub _delete: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub property: xcb_atom_t,
    /**<  */
    pub type_: xcb_atom_t,
    /**<  */
    pub long_offset: u32,
    /**<  */
    pub long_length: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_property_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_property_request_t>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_property_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_property_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_get_property_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_request_t ) ) . _delete
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_request_t ) , "::" , stringify ! ( _delete )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_request_t ) ) . window
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_request_t ) , "::" , stringify ! ( window )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_request_t ) ) . property
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_request_t ) , "::" , stringify ! ( property )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_request_t ) ) . type_ as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_request_t ) , "::" , stringify ! ( type_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_request_t ) ) .
                long_offset as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_request_t ) , "::" , stringify ! (
                long_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_request_t ) ) .
                long_length as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_request_t ) , "::" , stringify ! (
                long_length ) ));
}
impl Clone for xcb_get_property_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_property_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_property_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub format: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub type_: xcb_atom_t,
    /**<  */
    pub bytes_after: u32,
    /**<  */
    pub value_len: u32,
    /**<  */
    pub pad0: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_xcb_get_property_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_property_reply_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_property_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_property_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_get_property_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_reply_t ) ) . format as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_reply_t ) , "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_reply_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_reply_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_reply_t ) ) . length as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_reply_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_reply_t ) ) . type_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_reply_t ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_reply_t ) ) .
                bytes_after as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_reply_t ) , "::" , stringify ! ( bytes_after
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_reply_t ) ) . value_len
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_reply_t ) , "::" , stringify ! ( value_len )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_property_reply_t ) ) . pad0 as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_property_reply_t ) , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_get_property_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_properties_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_properties_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_properties_cookie_t>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_list_properties_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_properties_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_list_properties_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_properties_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_properties_cookie_t ) , "::" , stringify ! ( sequence
                ) ));
}
impl Clone for xcb_list_properties_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_properties_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_properties_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_properties_request_t>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_list_properties_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_properties_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_list_properties_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_properties_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_properties_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_properties_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_properties_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_properties_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_properties_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_properties_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_properties_request_t ) , "::" , stringify ! ( window
                ) ));
}
impl Clone for xcb_list_properties_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_properties_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_properties_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub atoms_len: u16,
    /**<  */
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_properties_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_properties_reply_t>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_list_properties_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_properties_reply_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_list_properties_reply_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_properties_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_properties_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_properties_reply_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_properties_reply_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_properties_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_properties_reply_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_properties_reply_t ) ) . length
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_properties_reply_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_properties_reply_t ) ) .
                atoms_len as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_properties_reply_t ) , "::" , stringify ! ( atoms_len
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_properties_reply_t ) ) . pad1 as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_properties_reply_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_list_properties_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_set_selection_owner_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_selection_owner_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub owner: xcb_window_t,
    /**<  */
    pub selection: xcb_atom_t,
    /**<  */
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_selection_owner_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_selection_owner_request_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_selection_owner_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_set_selection_owner_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_set_selection_owner_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_selection_owner_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_selection_owner_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_selection_owner_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_selection_owner_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_selection_owner_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_selection_owner_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_selection_owner_request_t ) ) .
                owner as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_selection_owner_request_t ) , "::" , stringify ! (
                owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_selection_owner_request_t ) ) .
                selection as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_selection_owner_request_t ) , "::" , stringify ! (
                selection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_selection_owner_request_t ) ) .
                time as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_selection_owner_request_t ) , "::" , stringify ! (
                time ) ));
}
impl Clone for xcb_set_selection_owner_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_selection_owner_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_selection_owner_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_selection_owner_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_selection_owner_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_selection_owner_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_selection_owner_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_selection_owner_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_selection_owner_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_get_selection_owner_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_selection_owner_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_selection_owner_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_selection_owner_request_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_selection_owner_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_selection_owner_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_selection_owner_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_selection_owner_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_selection_owner_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_selection_owner_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_selection_owner_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_selection_owner_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_selection_owner_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_selection_owner_request_t ) ) .
                selection as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_selection_owner_request_t ) , "::" , stringify ! (
                selection ) ));
}
impl Clone for xcb_get_selection_owner_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_selection_owner_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_selection_owner_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub owner: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_selection_owner_reply_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_selection_owner_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_selection_owner_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_selection_owner_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_selection_owner_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_selection_owner_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_selection_owner_reply_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_selection_owner_reply_t ) , "::" , stringify ! ( pad0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_selection_owner_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_selection_owner_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_selection_owner_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_selection_owner_reply_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_selection_owner_reply_t ) ) .
                owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_selection_owner_reply_t ) , "::" , stringify ! ( owner
                ) ));
}
impl Clone for xcb_get_selection_owner_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_convert_selection_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_convert_selection_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub requestor: xcb_window_t,
    /**<  */
    pub selection: xcb_atom_t,
    /**<  */
    pub target: xcb_atom_t,
    /**<  */
    pub property: xcb_atom_t,
    /**<  */
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_convert_selection_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_convert_selection_request_t>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( xcb_convert_selection_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_convert_selection_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_convert_selection_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_convert_selection_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_convert_selection_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_convert_selection_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_convert_selection_request_t ) , "::" , stringify ! ( pad0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_convert_selection_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_convert_selection_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_convert_selection_request_t ) ) .
                requestor as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_convert_selection_request_t ) , "::" , stringify ! (
                requestor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_convert_selection_request_t ) ) .
                selection as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_convert_selection_request_t ) , "::" , stringify ! (
                selection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_convert_selection_request_t ) ) .
                target as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_convert_selection_request_t ) , "::" , stringify ! (
                target ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_convert_selection_request_t ) ) .
                property as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_convert_selection_request_t ) , "::" , stringify ! (
                property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_convert_selection_request_t ) ) .
                time as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_convert_selection_request_t ) , "::" , stringify ! ( time
                ) ));
}
impl Clone for xcb_convert_selection_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_send_event_dest_t {
    XCB_SEND_EVENT_DEST_POINTER_WINDOW = 0,
    XCB_SEND_EVENT_DEST_ITEM_FOCUS = 1,
}
/**
 * @brief xcb_send_event_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_send_event_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub propagate: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub destination: xcb_window_t,
    /**<  */
    pub event_mask: u32,
    /**<  */
    pub event: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_send_event_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_send_event_request_t>() , 44usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_send_event_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_send_event_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_send_event_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_send_event_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_send_event_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_send_event_request_t ) ) . propagate
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_send_event_request_t ) , "::" , stringify ! ( propagate )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_send_event_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_send_event_request_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_send_event_request_t ) ) .
                destination as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_send_event_request_t ) , "::" , stringify ! ( destination
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_send_event_request_t ) ) . event_mask
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_send_event_request_t ) , "::" , stringify ! ( event_mask )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_send_event_request_t ) ) . event as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_send_event_request_t ) , "::" , stringify ! ( event ) ));
}
impl Clone for xcb_send_event_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_grab_mode_t { XCB_GRAB_MODE_SYNC = 0, XCB_GRAB_MODE_ASYNC = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_grab_status_t {
    XCB_GRAB_STATUS_SUCCESS = 0,
    XCB_GRAB_STATUS_ALREADY_GRABBED = 1,
    XCB_GRAB_STATUS_INVALID_TIME = 2,
    XCB_GRAB_STATUS_NOT_VIEWABLE = 3,
    XCB_GRAB_STATUS_FROZEN = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_cursor_enum_t { XCB_CURSOR_NONE = 0, }
/**
 * @brief xcb_grab_pointer_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_pointer_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_pointer_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_grab_pointer_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_grab_pointer_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_grab_pointer_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_grab_pointer_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_grab_pointer_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_pointer_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub owner_events: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub grab_window: xcb_window_t,
    /**<  */
    pub event_mask: u16,
    /**<  */
    pub pointer_mode: u8,
    /**<  */
    pub keyboard_mode: u8,
    /**<  */
    pub confine_to: xcb_window_t,
    /**<  */
    pub cursor: xcb_cursor_t,
    /**<  */
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_pointer_request_t>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_grab_pointer_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_grab_pointer_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_grab_pointer_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_request_t ) ) .
                owner_events as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_request_t ) , "::" , stringify ! (
                owner_events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_request_t ) ) .
                grab_window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_request_t ) , "::" , stringify ! (
                grab_window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_request_t ) ) .
                event_mask as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_request_t ) , "::" , stringify ! ( event_mask
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_request_t ) ) .
                pointer_mode as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_request_t ) , "::" , stringify ! (
                pointer_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_request_t ) ) .
                keyboard_mode as * const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_request_t ) , "::" , stringify ! (
                keyboard_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_request_t ) ) .
                confine_to as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_request_t ) , "::" , stringify ! ( confine_to
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_request_t ) ) . cursor
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_request_t ) , "::" , stringify ! ( cursor )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_request_t ) ) . time as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_request_t ) , "::" , stringify ! ( time ) ));
}
impl Clone for xcb_grab_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_grab_pointer_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_pointer_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub status: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_pointer_reply_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_grab_pointer_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_grab_pointer_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_grab_pointer_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_reply_t ) ) . status as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_reply_t ) , "::" , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_reply_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_reply_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_pointer_reply_t ) ) . length as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_pointer_reply_t ) , "::" , stringify ! ( length ) ));
}
impl Clone for xcb_grab_pointer_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_ungrab_pointer_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_pointer_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_pointer_request_t>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_ungrab_pointer_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_ungrab_pointer_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_ungrab_pointer_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_pointer_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_pointer_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_pointer_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_pointer_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_pointer_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_pointer_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_pointer_request_t ) ) . time
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_pointer_request_t ) , "::" , stringify ! ( time )
                ));
}
impl Clone for xcb_ungrab_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_button_index_t {
    XCB_BUTTON_INDEX_ANY = 0,
    XCB_BUTTON_INDEX_1 = 1,
    XCB_BUTTON_INDEX_2 = 2,
    XCB_BUTTON_INDEX_3 = 3,
    XCB_BUTTON_INDEX_4 = 4,
    XCB_BUTTON_INDEX_5 = 5,
}
/**
 * @brief xcb_grab_button_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_button_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub owner_events: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub grab_window: xcb_window_t,
    /**<  */
    pub event_mask: u16,
    /**<  */
    pub pointer_mode: u8,
    /**<  */
    pub keyboard_mode: u8,
    /**<  */
    pub confine_to: xcb_window_t,
    /**<  */
    pub cursor: xcb_cursor_t,
    /**<  */
    pub button: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub modifiers: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_button_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_button_request_t>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_grab_button_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_grab_button_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_grab_button_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) .
                owner_events as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! (
                owner_events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) .
                grab_window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! ( grab_window
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) .
                event_mask as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! ( event_mask
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) .
                pointer_mode as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! (
                pointer_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) .
                keyboard_mode as * const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! (
                keyboard_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) .
                confine_to as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! ( confine_to
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) . cursor as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! ( cursor )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) . button as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! ( button )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) . pad0 as *
                const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_button_request_t ) ) . modifiers
                as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_button_request_t ) , "::" , stringify ! ( modifiers )
                ));
}
impl Clone for xcb_grab_button_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_ungrab_button_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_button_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub button: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub grab_window: xcb_window_t,
    /**<  */
    pub modifiers: u16,
    /**<  */
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_button_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_button_request_t>() , 12usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_ungrab_button_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_ungrab_button_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_ungrab_button_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_button_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_button_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_button_request_t ) ) . button
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_button_request_t ) , "::" , stringify ! ( button )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_button_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_button_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_button_request_t ) ) .
                grab_window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_button_request_t ) , "::" , stringify ! (
                grab_window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_button_request_t ) ) .
                modifiers as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_button_request_t ) , "::" , stringify ! ( modifiers
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_button_request_t ) ) . pad0 as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_button_request_t ) , "::" , stringify ! ( pad0 )
                ));
}
impl Clone for xcb_ungrab_button_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_change_active_pointer_grab_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_active_pointer_grab_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cursor: xcb_cursor_t,
    /**<  */
    pub time: xcb_timestamp_t,
    /**<  */
    pub event_mask: u16,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_active_pointer_grab_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_active_pointer_grab_request_t>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               xcb_change_active_pointer_grab_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_change_active_pointer_grab_request_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_change_active_pointer_grab_request_t ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const xcb_change_active_pointer_grab_request_t ) )
                . major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_active_pointer_grab_request_t ) , "::" , stringify
                ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const xcb_change_active_pointer_grab_request_t ) )
                . pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_active_pointer_grab_request_t ) , "::" , stringify
                ! ( pad0 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const xcb_change_active_pointer_grab_request_t ) )
                . length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_active_pointer_grab_request_t ) , "::" , stringify
                ! ( length ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const xcb_change_active_pointer_grab_request_t ) )
                . cursor as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_active_pointer_grab_request_t ) , "::" , stringify
                ! ( cursor ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const xcb_change_active_pointer_grab_request_t ) )
                . time as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_active_pointer_grab_request_t ) , "::" , stringify
                ! ( time ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const xcb_change_active_pointer_grab_request_t ) )
                . event_mask as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_active_pointer_grab_request_t ) , "::" , stringify
                ! ( event_mask ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const xcb_change_active_pointer_grab_request_t ) )
                . pad1 as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_active_pointer_grab_request_t ) , "::" , stringify
                ! ( pad1 ) ));
}
impl Clone for xcb_change_active_pointer_grab_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_grab_keyboard_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_keyboard_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_keyboard_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_grab_keyboard_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_grab_keyboard_cookie_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_grab_keyboard_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_grab_keyboard_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_grab_keyboard_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_keyboard_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub owner_events: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub grab_window: xcb_window_t,
    /**<  */
    pub time: xcb_timestamp_t,
    /**<  */
    pub pointer_mode: u8,
    /**<  */
    pub keyboard_mode: u8,
    /**<  */
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_keyboard_request_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_grab_keyboard_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_grab_keyboard_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_grab_keyboard_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_request_t ) ) .
                owner_events as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_request_t ) , "::" , stringify ! (
                owner_events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_request_t ) ) .
                grab_window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_request_t ) , "::" , stringify ! (
                grab_window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_request_t ) ) . time as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_request_t ) , "::" , stringify ! ( time )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_request_t ) ) .
                pointer_mode as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_request_t ) , "::" , stringify ! (
                pointer_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_request_t ) ) .
                keyboard_mode as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_request_t ) , "::" , stringify ! (
                keyboard_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_request_t ) ) . pad0 as
                * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_request_t ) , "::" , stringify ! ( pad0 )
                ));
}
impl Clone for xcb_grab_keyboard_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_grab_keyboard_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_keyboard_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub status: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_keyboard_reply_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_grab_keyboard_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_grab_keyboard_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_grab_keyboard_reply_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_reply_t ) ) . status as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_reply_t ) , "::" , stringify ! ( status )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_reply_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_reply_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_keyboard_reply_t ) ) . length as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_keyboard_reply_t ) , "::" , stringify ! ( length )
                ));
}
impl Clone for xcb_grab_keyboard_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_ungrab_keyboard_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_keyboard_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_keyboard_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_keyboard_request_t>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_ungrab_keyboard_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_ungrab_keyboard_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_ungrab_keyboard_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_keyboard_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_keyboard_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_keyboard_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_keyboard_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_keyboard_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_keyboard_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_keyboard_request_t ) ) . time
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_keyboard_request_t ) , "::" , stringify ! ( time )
                ));
}
impl Clone for xcb_ungrab_keyboard_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_grab_t { XCB_GRAB_ANY = 0, }
/**
 * @brief xcb_grab_key_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_key_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub owner_events: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub grab_window: xcb_window_t,
    /**<  */
    pub modifiers: u16,
    /**<  */
    pub key: xcb_keycode_t,
    /**<  */
    pub pointer_mode: u8,
    /**<  */
    pub keyboard_mode: u8,
    /**<  */
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_key_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_key_request_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_grab_key_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_grab_key_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_grab_key_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_key_request_t ) ) . major_opcode
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_grab_key_request_t
                ) , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_key_request_t ) ) . owner_events
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_grab_key_request_t
                ) , "::" , stringify ! ( owner_events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_key_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_grab_key_request_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_key_request_t ) ) . grab_window
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_grab_key_request_t
                ) , "::" , stringify ! ( grab_window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_key_request_t ) ) . modifiers as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_grab_key_request_t
                ) , "::" , stringify ! ( modifiers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_key_request_t ) ) . key as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_grab_key_request_t
                ) , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_key_request_t ) ) . pointer_mode
                as * const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_grab_key_request_t
                ) , "::" , stringify ! ( pointer_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_key_request_t ) ) .
                keyboard_mode as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_grab_key_request_t
                ) , "::" , stringify ! ( keyboard_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_key_request_t ) ) . pad0 as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_grab_key_request_t
                ) , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_grab_key_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_ungrab_key_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_key_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub key: xcb_keycode_t,
    /**<  */
    pub length: u16,
    /**<  */
    pub grab_window: xcb_window_t,
    /**<  */
    pub modifiers: u16,
    /**<  */
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_key_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_key_request_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_ungrab_key_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_ungrab_key_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_ungrab_key_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_key_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_key_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_key_request_t ) ) . key as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_key_request_t ) , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_key_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_key_request_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_key_request_t ) ) .
                grab_window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_key_request_t ) , "::" , stringify ! ( grab_window
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_key_request_t ) ) . modifiers
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_key_request_t ) , "::" , stringify ! ( modifiers )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_key_request_t ) ) . pad0 as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_key_request_t ) , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_ungrab_key_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_allow_t {
    XCB_ALLOW_ASYNC_POINTER = 0,
    XCB_ALLOW_SYNC_POINTER = 1,
    XCB_ALLOW_REPLAY_POINTER = 2,
    XCB_ALLOW_ASYNC_KEYBOARD = 3,
    XCB_ALLOW_SYNC_KEYBOARD = 4,
    XCB_ALLOW_REPLAY_KEYBOARD = 5,
    XCB_ALLOW_ASYNC_BOTH = 6,
    XCB_ALLOW_SYNC_BOTH = 7,
}
/**
 * @brief xcb_allow_events_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_allow_events_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub mode: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_allow_events_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_allow_events_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_allow_events_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_allow_events_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_allow_events_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_allow_events_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_allow_events_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_allow_events_request_t ) ) . mode as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_allow_events_request_t ) , "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_allow_events_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_allow_events_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_allow_events_request_t ) ) . time as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_allow_events_request_t ) , "::" , stringify ! ( time ) ));
}
impl Clone for xcb_allow_events_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_grab_server_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_server_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_server_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_server_request_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_grab_server_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_grab_server_request_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_grab_server_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_server_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_server_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_server_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_server_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_grab_server_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_grab_server_request_t ) , "::" , stringify ! ( length )
                ));
}
impl Clone for xcb_grab_server_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_ungrab_server_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_server_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_server_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_server_request_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_ungrab_server_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_ungrab_server_request_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_ungrab_server_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_server_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_server_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_server_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_server_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_ungrab_server_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_ungrab_server_request_t ) , "::" , stringify ! ( length )
                ));
}
impl Clone for xcb_ungrab_server_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_pointer_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_pointer_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_pointer_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_pointer_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_pointer_cookie_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_query_pointer_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_query_pointer_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_pointer_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_pointer_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_pointer_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_pointer_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_pointer_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_query_pointer_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_request_t ) ) . window
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_request_t ) , "::" , stringify ! ( window )
                ));
}
impl Clone for xcb_query_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_pointer_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_pointer_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub same_screen: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub root: xcb_window_t,
    /**<  */
    pub child: xcb_window_t,
    /**<  */
    pub root_x: i16,
    /**<  */
    pub root_y: i16,
    /**<  */
    pub win_x: i16,
    /**<  */
    pub win_y: i16,
    /**<  */
    pub mask: u16,
    /**<  */
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_pointer_reply_t>() , 28usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_pointer_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_pointer_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_query_pointer_reply_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) .
                same_screen as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! ( same_screen
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) . length as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) . root as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) . child as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! ( child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) . root_x as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! ( root_x )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) . root_y as
                * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! ( root_y )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) . win_x as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! ( win_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) . win_y as
                * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! ( win_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) . mask as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_pointer_reply_t ) ) . pad0 as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_pointer_reply_t ) , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_query_pointer_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_timecoord_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_timecoord_t {
    /**<  */
    pub time: xcb_timestamp_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_t() {
    assert_eq!(::std::mem::size_of::<xcb_timecoord_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( xcb_timecoord_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_timecoord_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( xcb_timecoord_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_timecoord_t ) ) . time as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_timecoord_t ) ,
                "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_timecoord_t ) ) . x as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_timecoord_t ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_timecoord_t ) ) . y as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_timecoord_t ) ,
                "::" , stringify ! ( y ) ));
}
impl Clone for xcb_timecoord_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_timecoord_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_timecoord_iterator_t {
    /**<  */
    pub data: *mut xcb_timecoord_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_timecoord_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_timecoord_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_timecoord_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_timecoord_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_timecoord_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_timecoord_iterator_t ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_timecoord_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_timecoord_iterator_t ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_timecoord_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_timecoord_iterator_t ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_timecoord_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_motion_events_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_motion_events_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_motion_events_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_motion_events_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_motion_events_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_get_motion_events_cookie_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_get_motion_events_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_motion_events_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_motion_events_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub start: xcb_timestamp_t,
    /**<  */
    pub stop: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_motion_events_request_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_motion_events_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_motion_events_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_motion_events_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_request_t ) , "::" , stringify ! ( pad0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_request_t ) , "::" , stringify ! (
                window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_request_t ) ) .
                start as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_request_t ) , "::" , stringify ! ( start
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_request_t ) ) .
                stop as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_request_t ) , "::" , stringify ! ( stop
                ) ));
}
impl Clone for xcb_get_motion_events_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_motion_events_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_motion_events_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub events_len: u32,
    /**<  */
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_motion_events_reply_t>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_motion_events_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_motion_events_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_get_motion_events_reply_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_reply_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_reply_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_reply_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_reply_t ) ) .
                events_len as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_reply_t ) , "::" , stringify ! (
                events_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_motion_events_reply_t ) ) . pad1
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_motion_events_reply_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_get_motion_events_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_translate_coordinates_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_translate_coordinates_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_translate_coordinates_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_translate_coordinates_cookie_t
               ) ));
    assert_eq! (::std::mem::align_of::<xcb_translate_coordinates_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_translate_coordinates_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_translate_coordinates_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_translate_coordinates_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_translate_coordinates_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub src_window: xcb_window_t,
    /**<  */
    pub dst_window: xcb_window_t,
    /**<  */
    pub src_x: i16,
    /**<  */
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_translate_coordinates_request_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( xcb_translate_coordinates_request_t
               ) ));
    assert_eq! (::std::mem::align_of::<xcb_translate_coordinates_request_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_translate_coordinates_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_request_t ) ) .
                src_window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_request_t ) , "::" , stringify ! (
                src_window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_request_t ) ) .
                dst_window as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_request_t ) , "::" , stringify ! (
                dst_window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_request_t ) ) .
                src_x as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_request_t ) , "::" , stringify ! (
                src_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_request_t ) ) .
                src_y as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_request_t ) , "::" , stringify ! (
                src_y ) ));
}
impl Clone for xcb_translate_coordinates_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_translate_coordinates_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_translate_coordinates_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub same_screen: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub child: xcb_window_t,
    /**<  */
    pub dst_x: i16,
    /**<  */
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_translate_coordinates_reply_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( xcb_translate_coordinates_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_translate_coordinates_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_translate_coordinates_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_reply_t ) ) .
                same_screen as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_reply_t ) , "::" , stringify ! (
                same_screen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_reply_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_reply_t ) ) .
                child as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_reply_t ) , "::" , stringify ! (
                child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_reply_t ) ) .
                dst_x as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_reply_t ) , "::" , stringify ! (
                dst_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_translate_coordinates_reply_t ) ) .
                dst_y as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_translate_coordinates_reply_t ) , "::" , stringify ! (
                dst_y ) ));
}
impl Clone for xcb_translate_coordinates_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_warp_pointer_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_warp_pointer_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub src_window: xcb_window_t,
    /**<  */
    pub dst_window: xcb_window_t,
    /**<  */
    pub src_x: i16,
    /**<  */
    pub src_y: i16,
    /**<  */
    pub src_width: u16,
    /**<  */
    pub src_height: u16,
    /**<  */
    pub dst_x: i16,
    /**<  */
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_warp_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_warp_pointer_request_t>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_warp_pointer_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_warp_pointer_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_warp_pointer_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_warp_pointer_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_warp_pointer_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_warp_pointer_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_warp_pointer_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_warp_pointer_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_warp_pointer_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_warp_pointer_request_t ) ) .
                src_window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_warp_pointer_request_t ) , "::" , stringify ! ( src_window
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_warp_pointer_request_t ) ) .
                dst_window as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_warp_pointer_request_t ) , "::" , stringify ! ( dst_window
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_warp_pointer_request_t ) ) . src_x as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_warp_pointer_request_t ) , "::" , stringify ! ( src_x )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_warp_pointer_request_t ) ) . src_y as
                * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_warp_pointer_request_t ) , "::" , stringify ! ( src_y )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_warp_pointer_request_t ) ) .
                src_width as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_warp_pointer_request_t ) , "::" , stringify ! ( src_width
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_warp_pointer_request_t ) ) .
                src_height as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_warp_pointer_request_t ) , "::" , stringify ! ( src_height
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_warp_pointer_request_t ) ) . dst_x as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_warp_pointer_request_t ) , "::" , stringify ! ( dst_x )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_warp_pointer_request_t ) ) . dst_y as
                * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_warp_pointer_request_t ) , "::" , stringify ! ( dst_y )
                ));
}
impl Clone for xcb_warp_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_input_focus_t {
    XCB_INPUT_FOCUS_NONE = 0,
    XCB_INPUT_FOCUS_POINTER_ROOT = 1,
    XCB_INPUT_FOCUS_PARENT = 2,
    XCB_INPUT_FOCUS_FOLLOW_KEYBOARD = 3,
}
/**
 * @brief xcb_set_input_focus_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_input_focus_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub revert_to: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub focus: xcb_window_t,
    /**<  */
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_input_focus_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_input_focus_request_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_input_focus_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_set_input_focus_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_set_input_focus_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_input_focus_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_input_focus_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_input_focus_request_t ) ) .
                revert_to as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_input_focus_request_t ) , "::" , stringify ! (
                revert_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_input_focus_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_input_focus_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_input_focus_request_t ) ) . focus
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_input_focus_request_t ) , "::" , stringify ! ( focus )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_input_focus_request_t ) ) . time
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_input_focus_request_t ) , "::" , stringify ! ( time )
                ));
}
impl Clone for xcb_set_input_focus_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_input_focus_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_input_focus_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_input_focus_cookie_t>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_get_input_focus_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_input_focus_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_get_input_focus_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_input_focus_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_input_focus_cookie_t ) , "::" , stringify ! ( sequence
                ) ));
}
impl Clone for xcb_get_input_focus_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_input_focus_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_input_focus_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_input_focus_request_t>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_get_input_focus_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_input_focus_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_get_input_focus_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_input_focus_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_input_focus_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_input_focus_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_input_focus_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_input_focus_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_input_focus_request_t ) , "::" , stringify ! ( length
                ) ));
}
impl Clone for xcb_get_input_focus_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_input_focus_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_input_focus_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub revert_to: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub focus: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_input_focus_reply_t>() , 12usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_get_input_focus_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_input_focus_reply_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_get_input_focus_reply_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_input_focus_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_input_focus_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_input_focus_reply_t ) ) .
                revert_to as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_input_focus_reply_t ) , "::" , stringify ! ( revert_to
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_input_focus_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_input_focus_reply_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_input_focus_reply_t ) ) . length
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_input_focus_reply_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_input_focus_reply_t ) ) . focus
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_input_focus_reply_t ) , "::" , stringify ! ( focus )
                ));
}
impl Clone for xcb_get_input_focus_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_keymap_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_keymap_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_keymap_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_keymap_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_keymap_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_query_keymap_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_keymap_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_keymap_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_query_keymap_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_keymap_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_keymap_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_keymap_request_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_keymap_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_keymap_request_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_query_keymap_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_keymap_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_keymap_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_keymap_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_keymap_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_keymap_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_keymap_request_t ) , "::" , stringify ! ( length )
                ));
}
impl Clone for xcb_query_keymap_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_keymap_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_keymap_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub keys: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_keymap_reply_t>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_keymap_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_keymap_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_query_keymap_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_keymap_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_keymap_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_keymap_reply_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_keymap_reply_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_keymap_reply_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_keymap_reply_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_keymap_reply_t ) ) . length as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_keymap_reply_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_keymap_reply_t ) ) . keys as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_keymap_reply_t ) , "::" , stringify ! ( keys ) ));
}
impl Clone for xcb_query_keymap_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_open_font_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_open_font_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub fid: xcb_font_t,
    /**<  */
    pub name_len: u16,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_open_font_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_open_font_request_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_open_font_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_open_font_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_open_font_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_open_font_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_open_font_request_t
                ) , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_open_font_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_open_font_request_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_open_font_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_open_font_request_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_open_font_request_t ) ) . fid as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_open_font_request_t
                ) , "::" , stringify ! ( fid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_open_font_request_t ) ) . name_len as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_open_font_request_t
                ) , "::" , stringify ! ( name_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_open_font_request_t ) ) . pad1 as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_open_font_request_t
                ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_open_font_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_close_font_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_close_font_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub font: xcb_font_t,
}
#[test]
fn bindgen_test_layout_xcb_close_font_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_close_font_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_close_font_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_close_font_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_close_font_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_close_font_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_close_font_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_close_font_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_close_font_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_close_font_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_close_font_request_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_close_font_request_t ) ) . font as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_close_font_request_t ) , "::" , stringify ! ( font ) ));
}
impl Clone for xcb_close_font_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_font_draw_t {
    XCB_FONT_DRAW_LEFT_TO_RIGHT = 0,
    XCB_FONT_DRAW_RIGHT_TO_LEFT = 1,
}
/**
 * @brief xcb_fontprop_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fontprop_t {
    /**<  */
    pub name: xcb_atom_t,
    /**<  */
    pub value: u32,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_t() {
    assert_eq!(::std::mem::size_of::<xcb_fontprop_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( xcb_fontprop_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_fontprop_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_fontprop_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fontprop_t ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fontprop_t ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fontprop_t ) ) . value as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fontprop_t ) , "::"
                , stringify ! ( value ) ));
}
impl Clone for xcb_fontprop_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_fontprop_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fontprop_iterator_t {
    /**<  */
    pub data: *mut xcb_fontprop_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_fontprop_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_fontprop_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_fontprop_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_fontprop_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fontprop_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fontprop_iterator_t
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fontprop_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fontprop_iterator_t
                ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fontprop_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fontprop_iterator_t
                ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_fontprop_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_charinfo_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_charinfo_t {
    /**<  */
    pub left_side_bearing: i16,
    /**<  */
    pub right_side_bearing: i16,
    /**<  */
    pub character_width: i16,
    /**<  */
    pub ascent: i16,
    /**<  */
    pub descent: i16,
    /**<  */
    pub attributes: u16,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_t() {
    assert_eq!(::std::mem::size_of::<xcb_charinfo_t>() , 12usize , concat ! (
               "Size of: " , stringify ! ( xcb_charinfo_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_charinfo_t>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_charinfo_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_charinfo_t ) ) . left_side_bearing as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_charinfo_t ) , "::"
                , stringify ! ( left_side_bearing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_charinfo_t ) ) . right_side_bearing
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_charinfo_t ) , "::"
                , stringify ! ( right_side_bearing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_charinfo_t ) ) . character_width as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_charinfo_t ) , "::"
                , stringify ! ( character_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_charinfo_t ) ) . ascent as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_charinfo_t ) , "::"
                , stringify ! ( ascent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_charinfo_t ) ) . descent as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_charinfo_t ) , "::"
                , stringify ! ( descent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_charinfo_t ) ) . attributes as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_charinfo_t ) , "::"
                , stringify ! ( attributes ) ));
}
impl Clone for xcb_charinfo_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_charinfo_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_charinfo_iterator_t {
    /**<  */
    pub data: *mut xcb_charinfo_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_charinfo_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_charinfo_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_charinfo_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_charinfo_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_charinfo_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_charinfo_iterator_t
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_charinfo_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_charinfo_iterator_t
                ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_charinfo_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_charinfo_iterator_t
                ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_charinfo_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_font_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_font_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_font_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_font_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_font_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_font_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_query_font_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_cookie_t ) ) . sequence as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_cookie_t
                ) , "::" , stringify ! ( sequence ) ));
}
impl Clone for xcb_query_font_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_font_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_font_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_font_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_font_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_font_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_font_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_query_font_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_font_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_font_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_font_request_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_request_t ) ) . font as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_font_request_t ) , "::" , stringify ! ( font ) ));
}
impl Clone for xcb_query_font_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_font_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_font_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub min_bounds: xcb_charinfo_t,
    /**<  */
    pub pad1: [u8; 4usize],
    /**<  */
    pub max_bounds: xcb_charinfo_t,
    /**<  */
    pub pad2: [u8; 4usize],
    /**<  */
    pub min_char_or_byte2: u16,
    /**<  */
    pub max_char_or_byte2: u16,
    /**<  */
    pub default_char: u16,
    /**<  */
    pub properties_len: u16,
    /**<  */
    pub draw_direction: u8,
    /**<  */
    pub min_byte1: u8,
    /**<  */
    pub max_byte1: u8,
    /**<  */
    pub all_chars_exist: u8,
    /**<  */
    pub font_ascent: i16,
    /**<  */
    pub font_descent: i16,
    /**<  */
    pub char_infos_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_query_font_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_font_reply_t>() , 60usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_query_font_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_query_font_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_query_font_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . sequence as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . min_bounds
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( min_bounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . pad1 as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . max_bounds
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( max_bounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . pad2 as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) .
                min_char_or_byte2 as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( min_char_or_byte2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) .
                max_char_or_byte2 as * const _ as usize } , 42usize , concat !
                (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( max_char_or_byte2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . default_char
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( default_char ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) .
                properties_len as * const _ as usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( properties_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) .
                draw_direction as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( draw_direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . min_byte1 as
                * const _ as usize } , 49usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( min_byte1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . max_byte1 as
                * const _ as usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( max_byte1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) .
                all_chars_exist as * const _ as usize } , 51usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( all_chars_exist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . font_ascent
                as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( font_ascent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) . font_descent
                as * const _ as usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( font_descent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_font_reply_t ) ) .
                char_infos_len as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_query_font_reply_t
                ) , "::" , stringify ! ( char_infos_len ) ));
}
impl Clone for xcb_query_font_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_text_extents_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_text_extents_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_text_extents_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_query_text_extents_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_query_text_extents_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_query_text_extents_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_query_text_extents_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_text_extents_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_text_extents_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub odd_length: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_text_extents_request_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( xcb_query_text_extents_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_query_text_extents_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_query_text_extents_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_request_t ) ) .
                odd_length as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_request_t ) , "::" , stringify ! (
                odd_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_request_t ) ) .
                font as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_request_t ) , "::" , stringify ! ( font
                ) ));
}
impl Clone for xcb_query_text_extents_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_text_extents_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_text_extents_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub draw_direction: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub font_ascent: i16,
    /**<  */
    pub font_descent: i16,
    /**<  */
    pub overall_ascent: i16,
    /**<  */
    pub overall_descent: i16,
    /**<  */
    pub overall_width: i32,
    /**<  */
    pub overall_left: i32,
    /**<  */
    pub overall_right: i32,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_text_extents_reply_t>() ,
               28usize , concat ! (
               "Size of: " , stringify ! ( xcb_query_text_extents_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_query_text_extents_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_query_text_extents_reply_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_reply_t ) ) .
                draw_direction as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_reply_t ) , "::" , stringify ! (
                draw_direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_reply_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_reply_t ) ) .
                font_ascent as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_reply_t ) , "::" , stringify ! (
                font_ascent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_reply_t ) ) .
                font_descent as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_reply_t ) , "::" , stringify ! (
                font_descent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_reply_t ) ) .
                overall_ascent as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_reply_t ) , "::" , stringify ! (
                overall_ascent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_reply_t ) ) .
                overall_descent as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_reply_t ) , "::" , stringify ! (
                overall_descent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_reply_t ) ) .
                overall_width as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_reply_t ) , "::" , stringify ! (
                overall_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_reply_t ) ) .
                overall_left as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_reply_t ) , "::" , stringify ! (
                overall_left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_text_extents_reply_t ) ) .
                overall_right as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_text_extents_reply_t ) , "::" , stringify ! (
                overall_right ) ));
}
impl Clone for xcb_query_text_extents_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_str_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_str_t {
    /**<  */
    pub name_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_str_t() {
    assert_eq!(::std::mem::size_of::<xcb_str_t>() , 1usize , concat ! (
               "Size of: " , stringify ! ( xcb_str_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_str_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( xcb_str_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_str_t ) ) . name_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_str_t ) , "::" ,
                stringify ! ( name_len ) ));
}
impl Clone for xcb_str_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_str_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_str_iterator_t {
    /**<  */
    pub data: *mut xcb_str_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_str_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_str_iterator_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( xcb_str_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_str_iterator_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( xcb_str_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_str_iterator_t ) ) . data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_str_iterator_t ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_str_iterator_t ) ) . rem as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_str_iterator_t ) ,
                "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_str_iterator_t ) ) . index as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_str_iterator_t ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for xcb_str_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_fonts_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_list_fonts_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_fonts_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_list_fonts_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_cookie_t ) ) . sequence as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_fonts_cookie_t
                ) , "::" , stringify ! ( sequence ) ));
}
impl Clone for xcb_list_fonts_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_fonts_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub max_names: u16,
    /**<  */
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_list_fonts_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_fonts_request_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_list_fonts_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_request_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_request_t ) ) . max_names
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_request_t ) , "::" , stringify ! ( max_names )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_request_t ) ) .
                pattern_len as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_request_t ) , "::" , stringify ! ( pattern_len
                ) ));
}
impl Clone for xcb_list_fonts_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_fonts_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub names_len: u16,
    /**<  */
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_reply_t>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_list_fonts_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_list_fonts_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_list_fonts_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_fonts_reply_t
                ) , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_reply_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_fonts_reply_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_reply_t ) ) . sequence as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_fonts_reply_t
                ) , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_reply_t ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_fonts_reply_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_reply_t ) ) . names_len as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_fonts_reply_t
                ) , "::" , stringify ! ( names_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_reply_t ) ) . pad1 as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_fonts_reply_t
                ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_list_fonts_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_fonts_with_info_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_with_info_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_with_info_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_list_fonts_with_info_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_list_fonts_with_info_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_list_fonts_with_info_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_list_fonts_with_info_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_fonts_with_info_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_with_info_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub max_names: u16,
    /**<  */
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_with_info_request_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( xcb_list_fonts_with_info_request_t
               ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_fonts_with_info_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_list_fonts_with_info_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_request_t ) ) .
                max_names as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_request_t ) , "::" , stringify ! (
                max_names ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_request_t ) ) .
                pattern_len as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_request_t ) , "::" , stringify ! (
                pattern_len ) ));
}
impl Clone for xcb_list_fonts_with_info_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_fonts_with_info_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_with_info_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub name_len: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub min_bounds: xcb_charinfo_t,
    /**<  */
    pub pad0: [u8; 4usize],
    /**<  */
    pub max_bounds: xcb_charinfo_t,
    /**<  */
    pub pad1: [u8; 4usize],
    /**<  */
    pub min_char_or_byte2: u16,
    /**<  */
    pub max_char_or_byte2: u16,
    /**<  */
    pub default_char: u16,
    /**<  */
    pub properties_len: u16,
    /**<  */
    pub draw_direction: u8,
    /**<  */
    pub min_byte1: u8,
    /**<  */
    pub max_byte1: u8,
    /**<  */
    pub all_chars_exist: u8,
    /**<  */
    pub font_ascent: i16,
    /**<  */
    pub font_descent: i16,
    /**<  */
    pub replies_hint: u32,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_with_info_reply_t>() ,
               60usize , concat ! (
               "Size of: " , stringify ! ( xcb_list_fonts_with_info_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_list_fonts_with_info_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                name_len as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                name_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                min_bounds as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                min_bounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                pad0 as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! ( pad0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                max_bounds as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                max_bounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                pad1 as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! ( pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                min_char_or_byte2 as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                min_char_or_byte2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                max_char_or_byte2 as * const _ as usize } , 42usize , concat !
                (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                max_char_or_byte2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                default_char as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                default_char ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                properties_len as * const _ as usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                properties_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                draw_direction as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                draw_direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                min_byte1 as * const _ as usize } , 49usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                min_byte1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                max_byte1 as * const _ as usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                max_byte1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                all_chars_exist as * const _ as usize } , 51usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                all_chars_exist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                font_ascent as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                font_ascent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                font_descent as * const _ as usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                font_descent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_fonts_with_info_reply_t ) ) .
                replies_hint as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_fonts_with_info_reply_t ) , "::" , stringify ! (
                replies_hint ) ));
}
impl Clone for xcb_list_fonts_with_info_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_set_font_path_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_font_path_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub font_qty: u16,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_set_font_path_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_font_path_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_set_font_path_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_set_font_path_request_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_set_font_path_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_font_path_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_font_path_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_font_path_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_font_path_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_font_path_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_font_path_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_font_path_request_t ) ) .
                font_qty as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_font_path_request_t ) , "::" , stringify ! ( font_qty
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_font_path_request_t ) ) . pad1 as
                * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_font_path_request_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_set_font_path_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_font_path_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_font_path_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_font_path_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_font_path_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_font_path_cookie_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_get_font_path_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_font_path_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_font_path_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_get_font_path_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_font_path_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_font_path_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_font_path_request_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_font_path_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_font_path_request_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_get_font_path_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_font_path_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_font_path_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_font_path_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_font_path_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_font_path_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_font_path_request_t ) , "::" , stringify ! ( length )
                ));
}
impl Clone for xcb_get_font_path_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_font_path_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_font_path_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub path_len: u16,
    /**<  */
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_font_path_reply_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_font_path_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_font_path_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_get_font_path_reply_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_font_path_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_font_path_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_font_path_reply_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_font_path_reply_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_font_path_reply_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_font_path_reply_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_font_path_reply_t ) ) . length as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_font_path_reply_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_font_path_reply_t ) ) . path_len
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_font_path_reply_t ) , "::" , stringify ! ( path_len )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_font_path_reply_t ) ) . pad1 as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_font_path_reply_t ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_get_font_path_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_create_pixmap_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_pixmap_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub depth: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub pid: xcb_pixmap_t,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_pixmap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_pixmap_request_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_create_pixmap_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_create_pixmap_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_create_pixmap_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_pixmap_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_pixmap_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_pixmap_request_t ) ) . depth
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_pixmap_request_t ) , "::" , stringify ! ( depth )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_pixmap_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_pixmap_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_pixmap_request_t ) ) . pid as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_pixmap_request_t ) , "::" , stringify ! ( pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_pixmap_request_t ) ) .
                drawable as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_pixmap_request_t ) , "::" , stringify ! ( drawable
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_pixmap_request_t ) ) . width
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_pixmap_request_t ) , "::" , stringify ! ( width )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_pixmap_request_t ) ) . height
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_pixmap_request_t ) , "::" , stringify ! ( height )
                ));
}
impl Clone for xcb_create_pixmap_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_free_pixmap_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_pixmap_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub pixmap: xcb_pixmap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_pixmap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_pixmap_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_free_pixmap_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_free_pixmap_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_free_pixmap_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_pixmap_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_pixmap_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_pixmap_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_pixmap_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_pixmap_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_pixmap_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_pixmap_request_t ) ) . pixmap as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_pixmap_request_t ) , "::" , stringify ! ( pixmap )
                ));
}
impl Clone for xcb_free_pixmap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_gc_t {
    XCB_GC_FUNCTION = 1,
    XCB_GC_PLANE_MASK = 2,
    XCB_GC_FOREGROUND = 4,
    XCB_GC_BACKGROUND = 8,
    XCB_GC_LINE_WIDTH = 16,
    XCB_GC_LINE_STYLE = 32,
    XCB_GC_CAP_STYLE = 64,
    XCB_GC_JOIN_STYLE = 128,
    XCB_GC_FILL_STYLE = 256,
    XCB_GC_FILL_RULE = 512,
    XCB_GC_TILE = 1024,
    XCB_GC_STIPPLE = 2048,
    XCB_GC_TILE_STIPPLE_ORIGIN_X = 4096,
    XCB_GC_TILE_STIPPLE_ORIGIN_Y = 8192,
    XCB_GC_FONT = 16384,
    XCB_GC_SUBWINDOW_MODE = 32768,
    XCB_GC_GRAPHICS_EXPOSURES = 65536,
    XCB_GC_CLIP_ORIGIN_X = 131072,
    XCB_GC_CLIP_ORIGIN_Y = 262144,
    XCB_GC_CLIP_MASK = 524288,
    XCB_GC_DASH_OFFSET = 1048576,
    XCB_GC_DASH_LIST = 2097152,
    XCB_GC_ARC_MODE = 4194304,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_gx_t {
    XCB_GX_CLEAR = 0,
    XCB_GX_AND = 1,
    XCB_GX_AND_REVERSE = 2,
    XCB_GX_COPY = 3,
    XCB_GX_AND_INVERTED = 4,
    XCB_GX_NOOP = 5,
    XCB_GX_XOR = 6,
    XCB_GX_OR = 7,
    XCB_GX_NOR = 8,
    XCB_GX_EQUIV = 9,
    XCB_GX_INVERT = 10,
    XCB_GX_OR_REVERSE = 11,
    XCB_GX_COPY_INVERTED = 12,
    XCB_GX_OR_INVERTED = 13,
    XCB_GX_NAND = 14,
    XCB_GX_SET = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_line_style_t {
    XCB_LINE_STYLE_SOLID = 0,
    XCB_LINE_STYLE_ON_OFF_DASH = 1,
    XCB_LINE_STYLE_DOUBLE_DASH = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_cap_style_t {
    XCB_CAP_STYLE_NOT_LAST = 0,
    XCB_CAP_STYLE_BUTT = 1,
    XCB_CAP_STYLE_ROUND = 2,
    XCB_CAP_STYLE_PROJECTING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_join_style_t {
    XCB_JOIN_STYLE_MITER = 0,
    XCB_JOIN_STYLE_ROUND = 1,
    XCB_JOIN_STYLE_BEVEL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_fill_style_t {
    XCB_FILL_STYLE_SOLID = 0,
    XCB_FILL_STYLE_TILED = 1,
    XCB_FILL_STYLE_STIPPLED = 2,
    XCB_FILL_STYLE_OPAQUE_STIPPLED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_fill_rule_t {
    XCB_FILL_RULE_EVEN_ODD = 0,
    XCB_FILL_RULE_WINDING = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_subwindow_mode_t {
    XCB_SUBWINDOW_MODE_CLIP_BY_CHILDREN = 0,
    XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_arc_mode_t {
    XCB_ARC_MODE_CHORD = 0,
    XCB_ARC_MODE_PIE_SLICE = 1,
}
/**
 * @brief xcb_create_gc_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_gc_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cid: xcb_gcontext_t,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_gc_request_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_create_gc_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_create_gc_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_create_gc_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_gc_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_create_gc_request_t
                ) , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_gc_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_create_gc_request_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_gc_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_create_gc_request_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_gc_request_t ) ) . cid as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_create_gc_request_t
                ) , "::" , stringify ! ( cid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_gc_request_t ) ) . drawable as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_create_gc_request_t
                ) , "::" , stringify ! ( drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_gc_request_t ) ) . value_mask
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_create_gc_request_t
                ) , "::" , stringify ! ( value_mask ) ));
}
impl Clone for xcb_create_gc_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_change_gc_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_gc_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub gc: xcb_gcontext_t,
    /**<  */
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_gc_request_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_change_gc_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_change_gc_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_change_gc_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_gc_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_change_gc_request_t
                ) , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_gc_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_change_gc_request_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_gc_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_change_gc_request_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_gc_request_t ) ) . gc as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_change_gc_request_t
                ) , "::" , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_gc_request_t ) ) . value_mask
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_change_gc_request_t
                ) , "::" , stringify ! ( value_mask ) ));
}
impl Clone for xcb_change_gc_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_copy_gc_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_gc_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub src_gc: xcb_gcontext_t,
    /**<  */
    pub dst_gc: xcb_gcontext_t,
    /**<  */
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_gc_request_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_copy_gc_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_copy_gc_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_copy_gc_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_gc_request_t ) ) . major_opcode
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_gc_request_t )
                , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_gc_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_gc_request_t )
                , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_gc_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_gc_request_t )
                , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_gc_request_t ) ) . src_gc as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_gc_request_t )
                , "::" , stringify ! ( src_gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_gc_request_t ) ) . dst_gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_gc_request_t )
                , "::" , stringify ! ( dst_gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_gc_request_t ) ) . value_mask as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_gc_request_t )
                , "::" , stringify ! ( value_mask ) ));
}
impl Clone for xcb_copy_gc_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_set_dashes_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_dashes_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub gc: xcb_gcontext_t,
    /**<  */
    pub dash_offset: u16,
    /**<  */
    pub dashes_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_dashes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_dashes_request_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_set_dashes_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_set_dashes_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_set_dashes_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_dashes_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_dashes_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_dashes_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_dashes_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_dashes_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_dashes_request_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_dashes_request_t ) ) . gc as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_dashes_request_t ) , "::" , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_dashes_request_t ) ) .
                dash_offset as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_dashes_request_t ) , "::" , stringify ! ( dash_offset
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_dashes_request_t ) ) . dashes_len
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_dashes_request_t ) , "::" , stringify ! ( dashes_len )
                ));
}
impl Clone for xcb_set_dashes_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_clip_ordering_t {
    XCB_CLIP_ORDERING_UNSORTED = 0,
    XCB_CLIP_ORDERING_Y_SORTED = 1,
    XCB_CLIP_ORDERING_YX_SORTED = 2,
    XCB_CLIP_ORDERING_YX_BANDED = 3,
}
/**
 * @brief xcb_set_clip_rectangles_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_clip_rectangles_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub ordering: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub gc: xcb_gcontext_t,
    /**<  */
    pub clip_x_origin: i16,
    /**<  */
    pub clip_y_origin: i16,
}
#[test]
fn bindgen_test_layout_xcb_set_clip_rectangles_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_clip_rectangles_request_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_clip_rectangles_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_set_clip_rectangles_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_set_clip_rectangles_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_clip_rectangles_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_clip_rectangles_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_clip_rectangles_request_t ) ) .
                ordering as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_clip_rectangles_request_t ) , "::" , stringify ! (
                ordering ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_clip_rectangles_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_clip_rectangles_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_clip_rectangles_request_t ) ) .
                gc as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_clip_rectangles_request_t ) , "::" , stringify ! ( gc
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_clip_rectangles_request_t ) ) .
                clip_x_origin as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_clip_rectangles_request_t ) , "::" , stringify ! (
                clip_x_origin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_clip_rectangles_request_t ) ) .
                clip_y_origin as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_clip_rectangles_request_t ) , "::" , stringify ! (
                clip_y_origin ) ));
}
impl Clone for xcb_set_clip_rectangles_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_free_gc_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_gc_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_free_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_gc_request_t>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_free_gc_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_free_gc_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_free_gc_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_gc_request_t ) ) . major_opcode
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_free_gc_request_t )
                , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_gc_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_free_gc_request_t )
                , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_gc_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_free_gc_request_t )
                , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_gc_request_t ) ) . gc as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_free_gc_request_t )
                , "::" , stringify ! ( gc ) ));
}
impl Clone for xcb_free_gc_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_clear_area_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_clear_area_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub exposures: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_clear_area_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_clear_area_request_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_clear_area_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_clear_area_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_clear_area_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_clear_area_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_clear_area_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_clear_area_request_t ) ) . exposures
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_clear_area_request_t ) , "::" , stringify ! ( exposures )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_clear_area_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_clear_area_request_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_clear_area_request_t ) ) . window as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_clear_area_request_t ) , "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_clear_area_request_t ) ) . x as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_clear_area_request_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_clear_area_request_t ) ) . y as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_clear_area_request_t ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_clear_area_request_t ) ) . width as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_clear_area_request_t ) , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_clear_area_request_t ) ) . height as
                * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_clear_area_request_t ) , "::" , stringify ! ( height ) ));
}
impl Clone for xcb_clear_area_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_copy_area_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_area_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub src_drawable: xcb_drawable_t,
    /**<  */
    pub dst_drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
    /**<  */
    pub src_x: i16,
    /**<  */
    pub src_y: i16,
    /**<  */
    pub dst_x: i16,
    /**<  */
    pub dst_y: i16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_copy_area_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_area_request_t>() , 28usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_copy_area_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_copy_area_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_copy_area_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) .
                src_drawable as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( src_drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) .
                dst_drawable as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( dst_drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) . gc as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) . src_x as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( src_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) . src_y as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( src_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) . dst_x as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( dst_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) . dst_y as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( dst_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) . width as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_area_request_t ) ) . height as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_copy_area_request_t
                ) , "::" , stringify ! ( height ) ));
}
impl Clone for xcb_copy_area_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_copy_plane_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_plane_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub src_drawable: xcb_drawable_t,
    /**<  */
    pub dst_drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
    /**<  */
    pub src_x: i16,
    /**<  */
    pub src_y: i16,
    /**<  */
    pub dst_x: i16,
    /**<  */
    pub dst_y: i16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
    /**<  */
    pub bit_plane: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_plane_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_plane_request_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_copy_plane_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_copy_plane_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_copy_plane_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) .
                src_drawable as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( src_drawable
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) .
                dst_drawable as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( dst_drawable
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) . gc as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) . src_x as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( src_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) . src_y as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( src_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) . dst_x as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( dst_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) . dst_y as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( dst_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) . width as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) . height as
                * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_plane_request_t ) ) . bit_plane
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_plane_request_t ) , "::" , stringify ! ( bit_plane )
                ));
}
impl Clone for xcb_copy_plane_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_coord_mode_t {
    XCB_COORD_MODE_ORIGIN = 0,
    XCB_COORD_MODE_PREVIOUS = 1,
}
/**
 * @brief xcb_poly_point_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_point_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub coordinate_mode: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_point_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_point_request_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_poly_point_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_poly_point_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_poly_point_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_point_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_point_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_point_request_t ) ) .
                coordinate_mode as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_point_request_t ) , "::" , stringify ! (
                coordinate_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_point_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_point_request_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_point_request_t ) ) . drawable
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_point_request_t ) , "::" , stringify ! ( drawable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_point_request_t ) ) . gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_point_request_t ) , "::" , stringify ! ( gc ) ));
}
impl Clone for xcb_poly_point_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_poly_line_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_line_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub coordinate_mode: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_line_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_line_request_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_poly_line_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_poly_line_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_poly_line_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_line_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_poly_line_request_t
                ) , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_line_request_t ) ) .
                coordinate_mode as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_poly_line_request_t
                ) , "::" , stringify ! ( coordinate_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_line_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_poly_line_request_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_line_request_t ) ) . drawable as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_poly_line_request_t
                ) , "::" , stringify ! ( drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_line_request_t ) ) . gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_poly_line_request_t
                ) , "::" , stringify ! ( gc ) ));
}
impl Clone for xcb_poly_line_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_segment_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_segment_t {
    /**<  */
    pub x1: i16,
    /**<  */
    pub y1: i16,
    /**<  */
    pub x2: i16,
    /**<  */
    pub y2: i16,
}
#[test]
fn bindgen_test_layout_xcb_segment_t() {
    assert_eq!(::std::mem::size_of::<xcb_segment_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( xcb_segment_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_segment_t>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_segment_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_segment_t ) ) . x1 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_segment_t ) , "::"
                , stringify ! ( x1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_segment_t ) ) . y1 as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_segment_t ) , "::"
                , stringify ! ( y1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_segment_t ) ) . x2 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_segment_t ) , "::"
                , stringify ! ( x2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_segment_t ) ) . y2 as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_segment_t ) , "::"
                , stringify ! ( y2 ) ));
}
impl Clone for xcb_segment_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_segment_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_segment_iterator_t {
    /**<  */
    pub data: *mut xcb_segment_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_segment_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_segment_iterator_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_segment_iterator_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_segment_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_segment_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_segment_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_segment_iterator_t
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_segment_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_segment_iterator_t
                ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_segment_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_segment_iterator_t
                ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_segment_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_poly_segment_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_segment_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_segment_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_segment_request_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_poly_segment_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_poly_segment_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_poly_segment_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_segment_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_segment_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_segment_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_segment_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_segment_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_segment_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_segment_request_t ) ) . drawable
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_segment_request_t ) , "::" , stringify ! ( drawable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_segment_request_t ) ) . gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_segment_request_t ) , "::" , stringify ! ( gc ) ));
}
impl Clone for xcb_poly_segment_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_poly_rectangle_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_rectangle_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_rectangle_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_rectangle_request_t>() , 12usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_poly_rectangle_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_poly_rectangle_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_poly_rectangle_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_rectangle_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_rectangle_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_rectangle_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_rectangle_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_rectangle_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_rectangle_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_rectangle_request_t ) ) .
                drawable as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_rectangle_request_t ) , "::" , stringify ! ( drawable
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_rectangle_request_t ) ) . gc as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_rectangle_request_t ) , "::" , stringify ! ( gc ) ));
}
impl Clone for xcb_poly_rectangle_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_poly_arc_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_arc_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_arc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_arc_request_t>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_poly_arc_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_poly_arc_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_poly_arc_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_arc_request_t ) ) . major_opcode
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_poly_arc_request_t
                ) , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_arc_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_poly_arc_request_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_arc_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_poly_arc_request_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_arc_request_t ) ) . drawable as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_poly_arc_request_t
                ) , "::" , stringify ! ( drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_arc_request_t ) ) . gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_poly_arc_request_t
                ) , "::" , stringify ! ( gc ) ));
}
impl Clone for xcb_poly_arc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_poly_shape_t {
    XCB_POLY_SHAPE_COMPLEX = 0,
    XCB_POLY_SHAPE_NONCONVEX = 1,
    XCB_POLY_SHAPE_CONVEX = 2,
}
/**
 * @brief xcb_fill_poly_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fill_poly_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
    /**<  */
    pub shape: u8,
    /**<  */
    pub coordinate_mode: u8,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_fill_poly_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_fill_poly_request_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_fill_poly_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_fill_poly_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_fill_poly_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fill_poly_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fill_poly_request_t
                ) , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fill_poly_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fill_poly_request_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fill_poly_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fill_poly_request_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fill_poly_request_t ) ) . drawable as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fill_poly_request_t
                ) , "::" , stringify ! ( drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fill_poly_request_t ) ) . gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fill_poly_request_t
                ) , "::" , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fill_poly_request_t ) ) . shape as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fill_poly_request_t
                ) , "::" , stringify ! ( shape ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fill_poly_request_t ) ) .
                coordinate_mode as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fill_poly_request_t
                ) , "::" , stringify ! ( coordinate_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_fill_poly_request_t ) ) . pad1 as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_fill_poly_request_t
                ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_fill_poly_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_poly_fill_rectangle_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_fill_rectangle_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_rectangle_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_fill_rectangle_request_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( xcb_poly_fill_rectangle_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_poly_fill_rectangle_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_poly_fill_rectangle_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_fill_rectangle_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_fill_rectangle_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_fill_rectangle_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_fill_rectangle_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_fill_rectangle_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_fill_rectangle_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_fill_rectangle_request_t ) ) .
                drawable as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_fill_rectangle_request_t ) , "::" , stringify ! (
                drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_fill_rectangle_request_t ) ) .
                gc as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_fill_rectangle_request_t ) , "::" , stringify ! ( gc
                ) ));
}
impl Clone for xcb_poly_fill_rectangle_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_poly_fill_arc_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_fill_arc_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_arc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_fill_arc_request_t>() , 12usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_poly_fill_arc_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_poly_fill_arc_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_poly_fill_arc_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_fill_arc_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_fill_arc_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_fill_arc_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_fill_arc_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_fill_arc_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_fill_arc_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_fill_arc_request_t ) ) .
                drawable as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_fill_arc_request_t ) , "::" , stringify ! ( drawable
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_fill_arc_request_t ) ) . gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_fill_arc_request_t ) , "::" , stringify ! ( gc ) ));
}
impl Clone for xcb_poly_fill_arc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_image_format_t {
    XCB_IMAGE_FORMAT_XY_BITMAP = 0,
    XCB_IMAGE_FORMAT_XY_PIXMAP = 1,
    XCB_IMAGE_FORMAT_Z_PIXMAP = 2,
}
/**
 * @brief xcb_put_image_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_put_image_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub format: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
    /**<  */
    pub dst_x: i16,
    /**<  */
    pub dst_y: i16,
    /**<  */
    pub left_pad: u8,
    /**<  */
    pub depth: u8,
    /**<  */
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_put_image_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_put_image_request_t>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_put_image_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_put_image_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_put_image_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) . format as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) . drawable as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) . gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) . width as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) . height as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) . dst_x as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( dst_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) . dst_y as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( dst_y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) . left_pad as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( left_pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) . depth as *
                const _ as usize } , 21usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_put_image_request_t ) ) . pad0 as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_put_image_request_t
                ) , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_put_image_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_image_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_image_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_image_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_image_cookie_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_get_image_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_image_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_get_image_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_cookie_t ) ) . sequence as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_cookie_t
                ) , "::" , stringify ! ( sequence ) ));
}
impl Clone for xcb_get_image_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_image_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_image_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub format: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
    /**<  */
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_image_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_image_request_t>() , 20usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_get_image_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_image_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_get_image_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_request_t
                ) , "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_request_t ) ) . format as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_request_t
                ) , "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_request_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_request_t ) ) . drawable as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_request_t
                ) , "::" , stringify ! ( drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_request_t ) ) . x as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_request_t
                ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_request_t ) ) . y as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_request_t
                ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_request_t ) ) . width as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_request_t
                ) , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_request_t ) ) . height as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_request_t
                ) , "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_request_t ) ) . plane_mask
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_request_t
                ) , "::" , stringify ! ( plane_mask ) ));
}
impl Clone for xcb_get_image_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_image_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_image_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub depth: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub visual: xcb_visualid_t,
    /**<  */
    pub pad0: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_image_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_image_reply_t>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_get_image_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_image_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_get_image_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_reply_t ) ) . response_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_reply_t )
                , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_reply_t ) ) . depth as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_reply_t )
                , "::" , stringify ! ( depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_reply_t ) ) . sequence as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_reply_t )
                , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_reply_t ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_reply_t )
                , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_reply_t ) ) . visual as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_reply_t )
                , "::" , stringify ! ( visual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_image_reply_t ) ) . pad0 as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_get_image_reply_t )
                , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_get_image_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_poly_text_8_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_text_8_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_8_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_text_8_request_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_poly_text_8_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_poly_text_8_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_poly_text_8_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_8_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_8_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_8_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_8_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_8_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_8_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_8_request_t ) ) . drawable
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_8_request_t ) , "::" , stringify ! ( drawable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_8_request_t ) ) . gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_8_request_t ) , "::" , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_8_request_t ) ) . x as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_8_request_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_8_request_t ) ) . y as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_8_request_t ) , "::" , stringify ! ( y ) ));
}
impl Clone for xcb_poly_text_8_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_poly_text_16_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_text_16_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_16_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_text_16_request_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_poly_text_16_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_poly_text_16_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_poly_text_16_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_16_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_16_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_16_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_16_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_16_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_16_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_16_request_t ) ) . drawable
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_16_request_t ) , "::" , stringify ! ( drawable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_16_request_t ) ) . gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_16_request_t ) , "::" , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_16_request_t ) ) . x as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_16_request_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_poly_text_16_request_t ) ) . y as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_poly_text_16_request_t ) , "::" , stringify ! ( y ) ));
}
impl Clone for xcb_poly_text_16_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_image_text_8_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_image_text_8_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub string_len: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_8_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_image_text_8_request_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_image_text_8_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_image_text_8_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_image_text_8_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_8_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_8_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_8_request_t ) ) .
                string_len as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_8_request_t ) , "::" , stringify ! ( string_len
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_8_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_8_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_8_request_t ) ) . drawable
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_8_request_t ) , "::" , stringify ! ( drawable )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_8_request_t ) ) . gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_8_request_t ) , "::" , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_8_request_t ) ) . x as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_8_request_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_8_request_t ) ) . y as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_8_request_t ) , "::" , stringify ! ( y ) ));
}
impl Clone for xcb_image_text_8_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_image_text_16_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_image_text_16_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub string_len: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub gc: xcb_gcontext_t,
    /**<  */
    pub x: i16,
    /**<  */
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_16_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_image_text_16_request_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_image_text_16_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_image_text_16_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_image_text_16_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_16_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_16_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_16_request_t ) ) .
                string_len as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_16_request_t ) , "::" , stringify ! (
                string_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_16_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_16_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_16_request_t ) ) .
                drawable as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_16_request_t ) , "::" , stringify ! ( drawable
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_16_request_t ) ) . gc as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_16_request_t ) , "::" , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_16_request_t ) ) . x as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_16_request_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_image_text_16_request_t ) ) . y as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_image_text_16_request_t ) , "::" , stringify ! ( y ) ));
}
impl Clone for xcb_image_text_16_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_colormap_alloc_t {
    XCB_COLORMAP_ALLOC_NONE = 0,
    XCB_COLORMAP_ALLOC_ALL = 1,
}
/**
 * @brief xcb_create_colormap_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_colormap_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub alloc: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub mid: xcb_colormap_t,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub visual: xcb_visualid_t,
}
#[test]
fn bindgen_test_layout_xcb_create_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_colormap_request_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( xcb_create_colormap_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_create_colormap_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_create_colormap_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_colormap_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_colormap_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_colormap_request_t ) ) . alloc
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_colormap_request_t ) , "::" , stringify ! ( alloc )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_colormap_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_colormap_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_colormap_request_t ) ) . mid
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_colormap_request_t ) , "::" , stringify ! ( mid )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_colormap_request_t ) ) .
                window as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_colormap_request_t ) , "::" , stringify ! ( window
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_colormap_request_t ) ) .
                visual as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_colormap_request_t ) , "::" , stringify ! ( visual
                ) ));
}
impl Clone for xcb_create_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_free_colormap_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_colormap_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_colormap_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_free_colormap_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_free_colormap_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_free_colormap_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_colormap_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_colormap_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_colormap_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_colormap_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_colormap_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_colormap_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_colormap_request_t ) ) . cmap as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_colormap_request_t ) , "::" , stringify ! ( cmap )
                ));
}
impl Clone for xcb_free_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_copy_colormap_and_free_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_colormap_and_free_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub mid: xcb_colormap_t,
    /**<  */
    pub src_cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_copy_colormap_and_free_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_colormap_and_free_request_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! (
               xcb_copy_colormap_and_free_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_copy_colormap_and_free_request_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_copy_colormap_and_free_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_colormap_and_free_request_t ) )
                . major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_colormap_and_free_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_colormap_and_free_request_t ) )
                . pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_colormap_and_free_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_colormap_and_free_request_t ) )
                . length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_colormap_and_free_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_colormap_and_free_request_t ) )
                . mid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_colormap_and_free_request_t ) , "::" , stringify ! (
                mid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_copy_colormap_and_free_request_t ) )
                . src_cmap as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_copy_colormap_and_free_request_t ) , "::" , stringify ! (
                src_cmap ) ));
}
impl Clone for xcb_copy_colormap_and_free_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_install_colormap_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_install_colormap_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_install_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_install_colormap_request_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( xcb_install_colormap_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_install_colormap_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_install_colormap_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_install_colormap_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_install_colormap_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_install_colormap_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_install_colormap_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_install_colormap_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_install_colormap_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_install_colormap_request_t ) ) . cmap
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_install_colormap_request_t ) , "::" , stringify ! ( cmap )
                ));
}
impl Clone for xcb_install_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_uninstall_colormap_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_uninstall_colormap_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_uninstall_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_uninstall_colormap_request_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( xcb_uninstall_colormap_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_uninstall_colormap_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_uninstall_colormap_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_uninstall_colormap_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_uninstall_colormap_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_uninstall_colormap_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_uninstall_colormap_request_t ) , "::" , stringify ! ( pad0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_uninstall_colormap_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_uninstall_colormap_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_uninstall_colormap_request_t ) ) .
                cmap as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_uninstall_colormap_request_t ) , "::" , stringify ! ( cmap
                ) ));
}
impl Clone for xcb_uninstall_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_installed_colormaps_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_installed_colormaps_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_installed_colormaps_cookie_t>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               xcb_list_installed_colormaps_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_installed_colormaps_cookie_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_list_installed_colormaps_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_installed_colormaps_cookie_t ) )
                . sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_installed_colormaps_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_list_installed_colormaps_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_installed_colormaps_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_installed_colormaps_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_installed_colormaps_request_t>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               xcb_list_installed_colormaps_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_installed_colormaps_request_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_list_installed_colormaps_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_installed_colormaps_request_t )
                ) . major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_installed_colormaps_request_t ) , "::" , stringify !
                ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_installed_colormaps_request_t )
                ) . pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_installed_colormaps_request_t ) , "::" , stringify !
                ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_installed_colormaps_request_t )
                ) . length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_installed_colormaps_request_t ) , "::" , stringify !
                ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_installed_colormaps_request_t )
                ) . window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_installed_colormaps_request_t ) , "::" , stringify !
                ( window ) ));
}
impl Clone for xcb_list_installed_colormaps_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_installed_colormaps_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_installed_colormaps_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub cmaps_len: u16,
    /**<  */
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_installed_colormaps_reply_t>() ,
               32usize , concat ! (
               "Size of: " , stringify ! (
               xcb_list_installed_colormaps_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_installed_colormaps_reply_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_list_installed_colormaps_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_installed_colormaps_reply_t ) )
                . response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_installed_colormaps_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_installed_colormaps_reply_t ) )
                . pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_installed_colormaps_reply_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_installed_colormaps_reply_t ) )
                . sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_installed_colormaps_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_installed_colormaps_reply_t ) )
                . length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_installed_colormaps_reply_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_installed_colormaps_reply_t ) )
                . cmaps_len as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_installed_colormaps_reply_t ) , "::" , stringify ! (
                cmaps_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_installed_colormaps_reply_t ) )
                . pad1 as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_installed_colormaps_reply_t ) , "::" , stringify ! (
                pad1 ) ));
}
impl Clone for xcb_list_installed_colormaps_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_color_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_alloc_color_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_color_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_alloc_color_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_alloc_color_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_color_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
    /**<  */
    pub red: u16,
    /**<  */
    pub green: u16,
    /**<  */
    pub blue: u16,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_request_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_alloc_color_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_color_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_alloc_color_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_request_t ) ) . cmap as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_request_t ) , "::" , stringify ! ( cmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_request_t ) ) . red as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_request_t ) , "::" , stringify ! ( red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_request_t ) ) . green as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_request_t ) , "::" , stringify ! ( green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_request_t ) ) . blue as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_request_t ) , "::" , stringify ! ( blue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_request_t ) ) . pad1 as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_request_t ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_alloc_color_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_color_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub red: u16,
    /**<  */
    pub green: u16,
    /**<  */
    pub blue: u16,
    /**<  */
    pub pad1: [u8; 2usize],
    /**<  */
    pub pixel: u32,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_reply_t>() , 20usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_alloc_color_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_color_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_alloc_color_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_alloc_color_reply_t
                ) , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_reply_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_alloc_color_reply_t
                ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_reply_t ) ) . sequence as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_alloc_color_reply_t
                ) , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_reply_t ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_alloc_color_reply_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_reply_t ) ) . red as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_alloc_color_reply_t
                ) , "::" , stringify ! ( red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_reply_t ) ) . green as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_alloc_color_reply_t
                ) , "::" , stringify ! ( green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_reply_t ) ) . blue as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_alloc_color_reply_t
                ) , "::" , stringify ! ( blue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_reply_t ) ) . pad1 as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_alloc_color_reply_t
                ) , "::" , stringify ! ( pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_reply_t ) ) . pixel as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_alloc_color_reply_t
                ) , "::" , stringify ! ( pixel ) ));
}
impl Clone for xcb_alloc_color_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_named_color_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_named_color_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_named_color_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_alloc_named_color_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_named_color_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_alloc_named_color_cookie_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_alloc_named_color_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_named_color_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_named_color_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
    /**<  */
    pub name_len: u16,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_named_color_request_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( xcb_alloc_named_color_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_named_color_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_alloc_named_color_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_request_t ) , "::" , stringify ! ( pad0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_request_t ) ) .
                cmap as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_request_t ) , "::" , stringify ! ( cmap
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_request_t ) ) .
                name_len as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_request_t ) , "::" , stringify ! (
                name_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_request_t ) ) .
                pad1 as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_request_t ) , "::" , stringify ! ( pad1
                ) ));
}
impl Clone for xcb_alloc_named_color_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_named_color_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_named_color_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub pixel: u32,
    /**<  */
    pub exact_red: u16,
    /**<  */
    pub exact_green: u16,
    /**<  */
    pub exact_blue: u16,
    /**<  */
    pub visual_red: u16,
    /**<  */
    pub visual_green: u16,
    /**<  */
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_named_color_reply_t>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( xcb_alloc_named_color_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_named_color_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_alloc_named_color_reply_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_reply_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_reply_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_reply_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_reply_t ) ) . pixel
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_reply_t ) , "::" , stringify ! ( pixel )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_reply_t ) ) .
                exact_red as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_reply_t ) , "::" , stringify ! (
                exact_red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_reply_t ) ) .
                exact_green as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_reply_t ) , "::" , stringify ! (
                exact_green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_reply_t ) ) .
                exact_blue as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_reply_t ) , "::" , stringify ! (
                exact_blue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_reply_t ) ) .
                visual_red as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_reply_t ) , "::" , stringify ! (
                visual_red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_reply_t ) ) .
                visual_green as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_reply_t ) , "::" , stringify ! (
                visual_green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_named_color_reply_t ) ) .
                visual_blue as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_named_color_reply_t ) , "::" , stringify ! (
                visual_blue ) ));
}
impl Clone for xcb_alloc_named_color_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_color_cells_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cells_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cells_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_alloc_color_cells_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_color_cells_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_alloc_color_cells_cookie_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_alloc_color_cells_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_color_cells_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cells_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub contiguous: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
    /**<  */
    pub colors: u16,
    /**<  */
    pub planes: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cells_request_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( xcb_alloc_color_cells_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_color_cells_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_alloc_color_cells_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_request_t ) ) .
                contiguous as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_request_t ) , "::" , stringify ! (
                contiguous ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_request_t ) ) .
                cmap as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_request_t ) , "::" , stringify ! ( cmap
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_request_t ) ) .
                colors as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_request_t ) , "::" , stringify ! (
                colors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_request_t ) ) .
                planes as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_request_t ) , "::" , stringify ! (
                planes ) ));
}
impl Clone for xcb_alloc_color_cells_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_color_cells_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cells_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub pixels_len: u16,
    /**<  */
    pub masks_len: u16,
    /**<  */
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cells_reply_t>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( xcb_alloc_color_cells_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_color_cells_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_alloc_color_cells_reply_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_reply_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_reply_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_reply_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_reply_t ) ) .
                pixels_len as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_reply_t ) , "::" , stringify ! (
                pixels_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_reply_t ) ) .
                masks_len as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_reply_t ) , "::" , stringify ! (
                masks_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_cells_reply_t ) ) . pad1
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_cells_reply_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_alloc_color_cells_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_color_planes_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_planes_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_planes_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_alloc_color_planes_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_color_planes_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_alloc_color_planes_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_alloc_color_planes_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_color_planes_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_planes_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub contiguous: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
    /**<  */
    pub colors: u16,
    /**<  */
    pub reds: u16,
    /**<  */
    pub greens: u16,
    /**<  */
    pub blues: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_planes_request_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( xcb_alloc_color_planes_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_color_planes_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_alloc_color_planes_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_request_t ) ) .
                contiguous as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_request_t ) , "::" , stringify ! (
                contiguous ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_request_t ) ) .
                cmap as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_request_t ) , "::" , stringify ! ( cmap
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_request_t ) ) .
                colors as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_request_t ) , "::" , stringify ! (
                colors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_request_t ) ) .
                reds as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_request_t ) , "::" , stringify ! ( reds
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_request_t ) ) .
                greens as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_request_t ) , "::" , stringify ! (
                greens ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_request_t ) ) .
                blues as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_request_t ) , "::" , stringify ! (
                blues ) ));
}
impl Clone for xcb_alloc_color_planes_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_alloc_color_planes_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_planes_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub pixels_len: u16,
    /**<  */
    pub pad1: [u8; 2usize],
    /**<  */
    pub red_mask: u32,
    /**<  */
    pub green_mask: u32,
    /**<  */
    pub blue_mask: u32,
    /**<  */
    pub pad2: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_planes_reply_t>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( xcb_alloc_color_planes_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_alloc_color_planes_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_alloc_color_planes_reply_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_reply_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_reply_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_reply_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_reply_t ) ) .
                pixels_len as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_reply_t ) , "::" , stringify ! (
                pixels_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_reply_t ) ) . pad1
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_reply_t ) , "::" , stringify ! ( pad1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_reply_t ) ) .
                red_mask as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_reply_t ) , "::" , stringify ! (
                red_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_reply_t ) ) .
                green_mask as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_reply_t ) , "::" , stringify ! (
                green_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_reply_t ) ) .
                blue_mask as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_reply_t ) , "::" , stringify ! (
                blue_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_alloc_color_planes_reply_t ) ) . pad2
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_alloc_color_planes_reply_t ) , "::" , stringify ! ( pad2 )
                ));
}
impl Clone for xcb_alloc_color_planes_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_free_colors_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_colors_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
    /**<  */
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_free_colors_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_colors_request_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_free_colors_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_free_colors_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_free_colors_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_colors_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_colors_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_colors_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_colors_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_colors_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_colors_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_colors_request_t ) ) . cmap as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_colors_request_t ) , "::" , stringify ! ( cmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_colors_request_t ) ) .
                plane_mask as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_colors_request_t ) , "::" , stringify ! ( plane_mask
                ) ));
}
impl Clone for xcb_free_colors_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_color_flag_t {
    XCB_COLOR_FLAG_RED = 1,
    XCB_COLOR_FLAG_GREEN = 2,
    XCB_COLOR_FLAG_BLUE = 4,
}
/**
 * @brief xcb_coloritem_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_coloritem_t {
    /**<  */
    pub pixel: u32,
    /**<  */
    pub red: u16,
    /**<  */
    pub green: u16,
    /**<  */
    pub blue: u16,
    /**<  */
    pub flags: u8,
    /**<  */
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_t() {
    assert_eq!(::std::mem::size_of::<xcb_coloritem_t>() , 12usize , concat ! (
               "Size of: " , stringify ! ( xcb_coloritem_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_coloritem_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( xcb_coloritem_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_coloritem_t ) ) . pixel as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_coloritem_t ) ,
                "::" , stringify ! ( pixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_coloritem_t ) ) . red as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_coloritem_t ) ,
                "::" , stringify ! ( red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_coloritem_t ) ) . green as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_coloritem_t ) ,
                "::" , stringify ! ( green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_coloritem_t ) ) . blue as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_coloritem_t ) ,
                "::" , stringify ! ( blue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_coloritem_t ) ) . flags as * const _
                as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_coloritem_t ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_coloritem_t ) ) . pad0 as * const _
                as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_coloritem_t ) ,
                "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_coloritem_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_coloritem_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_coloritem_iterator_t {
    /**<  */
    pub data: *mut xcb_coloritem_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_coloritem_iterator_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_coloritem_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_coloritem_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_coloritem_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_coloritem_iterator_t ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_coloritem_iterator_t ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_coloritem_iterator_t ) ) . rem as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_coloritem_iterator_t ) , "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_coloritem_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_coloritem_iterator_t ) , "::" , stringify ! ( index ) ));
}
impl Clone for xcb_coloritem_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_store_colors_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_store_colors_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_store_colors_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_store_colors_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_store_colors_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_store_colors_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_store_colors_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_store_colors_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_store_colors_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_store_colors_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_store_colors_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_store_colors_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_store_colors_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_store_colors_request_t ) ) . cmap as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_store_colors_request_t ) , "::" , stringify ! ( cmap ) ));
}
impl Clone for xcb_store_colors_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_store_named_color_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_store_named_color_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub flags: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
    /**<  */
    pub pixel: u32,
    /**<  */
    pub name_len: u16,
    /**<  */
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_store_named_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_store_named_color_request_t>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( xcb_store_named_color_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_store_named_color_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_store_named_color_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_store_named_color_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_store_named_color_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_store_named_color_request_t ) ) .
                flags as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_store_named_color_request_t ) , "::" , stringify ! ( flags
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_store_named_color_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_store_named_color_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_store_named_color_request_t ) ) .
                cmap as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_store_named_color_request_t ) , "::" , stringify ! ( cmap
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_store_named_color_request_t ) ) .
                pixel as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_store_named_color_request_t ) , "::" , stringify ! ( pixel
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_store_named_color_request_t ) ) .
                name_len as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_store_named_color_request_t ) , "::" , stringify ! (
                name_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_store_named_color_request_t ) ) .
                pad0 as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_store_named_color_request_t ) , "::" , stringify ! ( pad0
                ) ));
}
impl Clone for xcb_store_named_color_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_rgb_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rgb_t {
    /**<  */
    pub red: u16,
    /**<  */
    pub green: u16,
    /**<  */
    pub blue: u16,
    /**<  */
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_rgb_t() {
    assert_eq!(::std::mem::size_of::<xcb_rgb_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( xcb_rgb_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_rgb_t>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_rgb_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rgb_t ) ) . red as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_rgb_t ) , "::" ,
                stringify ! ( red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rgb_t ) ) . green as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_rgb_t ) , "::" ,
                stringify ! ( green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rgb_t ) ) . blue as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_rgb_t ) , "::" ,
                stringify ! ( blue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rgb_t ) ) . pad0 as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_rgb_t ) , "::" ,
                stringify ! ( pad0 ) ));
}
impl Clone for xcb_rgb_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_rgb_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rgb_iterator_t {
    /**<  */
    pub data: *mut xcb_rgb_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rgb_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_rgb_iterator_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( xcb_rgb_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_rgb_iterator_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( xcb_rgb_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rgb_iterator_t ) ) . data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_rgb_iterator_t ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rgb_iterator_t ) ) . rem as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_rgb_iterator_t ) ,
                "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rgb_iterator_t ) ) . index as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_rgb_iterator_t ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for xcb_rgb_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_colors_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_colors_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_colors_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_colors_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_colors_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_query_colors_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_colors_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_colors_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_query_colors_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_colors_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_colors_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_colors_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_colors_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_colors_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_query_colors_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_colors_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_colors_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_colors_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_colors_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_colors_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_colors_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_colors_request_t ) ) . cmap as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_colors_request_t ) , "::" , stringify ! ( cmap ) ));
}
impl Clone for xcb_query_colors_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_colors_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_colors_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub colors_len: u16,
    /**<  */
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_query_colors_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_colors_reply_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_query_colors_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_colors_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_query_colors_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_colors_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_colors_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_colors_reply_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_colors_reply_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_colors_reply_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_colors_reply_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_colors_reply_t ) ) . length as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_colors_reply_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_colors_reply_t ) ) . colors_len
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_colors_reply_t ) , "::" , stringify ! ( colors_len )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_colors_reply_t ) ) . pad1 as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_colors_reply_t ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_query_colors_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_lookup_color_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_lookup_color_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_lookup_color_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_lookup_color_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_lookup_color_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_lookup_color_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_cookie_t ) ) . sequence
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_cookie_t ) , "::" , stringify ! ( sequence )
                ));
}
impl Clone for xcb_lookup_color_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_lookup_color_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_lookup_color_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cmap: xcb_colormap_t,
    /**<  */
    pub name_len: u16,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_lookup_color_request_t>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_lookup_color_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_lookup_color_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_lookup_color_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_request_t ) ) . cmap as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_request_t ) , "::" , stringify ! ( cmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_request_t ) ) . name_len
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_request_t ) , "::" , stringify ! ( name_len )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_request_t ) ) . pad1 as
                * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_request_t ) , "::" , stringify ! ( pad1 ) ));
}
impl Clone for xcb_lookup_color_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_lookup_color_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_lookup_color_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub exact_red: u16,
    /**<  */
    pub exact_green: u16,
    /**<  */
    pub exact_blue: u16,
    /**<  */
    pub visual_red: u16,
    /**<  */
    pub visual_green: u16,
    /**<  */
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_lookup_color_reply_t>() , 20usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_lookup_color_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_lookup_color_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_lookup_color_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_reply_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_reply_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_reply_t ) ) . sequence
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_reply_t ) , "::" , stringify ! ( sequence )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_reply_t ) ) . length as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_reply_t ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_reply_t ) ) . exact_red
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_reply_t ) , "::" , stringify ! ( exact_red )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_reply_t ) ) .
                exact_green as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_reply_t ) , "::" , stringify ! ( exact_green
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_reply_t ) ) . exact_blue
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_reply_t ) , "::" , stringify ! ( exact_blue )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_reply_t ) ) . visual_red
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_reply_t ) , "::" , stringify ! ( visual_red )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_reply_t ) ) .
                visual_green as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_reply_t ) , "::" , stringify ! ( visual_green
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_lookup_color_reply_t ) ) .
                visual_blue as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_lookup_color_reply_t ) , "::" , stringify ! ( visual_blue
                ) ));
}
impl Clone for xcb_lookup_color_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_pixmap_enum_t { XCB_PIXMAP_NONE = 0, }
/**
 * @brief xcb_create_cursor_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_cursor_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cid: xcb_cursor_t,
    /**<  */
    pub source: xcb_pixmap_t,
    /**<  */
    pub mask: xcb_pixmap_t,
    /**<  */
    pub fore_red: u16,
    /**<  */
    pub fore_green: u16,
    /**<  */
    pub fore_blue: u16,
    /**<  */
    pub back_red: u16,
    /**<  */
    pub back_green: u16,
    /**<  */
    pub back_blue: u16,
    /**<  */
    pub x: u16,
    /**<  */
    pub y: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_cursor_request_t>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_create_cursor_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_create_cursor_request_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_create_cursor_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) . cid as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! ( cid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) . source
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! ( source )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) . mask as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! ( mask )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) .
                fore_red as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! ( fore_red
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) .
                fore_green as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! (
                fore_green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) .
                fore_blue as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! ( fore_blue
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) .
                back_red as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! ( back_red
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) .
                back_green as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! (
                back_green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) .
                back_blue as * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! ( back_blue
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) . x as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_cursor_request_t ) ) . y as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_cursor_request_t ) , "::" , stringify ! ( y ) ));
}
impl Clone for xcb_create_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_font_enum_t { XCB_FONT_NONE = 0, }
/**
 * @brief xcb_create_glyph_cursor_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_glyph_cursor_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cid: xcb_cursor_t,
    /**<  */
    pub source_font: xcb_font_t,
    /**<  */
    pub mask_font: xcb_font_t,
    /**<  */
    pub source_char: u16,
    /**<  */
    pub mask_char: u16,
    /**<  */
    pub fore_red: u16,
    /**<  */
    pub fore_green: u16,
    /**<  */
    pub fore_blue: u16,
    /**<  */
    pub back_red: u16,
    /**<  */
    pub back_green: u16,
    /**<  */
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_glyph_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_glyph_cursor_request_t>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( xcb_create_glyph_cursor_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_create_glyph_cursor_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_create_glyph_cursor_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                cid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! ( cid
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                source_font as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                source_font ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                mask_font as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                mask_font ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                source_char as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                source_char ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                mask_char as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                mask_char ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                fore_red as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                fore_red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                fore_green as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                fore_green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                fore_blue as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                fore_blue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                back_red as * const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                back_red ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                back_green as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                back_green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_create_glyph_cursor_request_t ) ) .
                back_blue as * const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_create_glyph_cursor_request_t ) , "::" , stringify ! (
                back_blue ) ));
}
impl Clone for xcb_create_glyph_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_free_cursor_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_cursor_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_free_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_cursor_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_free_cursor_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_free_cursor_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_free_cursor_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_cursor_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_cursor_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_cursor_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_cursor_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_cursor_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_cursor_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_free_cursor_request_t ) ) . cursor as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_free_cursor_request_t ) , "::" , stringify ! ( cursor )
                ));
}
impl Clone for xcb_free_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_recolor_cursor_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_recolor_cursor_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub cursor: xcb_cursor_t,
    /**<  */
    pub fore_red: u16,
    /**<  */
    pub fore_green: u16,
    /**<  */
    pub fore_blue: u16,
    /**<  */
    pub back_red: u16,
    /**<  */
    pub back_green: u16,
    /**<  */
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_recolor_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_recolor_cursor_request_t>() , 20usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_recolor_cursor_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_recolor_cursor_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_recolor_cursor_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_recolor_cursor_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_recolor_cursor_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_recolor_cursor_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_recolor_cursor_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_recolor_cursor_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_recolor_cursor_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_recolor_cursor_request_t ) ) . cursor
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_recolor_cursor_request_t ) , "::" , stringify ! ( cursor )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_recolor_cursor_request_t ) ) .
                fore_red as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_recolor_cursor_request_t ) , "::" , stringify ! ( fore_red
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_recolor_cursor_request_t ) ) .
                fore_green as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_recolor_cursor_request_t ) , "::" , stringify ! (
                fore_green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_recolor_cursor_request_t ) ) .
                fore_blue as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_recolor_cursor_request_t ) , "::" , stringify ! (
                fore_blue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_recolor_cursor_request_t ) ) .
                back_red as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_recolor_cursor_request_t ) , "::" , stringify ! ( back_red
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_recolor_cursor_request_t ) ) .
                back_green as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_recolor_cursor_request_t ) , "::" , stringify ! (
                back_green ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_recolor_cursor_request_t ) ) .
                back_blue as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_recolor_cursor_request_t ) , "::" , stringify ! (
                back_blue ) ));
}
impl Clone for xcb_recolor_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_query_shape_of_t {
    XCB_QUERY_SHAPE_OF_LARGEST_CURSOR = 0,
    XCB_QUERY_SHAPE_OF_FASTEST_TILE = 1,
    XCB_QUERY_SHAPE_OF_FASTEST_STIPPLE = 2,
}
/**
 * @brief xcb_query_best_size_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_best_size_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_best_size_cookie_t>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_query_best_size_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_best_size_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_query_best_size_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_cookie_t ) , "::" , stringify ! ( sequence
                ) ));
}
impl Clone for xcb_query_best_size_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_best_size_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_best_size_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub _class: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub drawable: xcb_drawable_t,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_best_size_request_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( xcb_query_best_size_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_best_size_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_query_best_size_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_request_t ) ) .
                _class as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_request_t ) , "::" , stringify ! ( _class
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_request_t ) ) .
                drawable as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_request_t ) , "::" , stringify ! (
                drawable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_request_t ) ) . width
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_request_t ) , "::" , stringify ! ( width )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_request_t ) ) .
                height as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_request_t ) , "::" , stringify ! ( height
                ) ));
}
impl Clone for xcb_query_best_size_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_best_size_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_best_size_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub width: u16,
    /**<  */
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_best_size_reply_t>() , 12usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_query_best_size_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_best_size_reply_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_query_best_size_reply_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_reply_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_reply_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_reply_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_reply_t ) ) . length
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_reply_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_reply_t ) ) . width
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_reply_t ) , "::" , stringify ! ( width )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_best_size_reply_t ) ) . height
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_best_size_reply_t ) , "::" , stringify ! ( height )
                ));
}
impl Clone for xcb_query_best_size_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_extension_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_extension_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_extension_cookie_t>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_query_extension_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_extension_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_query_extension_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_cookie_t ) , "::" , stringify ! ( sequence
                ) ));
}
impl Clone for xcb_query_extension_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_query_extension_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_extension_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub name_len: u16,
    /**<  */
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_extension_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_extension_request_t>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_query_extension_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_query_extension_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_query_extension_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_request_t ) ) .
                name_len as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_request_t ) , "::" , stringify ! (
                name_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_query_extension_request_t ) ) . pad1
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_query_extension_request_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_query_extension_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_extensions_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_extensions_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_extensions_cookie_t>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_list_extensions_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_extensions_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_list_extensions_cookie_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_extensions_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_extensions_cookie_t ) , "::" , stringify ! ( sequence
                ) ));
}
impl Clone for xcb_list_extensions_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_extensions_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_extensions_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_extensions_request_t>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_list_extensions_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_extensions_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_list_extensions_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_extensions_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_extensions_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_extensions_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_extensions_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_extensions_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_extensions_request_t ) , "::" , stringify ! ( length
                ) ));
}
impl Clone for xcb_list_extensions_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_extensions_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_extensions_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub names_len: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_extensions_reply_t>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_list_extensions_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_extensions_reply_t>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_list_extensions_reply_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_extensions_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_extensions_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_extensions_reply_t ) ) .
                names_len as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_extensions_reply_t ) , "::" , stringify ! ( names_len
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_extensions_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_extensions_reply_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_extensions_reply_t ) ) . length
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_extensions_reply_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_extensions_reply_t ) ) . pad0 as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_extensions_reply_t ) , "::" , stringify ! ( pad0 )
                ));
}
impl Clone for xcb_list_extensions_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_change_keyboard_mapping_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_keyboard_mapping_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub keycode_count: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub first_keycode: xcb_keycode_t,
    /**<  */
    pub keysyms_per_keycode: u8,
    /**<  */
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_keyboard_mapping_request_t>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               xcb_change_keyboard_mapping_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_change_keyboard_mapping_request_t>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_change_keyboard_mapping_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_keyboard_mapping_request_t ) )
                . major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_keyboard_mapping_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_keyboard_mapping_request_t ) )
                . keycode_count as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_keyboard_mapping_request_t ) , "::" , stringify ! (
                keycode_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_keyboard_mapping_request_t ) )
                . length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_keyboard_mapping_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_keyboard_mapping_request_t ) )
                . first_keycode as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_keyboard_mapping_request_t ) , "::" , stringify ! (
                first_keycode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_keyboard_mapping_request_t ) )
                . keysyms_per_keycode as * const _ as usize } , 5usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_keyboard_mapping_request_t ) , "::" , stringify ! (
                keysyms_per_keycode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_keyboard_mapping_request_t ) )
                . pad0 as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_keyboard_mapping_request_t ) , "::" , stringify ! (
                pad0 ) ));
}
impl Clone for xcb_change_keyboard_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_keyboard_mapping_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_mapping_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_mapping_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_keyboard_mapping_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_keyboard_mapping_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_keyboard_mapping_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_mapping_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_mapping_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_get_keyboard_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_keyboard_mapping_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_mapping_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub first_keycode: xcb_keycode_t,
    /**<  */
    pub count: u8,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_mapping_request_t>() ,
               6usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_keyboard_mapping_request_t
               ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_keyboard_mapping_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_keyboard_mapping_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_mapping_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_mapping_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_mapping_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_mapping_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_mapping_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_mapping_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_mapping_request_t ) ) .
                first_keycode as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_mapping_request_t ) , "::" , stringify ! (
                first_keycode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_mapping_request_t ) ) .
                count as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_mapping_request_t ) , "::" , stringify ! (
                count ) ));
}
impl Clone for xcb_get_keyboard_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_keyboard_mapping_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_mapping_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub keysyms_per_keycode: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_mapping_reply_t>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_keyboard_mapping_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_keyboard_mapping_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_keyboard_mapping_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_mapping_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_mapping_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_mapping_reply_t ) ) .
                keysyms_per_keycode as * const _ as usize } , 1usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_mapping_reply_t ) , "::" , stringify ! (
                keysyms_per_keycode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_mapping_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_mapping_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_mapping_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_mapping_reply_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_mapping_reply_t ) ) .
                pad0 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_mapping_reply_t ) , "::" , stringify ! ( pad0
                ) ));
}
impl Clone for xcb_get_keyboard_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_kb_t {
    XCB_KB_KEY_CLICK_PERCENT = 1,
    XCB_KB_BELL_PERCENT = 2,
    XCB_KB_BELL_PITCH = 4,
    XCB_KB_BELL_DURATION = 8,
    XCB_KB_LED = 16,
    XCB_KB_LED_MODE = 32,
    XCB_KB_KEY = 64,
    XCB_KB_AUTO_REPEAT_MODE = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_led_mode_t { XCB_LED_MODE_OFF = 0, XCB_LED_MODE_ON = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_auto_repeat_mode_t {
    XCB_AUTO_REPEAT_MODE_OFF = 0,
    XCB_AUTO_REPEAT_MODE_ON = 1,
    XCB_AUTO_REPEAT_MODE_DEFAULT = 2,
}
/**
 * @brief xcb_change_keyboard_control_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_keyboard_control_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_keyboard_control_request_t>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               xcb_change_keyboard_control_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_change_keyboard_control_request_t>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_change_keyboard_control_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_keyboard_control_request_t ) )
                . major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_keyboard_control_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_keyboard_control_request_t ) )
                . pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_keyboard_control_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_keyboard_control_request_t ) )
                . length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_keyboard_control_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_keyboard_control_request_t ) )
                . value_mask as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_keyboard_control_request_t ) , "::" , stringify ! (
                value_mask ) ));
}
impl Clone for xcb_change_keyboard_control_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_keyboard_control_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_control_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_control_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_keyboard_control_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_keyboard_control_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_keyboard_control_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_get_keyboard_control_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_keyboard_control_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_control_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_control_request_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_keyboard_control_request_t
               ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_keyboard_control_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_keyboard_control_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_request_t ) , "::" , stringify ! (
                length ) ));
}
impl Clone for xcb_get_keyboard_control_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_keyboard_control_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_control_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub global_auto_repeat: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub led_mask: u32,
    /**<  */
    pub key_click_percent: u8,
    /**<  */
    pub bell_percent: u8,
    /**<  */
    pub bell_pitch: u16,
    /**<  */
    pub bell_duration: u16,
    /**<  */
    pub pad0: [u8; 2usize],
    /**<  */
    pub auto_repeats: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_control_reply_t>() ,
               52usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_keyboard_control_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_keyboard_control_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_keyboard_control_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_reply_t ) ) .
                global_auto_repeat as * const _ as usize } , 1usize , concat !
                (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_reply_t ) , "::" , stringify ! (
                global_auto_repeat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_reply_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_reply_t ) ) .
                led_mask as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_reply_t ) , "::" , stringify ! (
                led_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_reply_t ) ) .
                key_click_percent as * const _ as usize } , 12usize , concat !
                (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_reply_t ) , "::" , stringify ! (
                key_click_percent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_reply_t ) ) .
                bell_percent as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_reply_t ) , "::" , stringify ! (
                bell_percent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_reply_t ) ) .
                bell_pitch as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_reply_t ) , "::" , stringify ! (
                bell_pitch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_reply_t ) ) .
                bell_duration as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_reply_t ) , "::" , stringify ! (
                bell_duration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_reply_t ) ) .
                pad0 as * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_reply_t ) , "::" , stringify ! ( pad0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_keyboard_control_reply_t ) ) .
                auto_repeats as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_keyboard_control_reply_t ) , "::" , stringify ! (
                auto_repeats ) ));
}
impl Clone for xcb_get_keyboard_control_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_bell_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_bell_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub percent: i8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_bell_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_bell_request_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( xcb_bell_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_bell_request_t>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( xcb_bell_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_bell_request_t ) ) . major_opcode as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_bell_request_t ) ,
                "::" , stringify ! ( major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_bell_request_t ) ) . percent as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_bell_request_t ) ,
                "::" , stringify ! ( percent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_bell_request_t ) ) . length as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_bell_request_t ) ,
                "::" , stringify ! ( length ) ));
}
impl Clone for xcb_bell_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_change_pointer_control_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_pointer_control_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub acceleration_numerator: i16,
    /**<  */
    pub acceleration_denominator: i16,
    /**<  */
    pub threshold: i16,
    /**<  */
    pub do_acceleration: u8,
    /**<  */
    pub do_threshold: u8,
}
#[test]
fn bindgen_test_layout_xcb_change_pointer_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_pointer_control_request_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! (
               xcb_change_pointer_control_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_change_pointer_control_request_t>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_change_pointer_control_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_pointer_control_request_t ) )
                . major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_pointer_control_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_pointer_control_request_t ) )
                . pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_pointer_control_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_pointer_control_request_t ) )
                . length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_pointer_control_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_pointer_control_request_t ) )
                . acceleration_numerator as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_pointer_control_request_t ) , "::" , stringify ! (
                acceleration_numerator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_pointer_control_request_t ) )
                . acceleration_denominator as * const _ as usize } , 6usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_pointer_control_request_t ) , "::" , stringify ! (
                acceleration_denominator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_pointer_control_request_t ) )
                . threshold as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_pointer_control_request_t ) , "::" , stringify ! (
                threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_pointer_control_request_t ) )
                . do_acceleration as * const _ as usize } , 10usize , concat !
                (
                "Alignment of field: " , stringify ! (
                xcb_change_pointer_control_request_t ) , "::" , stringify ! (
                do_acceleration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_pointer_control_request_t ) )
                . do_threshold as * const _ as usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_pointer_control_request_t ) , "::" , stringify ! (
                do_threshold ) ));
}
impl Clone for xcb_change_pointer_control_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_pointer_control_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_control_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_control_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_pointer_control_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_pointer_control_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_pointer_control_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_get_pointer_control_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_pointer_control_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_control_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_control_request_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_pointer_control_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_pointer_control_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_pointer_control_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_request_t ) , "::" , stringify ! (
                length ) ));
}
impl Clone for xcb_get_pointer_control_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_pointer_control_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_control_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub acceleration_numerator: u16,
    /**<  */
    pub acceleration_denominator: u16,
    /**<  */
    pub threshold: u16,
    /**<  */
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_control_reply_t>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_pointer_control_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_pointer_control_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_pointer_control_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_reply_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_reply_t ) , "::" , stringify ! ( pad0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_reply_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_reply_t ) ) .
                acceleration_numerator as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_reply_t ) , "::" , stringify ! (
                acceleration_numerator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_reply_t ) ) .
                acceleration_denominator as * const _ as usize } , 10usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_reply_t ) , "::" , stringify ! (
                acceleration_denominator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_reply_t ) ) .
                threshold as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_reply_t ) , "::" , stringify ! (
                threshold ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_control_reply_t ) ) .
                pad1 as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_control_reply_t ) , "::" , stringify ! ( pad1
                ) ));
}
impl Clone for xcb_get_pointer_control_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_blanking_t {
    XCB_BLANKING_NOT_PREFERRED = 0,
    XCB_BLANKING_PREFERRED = 1,
    XCB_BLANKING_DEFAULT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_exposures_t {
    XCB_EXPOSURES_NOT_ALLOWED = 0,
    XCB_EXPOSURES_ALLOWED = 1,
    XCB_EXPOSURES_DEFAULT = 2,
}
/**
 * @brief xcb_set_screen_saver_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_screen_saver_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub timeout: i16,
    /**<  */
    pub interval: i16,
    /**<  */
    pub prefer_blanking: u8,
    /**<  */
    pub allow_exposures: u8,
}
#[test]
fn bindgen_test_layout_xcb_set_screen_saver_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_screen_saver_request_t>() ,
               10usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_screen_saver_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_set_screen_saver_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_set_screen_saver_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_screen_saver_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_screen_saver_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_screen_saver_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_screen_saver_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_screen_saver_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_screen_saver_request_t ) , "::" , stringify ! ( length
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_screen_saver_request_t ) ) .
                timeout as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_screen_saver_request_t ) , "::" , stringify ! (
                timeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_screen_saver_request_t ) ) .
                interval as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_screen_saver_request_t ) , "::" , stringify ! (
                interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_screen_saver_request_t ) ) .
                prefer_blanking as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_screen_saver_request_t ) , "::" , stringify ! (
                prefer_blanking ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_screen_saver_request_t ) ) .
                allow_exposures as * const _ as usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_screen_saver_request_t ) , "::" , stringify ! (
                allow_exposures ) ));
}
impl Clone for xcb_set_screen_saver_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_screen_saver_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_screen_saver_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_screen_saver_cookie_t>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_get_screen_saver_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_screen_saver_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_get_screen_saver_cookie_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_get_screen_saver_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_screen_saver_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_screen_saver_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_screen_saver_request_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_screen_saver_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_screen_saver_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_get_screen_saver_request_t
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_request_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_request_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_request_t ) , "::" , stringify ! ( length
                ) ));
}
impl Clone for xcb_get_screen_saver_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_screen_saver_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_screen_saver_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub timeout: u16,
    /**<  */
    pub interval: u16,
    /**<  */
    pub prefer_blanking: u8,
    /**<  */
    pub allow_exposures: u8,
    /**<  */
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_screen_saver_reply_t>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( xcb_get_screen_saver_reply_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_screen_saver_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( xcb_get_screen_saver_reply_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_reply_t ) ) . pad0
                as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_reply_t ) , "::" , stringify ! ( pad0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_reply_t ) , "::" , stringify ! ( sequence
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_reply_t ) ) . length
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_reply_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_reply_t ) ) .
                timeout as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_reply_t ) , "::" , stringify ! ( timeout
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_reply_t ) ) .
                interval as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_reply_t ) , "::" , stringify ! ( interval
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_reply_t ) ) .
                prefer_blanking as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_reply_t ) , "::" , stringify ! (
                prefer_blanking ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_reply_t ) ) .
                allow_exposures as * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_reply_t ) , "::" , stringify ! (
                allow_exposures ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_screen_saver_reply_t ) ) . pad1
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_screen_saver_reply_t ) , "::" , stringify ! ( pad1 )
                ));
}
impl Clone for xcb_get_screen_saver_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_host_mode_t {
    XCB_HOST_MODE_INSERT = 0,
    XCB_HOST_MODE_DELETE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_family_t {
    XCB_FAMILY_INTERNET = 0,
    XCB_FAMILY_DECNET = 1,
    XCB_FAMILY_CHAOS = 2,
    XCB_FAMILY_SERVER_INTERPRETED = 5,
    XCB_FAMILY_INTERNET_6 = 6,
}
/**
 * @brief xcb_change_hosts_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_hosts_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub mode: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub family: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_change_hosts_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_hosts_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_change_hosts_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_change_hosts_request_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_change_hosts_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_hosts_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_hosts_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_hosts_request_t ) ) . mode as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_hosts_request_t ) , "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_hosts_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_hosts_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_hosts_request_t ) ) . family
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_hosts_request_t ) , "::" , stringify ! ( family )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_hosts_request_t ) ) . pad0 as
                * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_hosts_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_change_hosts_request_t ) ) .
                address_len as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_change_hosts_request_t ) , "::" , stringify ! (
                address_len ) ));
}
impl Clone for xcb_change_hosts_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_host_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_host_t {
    /**<  */
    pub family: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_host_t() {
    assert_eq!(::std::mem::size_of::<xcb_host_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( xcb_host_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_host_t>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( xcb_host_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_host_t ) ) . family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_host_t ) , "::" ,
                stringify ! ( family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_host_t ) ) . pad0 as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_host_t ) , "::" ,
                stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_host_t ) ) . address_len as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_host_t ) , "::" ,
                stringify ! ( address_len ) ));
}
impl Clone for xcb_host_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_host_iterator_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_host_iterator_t {
    /**<  */
    pub data: *mut xcb_host_t,
    /**<  */
    pub rem: ::std::os::raw::c_int,
    /**<  */
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xcb_host_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_host_iterator_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( xcb_host_iterator_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_host_iterator_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_host_iterator_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_host_iterator_t ) ) . data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_host_iterator_t ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_host_iterator_t ) ) . rem as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_host_iterator_t ) ,
                "::" , stringify ! ( rem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_host_iterator_t ) ) . index as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_host_iterator_t ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for xcb_host_iterator_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_hosts_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_hosts_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_hosts_cookie_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_list_hosts_cookie_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_hosts_cookie_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_list_hosts_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_hosts_cookie_t ) ) . sequence as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_hosts_cookie_t
                ) , "::" , stringify ! ( sequence ) ));
}
impl Clone for xcb_list_hosts_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_hosts_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_hosts_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_hosts_request_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_list_hosts_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_list_hosts_request_t>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_list_hosts_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_hosts_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_hosts_request_t ) , "::" , stringify ! ( major_opcode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_hosts_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_hosts_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_hosts_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_list_hosts_request_t ) , "::" , stringify ! ( length ) ));
}
impl Clone for xcb_list_hosts_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_list_hosts_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_hosts_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub mode: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub hosts_len: u16,
    /**<  */
    pub pad0: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_hosts_reply_t>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( xcb_list_hosts_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_list_hosts_reply_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_list_hosts_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_hosts_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_hosts_reply_t
                ) , "::" , stringify ! ( response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_hosts_reply_t ) ) . mode as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_hosts_reply_t
                ) , "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_hosts_reply_t ) ) . sequence as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_hosts_reply_t
                ) , "::" , stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_hosts_reply_t ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_hosts_reply_t
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_hosts_reply_t ) ) . hosts_len as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_hosts_reply_t
                ) , "::" , stringify ! ( hosts_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_list_hosts_reply_t ) ) . pad0 as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( xcb_list_hosts_reply_t
                ) , "::" , stringify ! ( pad0 ) ));
}
impl Clone for xcb_list_hosts_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_access_control_t {
    XCB_ACCESS_CONTROL_DISABLE = 0,
    XCB_ACCESS_CONTROL_ENABLE = 1,
}
/**
 * @brief xcb_set_access_control_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_access_control_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub mode: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_access_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_access_control_request_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_access_control_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_set_access_control_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_set_access_control_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_access_control_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_access_control_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_access_control_request_t ) ) .
                mode as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_access_control_request_t ) , "::" , stringify ! ( mode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_access_control_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_access_control_request_t ) , "::" , stringify ! (
                length ) ));
}
impl Clone for xcb_set_access_control_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_close_down_t {
    XCB_CLOSE_DOWN_DESTROY_ALL = 0,
    XCB_CLOSE_DOWN_RETAIN_PERMANENT = 1,
    XCB_CLOSE_DOWN_RETAIN_TEMPORARY = 2,
}
/**
 * @brief xcb_set_close_down_mode_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_close_down_mode_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub mode: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_close_down_mode_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_close_down_mode_request_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_close_down_mode_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_set_close_down_mode_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_set_close_down_mode_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_close_down_mode_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_close_down_mode_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_close_down_mode_request_t ) ) .
                mode as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_close_down_mode_request_t ) , "::" , stringify ! (
                mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_close_down_mode_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_close_down_mode_request_t ) , "::" , stringify ! (
                length ) ));
}
impl Clone for xcb_set_close_down_mode_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_kill_t { XCB_KILL_ALL_TEMPORARY = 0, }
/**
 * @brief xcb_kill_client_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_kill_client_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub resource: u32,
}
#[test]
fn bindgen_test_layout_xcb_kill_client_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_kill_client_request_t>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_kill_client_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_kill_client_request_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( xcb_kill_client_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_kill_client_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_kill_client_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_kill_client_request_t ) ) . pad0 as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_kill_client_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_kill_client_request_t ) ) . length as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_kill_client_request_t ) , "::" , stringify ! ( length )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_kill_client_request_t ) ) . resource
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_kill_client_request_t ) , "::" , stringify ! ( resource )
                ));
}
impl Clone for xcb_kill_client_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_rotate_properties_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rotate_properties_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
    /**<  */
    pub window: xcb_window_t,
    /**<  */
    pub atoms_len: u16,
    /**<  */
    pub delta: i16,
}
#[test]
fn bindgen_test_layout_xcb_rotate_properties_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_rotate_properties_request_t>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( xcb_rotate_properties_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_rotate_properties_request_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_rotate_properties_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rotate_properties_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_rotate_properties_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rotate_properties_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_rotate_properties_request_t ) , "::" , stringify ! ( pad0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rotate_properties_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_rotate_properties_request_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rotate_properties_request_t ) ) .
                window as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_rotate_properties_request_t ) , "::" , stringify ! (
                window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rotate_properties_request_t ) ) .
                atoms_len as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_rotate_properties_request_t ) , "::" , stringify ! (
                atoms_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_rotate_properties_request_t ) ) .
                delta as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_rotate_properties_request_t ) , "::" , stringify ! ( delta
                ) ));
}
impl Clone for xcb_rotate_properties_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_screen_saver_t {
    XCB_SCREEN_SAVER_RESET = 0,
    XCB_SCREEN_SAVER_ACTIVE = 1,
}
/**
 * @brief xcb_force_screen_saver_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_force_screen_saver_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub mode: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_force_screen_saver_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_force_screen_saver_request_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_force_screen_saver_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_force_screen_saver_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_force_screen_saver_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_force_screen_saver_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_force_screen_saver_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_force_screen_saver_request_t ) ) .
                mode as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_force_screen_saver_request_t ) , "::" , stringify ! ( mode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_force_screen_saver_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_force_screen_saver_request_t ) , "::" , stringify ! (
                length ) ));
}
impl Clone for xcb_force_screen_saver_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_mapping_status_t {
    XCB_MAPPING_STATUS_SUCCESS = 0,
    XCB_MAPPING_STATUS_BUSY = 1,
    XCB_MAPPING_STATUS_FAILURE = 2,
}
/**
 * @brief xcb_set_pointer_mapping_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_pointer_mapping_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_pointer_mapping_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_pointer_mapping_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_set_pointer_mapping_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_set_pointer_mapping_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_pointer_mapping_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_pointer_mapping_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_set_pointer_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_set_pointer_mapping_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_pointer_mapping_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub map_len: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_pointer_mapping_request_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_pointer_mapping_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_set_pointer_mapping_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_set_pointer_mapping_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_pointer_mapping_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_pointer_mapping_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_pointer_mapping_request_t ) ) .
                map_len as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_pointer_mapping_request_t ) , "::" , stringify ! (
                map_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_pointer_mapping_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_pointer_mapping_request_t ) , "::" , stringify ! (
                length ) ));
}
impl Clone for xcb_set_pointer_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_set_pointer_mapping_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_pointer_mapping_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub status: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_pointer_mapping_reply_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_pointer_mapping_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_set_pointer_mapping_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_set_pointer_mapping_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_pointer_mapping_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_pointer_mapping_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_pointer_mapping_reply_t ) ) .
                status as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_pointer_mapping_reply_t ) , "::" , stringify ! (
                status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_pointer_mapping_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_pointer_mapping_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_pointer_mapping_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_pointer_mapping_reply_t ) , "::" , stringify ! (
                length ) ));
}
impl Clone for xcb_set_pointer_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_pointer_mapping_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_mapping_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_mapping_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_pointer_mapping_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_pointer_mapping_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_pointer_mapping_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_mapping_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_mapping_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_get_pointer_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_pointer_mapping_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_mapping_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_mapping_request_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_pointer_mapping_request_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_pointer_mapping_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_pointer_mapping_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_mapping_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_mapping_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_mapping_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_mapping_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_mapping_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_mapping_request_t ) , "::" , stringify ! (
                length ) ));
}
impl Clone for xcb_get_pointer_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_pointer_mapping_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_mapping_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub map_len: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_mapping_reply_t>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_pointer_mapping_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_pointer_mapping_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_pointer_mapping_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_mapping_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_mapping_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_mapping_reply_t ) ) .
                map_len as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_mapping_reply_t ) , "::" , stringify ! (
                map_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_mapping_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_mapping_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_mapping_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_mapping_reply_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_pointer_mapping_reply_t ) ) .
                pad0 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_pointer_mapping_reply_t ) , "::" , stringify ! ( pad0
                ) ));
}
impl Clone for xcb_get_pointer_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_map_index_t {
    XCB_MAP_INDEX_SHIFT = 0,
    XCB_MAP_INDEX_LOCK = 1,
    XCB_MAP_INDEX_CONTROL = 2,
    XCB_MAP_INDEX_1 = 3,
    XCB_MAP_INDEX_2 = 4,
    XCB_MAP_INDEX_3 = 5,
    XCB_MAP_INDEX_4 = 6,
    XCB_MAP_INDEX_5 = 7,
}
/**
 * @brief xcb_set_modifier_mapping_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_modifier_mapping_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_modifier_mapping_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_modifier_mapping_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_set_modifier_mapping_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_set_modifier_mapping_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_modifier_mapping_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_modifier_mapping_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_set_modifier_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_set_modifier_mapping_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_modifier_mapping_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub keycodes_per_modifier: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_modifier_mapping_request_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_modifier_mapping_request_t
               ) ));
    assert_eq! (::std::mem::align_of::<xcb_set_modifier_mapping_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_set_modifier_mapping_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_modifier_mapping_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_modifier_mapping_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_modifier_mapping_request_t ) ) .
                keycodes_per_modifier as * const _ as usize } , 1usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_modifier_mapping_request_t ) , "::" , stringify ! (
                keycodes_per_modifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_modifier_mapping_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_modifier_mapping_request_t ) , "::" , stringify ! (
                length ) ));
}
impl Clone for xcb_set_modifier_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_set_modifier_mapping_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_modifier_mapping_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub status: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_modifier_mapping_reply_t>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( xcb_set_modifier_mapping_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_set_modifier_mapping_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_set_modifier_mapping_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_modifier_mapping_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_modifier_mapping_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_modifier_mapping_reply_t ) ) .
                status as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_modifier_mapping_reply_t ) , "::" , stringify ! (
                status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_modifier_mapping_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_modifier_mapping_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_set_modifier_mapping_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_set_modifier_mapping_reply_t ) , "::" , stringify ! (
                length ) ));
}
impl Clone for xcb_set_modifier_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_modifier_mapping_cookie_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_modifier_mapping_cookie_t {
    /**<  */
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_modifier_mapping_cookie_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_modifier_mapping_cookie_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_modifier_mapping_cookie_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_modifier_mapping_cookie_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_modifier_mapping_cookie_t ) ) .
                sequence as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_modifier_mapping_cookie_t ) , "::" , stringify ! (
                sequence ) ));
}
impl Clone for xcb_get_modifier_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_modifier_mapping_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_modifier_mapping_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_modifier_mapping_request_t>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_modifier_mapping_request_t
               ) ));
    assert_eq! (::std::mem::align_of::<xcb_get_modifier_mapping_request_t>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_modifier_mapping_request_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_modifier_mapping_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_modifier_mapping_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_modifier_mapping_request_t ) ) .
                pad0 as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_modifier_mapping_request_t ) , "::" , stringify ! (
                pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_modifier_mapping_request_t ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_modifier_mapping_request_t ) , "::" , stringify ! (
                length ) ));
}
impl Clone for xcb_get_modifier_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_get_modifier_mapping_reply_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_modifier_mapping_reply_t {
    /**<  */
    pub response_type: u8,
    /**<  */
    pub keycodes_per_modifier: u8,
    /**<  */
    pub sequence: u16,
    /**<  */
    pub length: u32,
    /**<  */
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_modifier_mapping_reply_t>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( xcb_get_modifier_mapping_reply_t )
               ));
    assert_eq! (::std::mem::align_of::<xcb_get_modifier_mapping_reply_t>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                xcb_get_modifier_mapping_reply_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_modifier_mapping_reply_t ) ) .
                response_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_modifier_mapping_reply_t ) , "::" , stringify ! (
                response_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_modifier_mapping_reply_t ) ) .
                keycodes_per_modifier as * const _ as usize } , 1usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_modifier_mapping_reply_t ) , "::" , stringify ! (
                keycodes_per_modifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_modifier_mapping_reply_t ) ) .
                sequence as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_modifier_mapping_reply_t ) , "::" , stringify ! (
                sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_modifier_mapping_reply_t ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_modifier_mapping_reply_t ) , "::" , stringify ! (
                length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_get_modifier_mapping_reply_t ) ) .
                pad0 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_get_modifier_mapping_reply_t ) , "::" , stringify ! ( pad0
                ) ));
}
impl Clone for xcb_get_modifier_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
/**
 * @brief xcb_no_operation_request_t
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_no_operation_request_t {
    /**<  */
    pub major_opcode: u8,
    /**<  */
    pub pad0: u8,
    /**<  */
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_no_operation_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_no_operation_request_t>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( xcb_no_operation_request_t ) ));
    assert_eq! (::std::mem::align_of::<xcb_no_operation_request_t>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( xcb_no_operation_request_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_no_operation_request_t ) ) .
                major_opcode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_no_operation_request_t ) , "::" , stringify ! (
                major_opcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_no_operation_request_t ) ) . pad0 as
                * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_no_operation_request_t ) , "::" , stringify ! ( pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xcb_no_operation_request_t ) ) . length
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                xcb_no_operation_request_t ) , "::" , stringify ! ( length )
                ));
}
impl Clone for xcb_no_operation_request_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_char2b_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_char2b_t)
 */
    pub fn xcb_char2b_next(i: *mut xcb_char2b_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_char2b_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_char2b_end(i: xcb_char2b_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_window_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_window_t)
 */
    pub fn xcb_window_next(i: *mut xcb_window_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_window_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_window_end(i: xcb_window_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_pixmap_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_pixmap_t)
 */
    pub fn xcb_pixmap_next(i: *mut xcb_pixmap_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_pixmap_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_pixmap_end(i: xcb_pixmap_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_cursor_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_cursor_t)
 */
    pub fn xcb_cursor_next(i: *mut xcb_cursor_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_cursor_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_cursor_end(i: xcb_cursor_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_font_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_font_t)
 */
    pub fn xcb_font_next(i: *mut xcb_font_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_font_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_font_end(i: xcb_font_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_gcontext_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_gcontext_t)
 */
    pub fn xcb_gcontext_next(i: *mut xcb_gcontext_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_gcontext_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_gcontext_end(i: xcb_gcontext_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_colormap_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_colormap_t)
 */
    pub fn xcb_colormap_next(i: *mut xcb_colormap_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_colormap_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_colormap_end(i: xcb_colormap_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_atom_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_atom_t)
 */
    pub fn xcb_atom_next(i: *mut xcb_atom_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_atom_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_atom_end(i: xcb_atom_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_drawable_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_drawable_t)
 */
    pub fn xcb_drawable_next(i: *mut xcb_drawable_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_drawable_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_drawable_end(i: xcb_drawable_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_fontable_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_fontable_t)
 */
    pub fn xcb_fontable_next(i: *mut xcb_fontable_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_fontable_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_fontable_end(i: xcb_fontable_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_visualid_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_visualid_t)
 */
    pub fn xcb_visualid_next(i: *mut xcb_visualid_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_visualid_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_visualid_end(i: xcb_visualid_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_timestamp_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_timestamp_t)
 */
    pub fn xcb_timestamp_next(i: *mut xcb_timestamp_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_timestamp_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_timestamp_end(i: xcb_timestamp_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_keysym_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_keysym_t)
 */
    pub fn xcb_keysym_next(i: *mut xcb_keysym_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_keysym_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_keysym_end(i: xcb_keysym_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_keycode_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_keycode_t)
 */
    pub fn xcb_keycode_next(i: *mut xcb_keycode_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_keycode_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_keycode_end(i: xcb_keycode_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_button_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_button_t)
 */
    pub fn xcb_button_next(i: *mut xcb_button_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_button_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_button_end(i: xcb_button_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_point_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_point_t)
 */
    pub fn xcb_point_next(i: *mut xcb_point_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_point_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_point_end(i: xcb_point_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_rectangle_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_rectangle_t)
 */
    pub fn xcb_rectangle_next(i: *mut xcb_rectangle_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_rectangle_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_rectangle_end(i: xcb_rectangle_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_arc_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_arc_t)
 */
    pub fn xcb_arc_next(i: *mut xcb_arc_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_arc_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_arc_end(i: xcb_arc_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_format_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_format_t)
 */
    pub fn xcb_format_next(i: *mut xcb_format_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_format_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_format_end(i: xcb_format_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_visualtype_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_visualtype_t)
 */
    pub fn xcb_visualtype_next(i: *mut xcb_visualtype_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_visualtype_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_visualtype_end(i: xcb_visualtype_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_depth_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals(R: *const xcb_depth_t) -> *mut xcb_visualtype_t;
}
extern "C" {
    pub fn xcb_depth_visuals_length(R: *const xcb_depth_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals_iterator(R: *const xcb_depth_t)
     -> xcb_visualtype_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_depth_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_depth_t)
 */
    pub fn xcb_depth_next(i: *mut xcb_depth_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_depth_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_depth_end(i: xcb_depth_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_screen_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_length(R: *const xcb_screen_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_iterator(R: *const xcb_screen_t)
     -> xcb_depth_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_screen_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_screen_t)
 */
    pub fn xcb_screen_next(i: *mut xcb_screen_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_screen_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_screen_end(i: xcb_screen_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name(R:
                                                             *const xcb_setup_request_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_length(R:
                                                                    *const xcb_setup_request_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_end(R:
                                                                 *const xcb_setup_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data(R:
                                                             *const xcb_setup_request_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_length(R:
                                                                    *const xcb_setup_request_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_end(R:
                                                                 *const xcb_setup_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_setup_request_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_setup_request_t)
 */
    pub fn xcb_setup_request_next(i: *mut xcb_setup_request_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_setup_request_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_setup_request_end(i: xcb_setup_request_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason(R: *const xcb_setup_failed_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_failed_reason_length(R: *const xcb_setup_failed_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason_end(R: *const xcb_setup_failed_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_setup_failed_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_setup_failed_t)
 */
    pub fn xcb_setup_failed_next(i: *mut xcb_setup_failed_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_setup_failed_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_setup_failed_end(i: xcb_setup_failed_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_sizeof(_buffer:
                                             *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason(R: *const xcb_setup_authenticate_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_length(R:
                                                    *const xcb_setup_authenticate_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_end(R:
                                                 *const xcb_setup_authenticate_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_setup_authenticate_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_setup_authenticate_t)
 */
    pub fn xcb_setup_authenticate_next(i:
                                           *mut xcb_setup_authenticate_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_setup_authenticate_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_setup_authenticate_end(i: xcb_setup_authenticate_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor(R: *const xcb_setup_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_setup_vendor_length(R: *const xcb_setup_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor_end(R: *const xcb_setup_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats(R: *const xcb_setup_t)
     -> *mut xcb_format_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_length(R: *const xcb_setup_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_iterator(R: *const xcb_setup_t)
     -> xcb_format_iterator_t;
}
extern "C" {
    pub fn xcb_setup_roots_length(R: *const xcb_setup_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_setup_roots_iterator(R: *const xcb_setup_t)
     -> xcb_screen_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_setup_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_setup_t)
 */
    pub fn xcb_setup_next(i: *mut xcb_setup_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_setup_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_setup_end(i: xcb_setup_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_client_message_data_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_client_message_data_t)
 */
    pub fn xcb_client_message_data_next(i:
                                            *mut xcb_client_message_data_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_client_message_data_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_client_message_data_end(i: xcb_client_message_data_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_create_window_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Creates a window
 *
 * @param c The connection
 * @param depth Specifies the new window's depth (TODO: what unit?).
 * \n
 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the
 * \a parent window.
 * @param wid The ID with which you will refer to the new window, created by
 * `xcb_generate_id`.
 * @param parent The parent window of the new window.
 * @param x The X coordinate of the new window.
 * @param y The Y coordinate of the new window.
 * @param width The width of the new window.
 * @param height The height of the new window.
 * @param border_width TODO:
 * \n
 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.
 * @param _class A bitmask of #xcb_window_class_t values.
 * @param _class \n
 * @param visual Specifies the id for the new window's visual.
 * \n
 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the
 * \a parent window.
 * @param value_mask A bitmask of #xcb_cw_t values.
 * @return A cookie
 *
 * Creates an unmapped window as child of the specified \a parent window. A
 * CreateNotify event will be generated. The new window is placed on top in the
 * stacking order with respect to siblings.
 *
 * The coordinate system has the X axis horizontal and the Y axis vertical with
 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms
 * of pixels, and coincide with pixel centers. Each window and pixmap has its own
 * coordinate system. For a window, the origin is inside the border at the inside,
 * upper-left corner.
 *
 * The created window is not yet displayed (mapped), call `xcb_map_window` to
 * display it.
 *
 * The created window will initially use the same cursor as its parent.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_create_window_checked(c: *mut xcb_connection_t, depth: u8,
                                     wid: xcb_window_t, parent: xcb_window_t,
                                     x: i16, y: i16, width: u16, height: u16,
                                     border_width: u16, _class: u16,
                                     visual: xcb_visualid_t, value_mask: u32,
                                     value_list: *const u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Creates a window
 *
 * @param c The connection
 * @param depth Specifies the new window's depth (TODO: what unit?).
 * \n
 * The special value `XCB_COPY_FROM_PARENT` means the depth is taken from the
 * \a parent window.
 * @param wid The ID with which you will refer to the new window, created by
 * `xcb_generate_id`.
 * @param parent The parent window of the new window.
 * @param x The X coordinate of the new window.
 * @param y The Y coordinate of the new window.
 * @param width The width of the new window.
 * @param height The height of the new window.
 * @param border_width TODO:
 * \n
 * Must be zero if the `class` is `InputOnly` or a `xcb_match_error_t` occurs.
 * @param _class A bitmask of #xcb_window_class_t values.
 * @param _class \n
 * @param visual Specifies the id for the new window's visual.
 * \n
 * The special value `XCB_COPY_FROM_PARENT` means the visual is taken from the
 * \a parent window.
 * @param value_mask A bitmask of #xcb_cw_t values.
 * @return A cookie
 *
 * Creates an unmapped window as child of the specified \a parent window. A
 * CreateNotify event will be generated. The new window is placed on top in the
 * stacking order with respect to siblings.
 *
 * The coordinate system has the X axis horizontal and the Y axis vertical with
 * the origin [0, 0] at the upper-left corner. Coordinates are integral, in terms
 * of pixels, and coincide with pixel centers. Each window and pixmap has its own
 * coordinate system. For a window, the origin is inside the border at the inside,
 * upper-left corner.
 *
 * The created window is not yet displayed (mapped), call `xcb_map_window` to
 * display it.
 *
 * The created window will initially use the same cursor as its parent.
 *
 */
    pub fn xcb_create_window(c: *mut xcb_connection_t, depth: u8,
                             wid: xcb_window_t, parent: xcb_window_t, x: i16,
                             y: i16, width: u16, height: u16,
                             border_width: u16, _class: u16,
                             visual: xcb_visualid_t, value_mask: u32,
                             value_list: *const u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_sizeof(_buffer:
                                                   *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief change window attributes
 *
 * @param c The connection
 * @param window The window to change.
 * @param value_mask A bitmask of #xcb_cw_t values.
 * @param value_mask \n
 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The
 * order has to correspond to the order of possible \a value_mask bits. See the
 * example.
 * @return A cookie
 *
 * Changes the attributes specified by \a value_mask for the specified \a window.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_change_window_attributes_checked(c: *mut xcb_connection_t,
                                                window: xcb_window_t,
                                                value_mask: u32,
                                                value_list: *const u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief change window attributes
 *
 * @param c The connection
 * @param window The window to change.
 * @param value_mask A bitmask of #xcb_cw_t values.
 * @param value_mask \n
 * @param value_list Values for each of the attributes specified in the bitmask \a value_mask. The
 * order has to correspond to the order of possible \a value_mask bits. See the
 * example.
 * @return A cookie
 *
 * Changes the attributes specified by \a value_mask for the specified \a window.
 *
 */
    pub fn xcb_change_window_attributes(c: *mut xcb_connection_t,
                                        window: xcb_window_t, value_mask: u32,
                                        value_list: *const u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Gets window attributes
 *
 * @param c The connection
 * @param window The window to get the attributes from.
 * @return A cookie
 *
 * Gets the current attributes for the specified \a window.
 *
 */
    pub fn xcb_get_window_attributes(c: *mut xcb_connection_t,
                                     window: xcb_window_t)
     -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    /**
 * @brief Gets window attributes
 *
 * @param c The connection
 * @param window The window to get the attributes from.
 * @return A cookie
 *
 * Gets the current attributes for the specified \a window.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_window_attributes_unchecked(c: *mut xcb_connection_t,
                                               window: xcb_window_t)
     -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_window_attributes_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_window_attributes_reply(c: *mut xcb_connection_t,
                                           cookie:
                                               xcb_get_window_attributes_cookie_t,
                                           e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_window_attributes_reply_t;
}
extern "C" {
    /**
 * @brief Destroys a window
 *
 * @param c The connection
 * @param window The window to destroy.
 * @return A cookie
 *
 * Destroys the specified window and all of its subwindows. A DestroyNotify event
 * is generated for each destroyed window (a DestroyNotify event is first generated
 * for any given window's inferiors). If the window was mapped, it will be
 * automatically unmapped before destroying.
 *
 * Calling DestroyWindow on the root window will do nothing.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_destroy_window_checked(c: *mut xcb_connection_t,
                                      window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Destroys a window
 *
 * @param c The connection
 * @param window The window to destroy.
 * @return A cookie
 *
 * Destroys the specified window and all of its subwindows. A DestroyNotify event
 * is generated for each destroyed window (a DestroyNotify event is first generated
 * for any given window's inferiors). If the window was mapped, it will be
 * automatically unmapped before destroying.
 *
 * Calling DestroyWindow on the root window will do nothing.
 *
 */
    pub fn xcb_destroy_window(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_destroy_subwindows_checked(c: *mut xcb_connection_t,
                                          window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_destroy_subwindows(c: *mut xcb_connection_t,
                                  window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Changes a client's save set
 *
 * @param c The connection
 * @param mode A bitmask of #xcb_set_mode_t values.
 * @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.
 * @param window The window to add or delete to/from your save set.
 * @return A cookie
 *
 * TODO: explain what the save set is for.
 *
 * This function either adds or removes the specified window to the client's (your
 * application's) save set.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_change_save_set_checked(c: *mut xcb_connection_t, mode: u8,
                                       window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Changes a client's save set
 *
 * @param c The connection
 * @param mode A bitmask of #xcb_set_mode_t values.
 * @param mode Insert to add the specified window to the save set or Delete to delete it from the save set.
 * @param window The window to add or delete to/from your save set.
 * @return A cookie
 *
 * TODO: explain what the save set is for.
 *
 * This function either adds or removes the specified window to the client's (your
 * application's) save set.
 *
 */
    pub fn xcb_change_save_set(c: *mut xcb_connection_t, mode: u8,
                               window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Reparents a window
 *
 * @param c The connection
 * @param window The window to reparent.
 * @param parent The new parent of the window.
 * @param x The X position of the window within its new parent.
 * @param y The Y position of the window within its new parent.
 * @return A cookie
 *
 * Makes the specified window a child of the specified parent window. If the
 * window is mapped, it will automatically be unmapped before reparenting and
 * re-mapped after reparenting. The window is placed in the stacking order on top
 * with respect to sibling windows.
 *
 * After reparenting, a ReparentNotify event is generated.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_reparent_window_checked(c: *mut xcb_connection_t,
                                       window: xcb_window_t,
                                       parent: xcb_window_t, x: i16, y: i16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Reparents a window
 *
 * @param c The connection
 * @param window The window to reparent.
 * @param parent The new parent of the window.
 * @param x The X position of the window within its new parent.
 * @param y The Y position of the window within its new parent.
 * @return A cookie
 *
 * Makes the specified window a child of the specified parent window. If the
 * window is mapped, it will automatically be unmapped before reparenting and
 * re-mapped after reparenting. The window is placed in the stacking order on top
 * with respect to sibling windows.
 *
 * After reparenting, a ReparentNotify event is generated.
 *
 */
    pub fn xcb_reparent_window(c: *mut xcb_connection_t, window: xcb_window_t,
                               parent: xcb_window_t, x: i16, y: i16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Makes a window visible
 *
 * @param c The connection
 * @param window The window to make visible.
 * @return A cookie
 *
 * Maps the specified window. This means making the window visible (as long as its
 * parent is visible).
 *
 * This MapWindow request will be translated to a MapRequest request if a window
 * manager is running. The window manager then decides to either map the window or
 * not. Set the override-redirect window attribute to true if you want to bypass
 * this mechanism.
 *
 * If the window manager decides to map the window (or if no window manager is
 * running), a MapNotify event is generated.
 *
 * If the window becomes viewable and no earlier contents for it are remembered,
 * the X server tiles the window with its background. If the window's background
 * is undefined, the existing screen contents are not altered, and the X server
 * generates zero or more Expose events.
 *
 * If the window type is InputOutput, an Expose event will be generated when the
 * window becomes visible. The normal response to an Expose event should be to
 * repaint the window.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_map_window_checked(c: *mut xcb_connection_t,
                                  window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Makes a window visible
 *
 * @param c The connection
 * @param window The window to make visible.
 * @return A cookie
 *
 * Maps the specified window. This means making the window visible (as long as its
 * parent is visible).
 *
 * This MapWindow request will be translated to a MapRequest request if a window
 * manager is running. The window manager then decides to either map the window or
 * not. Set the override-redirect window attribute to true if you want to bypass
 * this mechanism.
 *
 * If the window manager decides to map the window (or if no window manager is
 * running), a MapNotify event is generated.
 *
 * If the window becomes viewable and no earlier contents for it are remembered,
 * the X server tiles the window with its background. If the window's background
 * is undefined, the existing screen contents are not altered, and the X server
 * generates zero or more Expose events.
 *
 * If the window type is InputOutput, an Expose event will be generated when the
 * window becomes visible. The normal response to an Expose event should be to
 * repaint the window.
 *
 */
    pub fn xcb_map_window(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_map_subwindows_checked(c: *mut xcb_connection_t,
                                      window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_map_subwindows(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Makes a window invisible
 *
 * @param c The connection
 * @param window The window to make invisible.
 * @return A cookie
 *
 * Unmaps the specified window. This means making the window invisible (and all
 * its child windows).
 *
 * Unmapping a window leads to the `UnmapNotify` event being generated. Also,
 * `Expose` events are generated for formerly obscured windows.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_unmap_window_checked(c: *mut xcb_connection_t,
                                    window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Makes a window invisible
 *
 * @param c The connection
 * @param window The window to make invisible.
 * @return A cookie
 *
 * Unmaps the specified window. This means making the window invisible (and all
 * its child windows).
 *
 * Unmapping a window leads to the `UnmapNotify` event being generated. Also,
 * `Expose` events are generated for formerly obscured windows.
 *
 */
    pub fn xcb_unmap_window(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_unmap_subwindows_checked(c: *mut xcb_connection_t,
                                        window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_unmap_subwindows(c: *mut xcb_connection_t,
                                window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Configures window attributes
 *
 * @param c The connection
 * @param window The window to configure.
 * @param value_mask Bitmask of attributes to change.
 * @param value_list New values, corresponding to the attributes in value_mask. The order has to
 * correspond to the order of possible \a value_mask bits. See the example.
 * @return A cookie
 *
 * Configures a window's size, position, border width and stacking order.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_configure_window_checked(c: *mut xcb_connection_t,
                                        window: xcb_window_t, value_mask: u16,
                                        value_list: *const u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Configures window attributes
 *
 * @param c The connection
 * @param window The window to configure.
 * @param value_mask Bitmask of attributes to change.
 * @param value_list New values, corresponding to the attributes in value_mask. The order has to
 * correspond to the order of possible \a value_mask bits. See the example.
 * @return A cookie
 *
 * Configures a window's size, position, border width and stacking order.
 *
 */
    pub fn xcb_configure_window(c: *mut xcb_connection_t,
                                window: xcb_window_t, value_mask: u16,
                                value_list: *const u32) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Change window stacking order
 *
 * @param c The connection
 * @param direction A bitmask of #xcb_circulate_t values.
 * @param direction \n
 * @param window The window to raise/lower (depending on \a direction).
 * @return A cookie
 *
 * If \a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if
 * any) will be raised to the top of the stack.
 *
 * If \a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will
 * be lowered to the bottom of the stack.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_circulate_window_checked(c: *mut xcb_connection_t,
                                        direction: u8, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Change window stacking order
 *
 * @param c The connection
 * @param direction A bitmask of #xcb_circulate_t values.
 * @param direction \n
 * @param window The window to raise/lower (depending on \a direction).
 * @return A cookie
 *
 * If \a direction is `XCB_CIRCULATE_RAISE_LOWEST`, the lowest mapped child (if
 * any) will be raised to the top of the stack.
 *
 * If \a direction is `XCB_CIRCULATE_LOWER_HIGHEST`, the highest mapped child will
 * be lowered to the bottom of the stack.
 *
 */
    pub fn xcb_circulate_window(c: *mut xcb_connection_t, direction: u8,
                                window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Get current window geometry
 *
 * @param c The connection
 * @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.
 * @return A cookie
 *
 * Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).
 *
 */
    pub fn xcb_get_geometry(c: *mut xcb_connection_t,
                            drawable: xcb_drawable_t)
     -> xcb_get_geometry_cookie_t;
}
extern "C" {
    /**
 * @brief Get current window geometry
 *
 * @param c The connection
 * @param drawable The drawable (`Window` or `Pixmap`) of which the geometry will be received.
 * @return A cookie
 *
 * Gets the current geometry of the specified drawable (either `Window` or `Pixmap`).
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_geometry_unchecked(c: *mut xcb_connection_t,
                                      drawable: xcb_drawable_t)
     -> xcb_get_geometry_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_geometry_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_geometry_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_get_geometry_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_geometry_reply_t;
}
extern "C" {
    pub fn xcb_query_tree_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief query the window tree
 *
 * @param c The connection
 * @param window The \a window to query.
 * @return A cookie
 *
 * Gets the root window ID, parent window ID and list of children windows for the
 * specified \a window. The children are listed in bottom-to-top stacking order.
 *
 */
    pub fn xcb_query_tree(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_query_tree_cookie_t;
}
extern "C" {
    /**
 * @brief query the window tree
 *
 * @param c The connection
 * @param window The \a window to query.
 * @return A cookie
 *
 * Gets the root window ID, parent window ID and list of children windows for the
 * specified \a window. The children are listed in bottom-to-top stacking order.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_query_tree_unchecked(c: *mut xcb_connection_t,
                                    window: xcb_window_t)
     -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_children(R: *const xcb_query_tree_reply_t)
     -> *mut xcb_window_t;
}
extern "C" {
    pub fn xcb_query_tree_children_length(R: *const xcb_query_tree_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_tree_children_end(R: *const xcb_query_tree_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_query_tree_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_query_tree_reply(c: *mut xcb_connection_t,
                                cookie: xcb_query_tree_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_tree_reply_t;
}
extern "C" {
    pub fn xcb_intern_atom_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Get atom identifier by name
 *
 * @param c The connection
 * @param only_if_exists Return a valid atom id only if the atom already exists.
 * @param name_len The length of the following \a name.
 * @param name The name of the atom.
 * @return A cookie
 *
 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified
 * name. Atoms are used in protocols like EWMH, for example to store window titles
 * (`_NET_WM_NAME` atom) as property of a window.
 *
 * If \a only_if_exists is 0, the atom will be created if it does not already exist.
 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does
 * not yet exist.
 *
 */
    pub fn xcb_intern_atom(c: *mut xcb_connection_t, only_if_exists: u8,
                           name_len: u16, name: *const ::std::os::raw::c_char)
     -> xcb_intern_atom_cookie_t;
}
extern "C" {
    /**
 * @brief Get atom identifier by name
 *
 * @param c The connection
 * @param only_if_exists Return a valid atom id only if the atom already exists.
 * @param name_len The length of the following \a name.
 * @param name The name of the atom.
 * @return A cookie
 *
 * Retrieves the identifier (xcb_atom_t TODO) for the atom with the specified
 * name. Atoms are used in protocols like EWMH, for example to store window titles
 * (`_NET_WM_NAME` atom) as property of a window.
 *
 * If \a only_if_exists is 0, the atom will be created if it does not already exist.
 * If \a only_if_exists is 1, `XCB_ATOM_NONE` will be returned if the atom does
 * not yet exist.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_intern_atom_unchecked(c: *mut xcb_connection_t,
                                     only_if_exists: u8, name_len: u16,
                                     name: *const ::std::os::raw::c_char)
     -> xcb_intern_atom_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_intern_atom_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_intern_atom_reply(c: *mut xcb_connection_t,
                                 cookie: xcb_intern_atom_cookie_t,
                                 e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_intern_atom_reply_t;
}
extern "C" {
    pub fn xcb_get_atom_name_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_get_atom_name(c: *mut xcb_connection_t, atom: xcb_atom_t)
     -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_atom_name_unchecked(c: *mut xcb_connection_t,
                                       atom: xcb_atom_t)
     -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_name(R: *const xcb_get_atom_name_reply_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_get_atom_name_name_length(R: *const xcb_get_atom_name_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name_name_end(R: *const xcb_get_atom_name_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_atom_name_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_atom_name_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_get_atom_name_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_atom_name_reply_t;
}
extern "C" {
    pub fn xcb_change_property_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Changes a window property
 *
 * @param c The connection
 * @param mode A bitmask of #xcb_prop_mode_t values.
 * @param mode \n
 * @param window The window whose property you want to change.
 * @param property The property you want to change (an atom).
 * @param type The type of the property you want to change (an atom).
 * @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or
 * 32-bit quantities. Possible values are 8, 16 and 32. This information allows
 * the X server to correctly perform byte-swap operations as necessary.
 * @param data_len Specifies the number of elements (see \a format).
 * @param data The property data.
 * @return A cookie
 *
 * Sets or updates a property on the specified \a window. Properties are for
 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).
 * Protocols such as EWMH also use properties - for example EWMH defines the
 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_change_property_checked(c: *mut xcb_connection_t, mode: u8,
                                       window: xcb_window_t,
                                       property: xcb_atom_t,
                                       type_: xcb_atom_t, format: u8,
                                       data_len: u32,
                                       data: *const ::std::os::raw::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Changes a window property
 *
 * @param c The connection
 * @param mode A bitmask of #xcb_prop_mode_t values.
 * @param mode \n
 * @param window The window whose property you want to change.
 * @param property The property you want to change (an atom).
 * @param type The type of the property you want to change (an atom).
 * @param format Specifies whether the data should be viewed as a list of 8-bit, 16-bit or
 * 32-bit quantities. Possible values are 8, 16 and 32. This information allows
 * the X server to correctly perform byte-swap operations as necessary.
 * @param data_len Specifies the number of elements (see \a format).
 * @param data The property data.
 * @return A cookie
 *
 * Sets or updates a property on the specified \a window. Properties are for
 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).
 * Protocols such as EWMH also use properties - for example EWMH defines the
 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.
 *
 */
    pub fn xcb_change_property(c: *mut xcb_connection_t, mode: u8,
                               window: xcb_window_t, property: xcb_atom_t,
                               type_: xcb_atom_t, format: u8, data_len: u32,
                               data: *const ::std::os::raw::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_delete_property_checked(c: *mut xcb_connection_t,
                                       window: xcb_window_t,
                                       property: xcb_atom_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_delete_property(c: *mut xcb_connection_t, window: xcb_window_t,
                               property: xcb_atom_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Gets a window property
 *
 * @param c The connection
 * @param _delete Whether the property should actually be deleted. For deleting a property, the
 * specified \a type has to match the actual property type.
 * @param window The window whose property you want to get.
 * @param property The property you want to get (an atom).
 * @param type The type of the property you want to get (an atom).
 * @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the
 * data is to be retrieved.
 * @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you
 * set \a long_length to 4, you will receive 16 bytes of data).
 * @return A cookie
 *
 * Gets the specified \a property from the specified \a window. Properties are for
 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).
 * Protocols such as EWMH also use properties - for example EWMH defines the
 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.
 *
 * TODO: talk about \a type
 *
 * TODO: talk about `delete`
 *
 * TODO: talk about the offset/length thing. what's a valid use case?
 *
 */
    pub fn xcb_get_property(c: *mut xcb_connection_t, _delete: u8,
                            window: xcb_window_t, property: xcb_atom_t,
                            type_: xcb_atom_t, long_offset: u32,
                            long_length: u32) -> xcb_get_property_cookie_t;
}
extern "C" {
    /**
 * @brief Gets a window property
 *
 * @param c The connection
 * @param _delete Whether the property should actually be deleted. For deleting a property, the
 * specified \a type has to match the actual property type.
 * @param window The window whose property you want to get.
 * @param property The property you want to get (an atom).
 * @param type The type of the property you want to get (an atom).
 * @param long_offset Specifies the offset (in 32-bit multiples) in the specified property where the
 * data is to be retrieved.
 * @param long_length Specifies how many 32-bit multiples of data should be retrieved (e.g. if you
 * set \a long_length to 4, you will receive 16 bytes of data).
 * @return A cookie
 *
 * Gets the specified \a property from the specified \a window. Properties are for
 * example the window title (`WM_NAME`) or its minimum size (`WM_NORMAL_HINTS`).
 * Protocols such as EWMH also use properties - for example EWMH defines the
 * window title, encoded as UTF-8 string, in the `_NET_WM_NAME` property.
 *
 * TODO: talk about \a type
 *
 * TODO: talk about `delete`
 *
 * TODO: talk about the offset/length thing. what's a valid use case?
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_property_unchecked(c: *mut xcb_connection_t, _delete: u8,
                                      window: xcb_window_t,
                                      property: xcb_atom_t, type_: xcb_atom_t,
                                      long_offset: u32, long_length: u32)
     -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_value(R: *const xcb_get_property_reply_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xcb_get_property_value_length(R: *const xcb_get_property_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_property_value_end(R: *const xcb_get_property_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_property_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_property_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_get_property_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_property_reply_t;
}
extern "C" {
    pub fn xcb_list_properties_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_list_properties(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_list_properties_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_list_properties_unchecked(c: *mut xcb_connection_t,
                                         window: xcb_window_t)
     -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms(R: *const xcb_list_properties_reply_t)
     -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms_length(R:
                                                *const xcb_list_properties_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_properties_atoms_end(R:
                                             *const xcb_list_properties_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_list_properties_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_list_properties_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_list_properties_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_properties_reply_t;
}
extern "C" {
    /**
 * @brief Sets the owner of a selection
 *
 * @param c The connection
 * @param owner The new owner of the selection.
 * \n
 * The special value `XCB_NONE` means that the selection will have no owner.
 * @param selection The selection.
 * @param time Timestamp to avoid race conditions when running X over the network.
 * \n
 * The selection will not be changed if \a time is earlier than the current
 * last-change time of the \a selection or is later than the current X server time.
 * Otherwise, the last-change time is set to the specified time.
 * \n
 * The special value `XCB_CURRENT_TIME` will be replaced with the current server
 * time.
 * @return A cookie
 *
 * Makes `window` the owner of the selection \a selection and updates the
 * last-change time of the specified selection.
 *
 * TODO: briefly explain what a selection is.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_set_selection_owner_checked(c: *mut xcb_connection_t,
                                           owner: xcb_window_t,
                                           selection: xcb_atom_t,
                                           time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Sets the owner of a selection
 *
 * @param c The connection
 * @param owner The new owner of the selection.
 * \n
 * The special value `XCB_NONE` means that the selection will have no owner.
 * @param selection The selection.
 * @param time Timestamp to avoid race conditions when running X over the network.
 * \n
 * The selection will not be changed if \a time is earlier than the current
 * last-change time of the \a selection or is later than the current X server time.
 * Otherwise, the last-change time is set to the specified time.
 * \n
 * The special value `XCB_CURRENT_TIME` will be replaced with the current server
 * time.
 * @return A cookie
 *
 * Makes `window` the owner of the selection \a selection and updates the
 * last-change time of the specified selection.
 *
 * TODO: briefly explain what a selection is.
 *
 */
    pub fn xcb_set_selection_owner(c: *mut xcb_connection_t,
                                   owner: xcb_window_t, selection: xcb_atom_t,
                                   time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Gets the owner of a selection
 *
 * @param c The connection
 * @param selection The selection.
 * @return A cookie
 *
 * Gets the owner of the specified selection.
 *
 * TODO: briefly explain what a selection is.
 *
 */
    pub fn xcb_get_selection_owner(c: *mut xcb_connection_t,
                                   selection: xcb_atom_t)
     -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    /**
 * @brief Gets the owner of a selection
 *
 * @param c The connection
 * @param selection The selection.
 * @return A cookie
 *
 * Gets the owner of the specified selection.
 *
 * TODO: briefly explain what a selection is.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_selection_owner_unchecked(c: *mut xcb_connection_t,
                                             selection: xcb_atom_t)
     -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_selection_owner_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_selection_owner_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_get_selection_owner_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_selection_owner_reply_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_convert_selection_checked(c: *mut xcb_connection_t,
                                         requestor: xcb_window_t,
                                         selection: xcb_atom_t,
                                         target: xcb_atom_t,
                                         property: xcb_atom_t,
                                         time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_convert_selection(c: *mut xcb_connection_t,
                                 requestor: xcb_window_t,
                                 selection: xcb_atom_t, target: xcb_atom_t,
                                 property: xcb_atom_t, time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief send an event
 *
 * @param c The connection
 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,
 * the destination is replaced with the closest ancestor of \a destination for
 * which some client has selected a type in \a event_mask and for which no
 * intervening window has that type in its do-not-propagate-mask. If no such
 * window exists or if the window is an ancestor of the focus window and
 * `InputFocus` was originally specified as the destination, the event is not sent
 * to any clients. Otherwise, the event is reported to every client selecting on
 * the final destination any of the types specified in \a event_mask.
 * @param destination The window to send this event to. Every client which selects any event within
 * \a event_mask on \a destination will get the event.
 * \n
 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window
 * that contains the mouse pointer.
 * \n
 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which
 * has the keyboard focus.
 * @param event_mask Event_mask for determining which clients should receive the specified event.
 * See \a destination and \a propagate.
 * @param event The event to send to the specified \a destination.
 * @return A cookie
 *
 * Identifies the \a destination window, determines which clients should receive
 * the specified event and ignores any active grabs.
 *
 * The \a event must be one of the core events or an event defined by an extension,
 * so that the X server can correctly byte-swap the contents as necessary. The
 * contents of \a event are otherwise unaltered and unchecked except for the
 * `send_event` field which is forced to 'true'.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_send_event_checked(c: *mut xcb_connection_t, propagate: u8,
                                  destination: xcb_window_t, event_mask: u32,
                                  event: *const ::std::os::raw::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief send an event
 *
 * @param c The connection
 * @param propagate If \a propagate is true and no clients have selected any event on \a destination,
 * the destination is replaced with the closest ancestor of \a destination for
 * which some client has selected a type in \a event_mask and for which no
 * intervening window has that type in its do-not-propagate-mask. If no such
 * window exists or if the window is an ancestor of the focus window and
 * `InputFocus` was originally specified as the destination, the event is not sent
 * to any clients. Otherwise, the event is reported to every client selecting on
 * the final destination any of the types specified in \a event_mask.
 * @param destination The window to send this event to. Every client which selects any event within
 * \a event_mask on \a destination will get the event.
 * \n
 * The special value `XCB_SEND_EVENT_DEST_POINTER_WINDOW` refers to the window
 * that contains the mouse pointer.
 * \n
 * The special value `XCB_SEND_EVENT_DEST_ITEM_FOCUS` refers to the window which
 * has the keyboard focus.
 * @param event_mask Event_mask for determining which clients should receive the specified event.
 * See \a destination and \a propagate.
 * @param event The event to send to the specified \a destination.
 * @return A cookie
 *
 * Identifies the \a destination window, determines which clients should receive
 * the specified event and ignores any active grabs.
 *
 * The \a event must be one of the core events or an event defined by an extension,
 * so that the X server can correctly byte-swap the contents as necessary. The
 * contents of \a event are otherwise unaltered and unchecked except for the
 * `send_event` field which is forced to 'true'.
 *
 */
    pub fn xcb_send_event(c: *mut xcb_connection_t, propagate: u8,
                          destination: xcb_window_t, event_mask: u32,
                          event: *const ::std::os::raw::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Grab the pointer
 *
 * @param c The connection
 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not
 * reported to the \a grab_window.
 * @param grab_window Specifies the window on which the pointer should be grabbed.
 * @param event_mask Specifies which pointer events are reported to the client.
 * \n
 * TODO: which values?
 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.
 * @param pointer_mode \n
 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.
 * @param keyboard_mode \n
 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to
 * move the pointer out of that window).
 * \n
 * The special value `XCB_NONE` means don't confine the pointer.
 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the
 * cursor.
 * @param time The time argument allows you to avoid certain circumstances that come up if
 * applications take a long time to respond or if there are long network delays.
 * Consider a situation where you have two applications, both of which normally
 * grab the pointer when clicked on. If both applications specify the timestamp
 * from the event, the second application may wake up faster and successfully grab
 * the pointer before the first application. The first application then will get
 * an indication that the other application grabbed the pointer before its request
 * was processed.
 * \n
 * The special value `XCB_CURRENT_TIME` will be replaced with the current server
 * time.
 * @return A cookie
 *
 * Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.
 *
 */
    pub fn xcb_grab_pointer(c: *mut xcb_connection_t, owner_events: u8,
                            grab_window: xcb_window_t, event_mask: u16,
                            pointer_mode: u8, keyboard_mode: u8,
                            confine_to: xcb_window_t, cursor: xcb_cursor_t,
                            time: xcb_timestamp_t)
     -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    /**
 * @brief Grab the pointer
 *
 * @param c The connection
 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not
 * reported to the \a grab_window.
 * @param grab_window Specifies the window on which the pointer should be grabbed.
 * @param event_mask Specifies which pointer events are reported to the client.
 * \n
 * TODO: which values?
 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.
 * @param pointer_mode \n
 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.
 * @param keyboard_mode \n
 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to
 * move the pointer out of that window).
 * \n
 * The special value `XCB_NONE` means don't confine the pointer.
 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the
 * cursor.
 * @param time The time argument allows you to avoid certain circumstances that come up if
 * applications take a long time to respond or if there are long network delays.
 * Consider a situation where you have two applications, both of which normally
 * grab the pointer when clicked on. If both applications specify the timestamp
 * from the event, the second application may wake up faster and successfully grab
 * the pointer before the first application. The first application then will get
 * an indication that the other application grabbed the pointer before its request
 * was processed.
 * \n
 * The special value `XCB_CURRENT_TIME` will be replaced with the current server
 * time.
 * @return A cookie
 *
 * Actively grabs control of the pointer. Further pointer events are reported only to the grabbing client. Overrides any active pointer grab by this client.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_grab_pointer_unchecked(c: *mut xcb_connection_t,
                                      owner_events: u8,
                                      grab_window: xcb_window_t,
                                      event_mask: u16, pointer_mode: u8,
                                      keyboard_mode: u8,
                                      confine_to: xcb_window_t,
                                      cursor: xcb_cursor_t,
                                      time: xcb_timestamp_t)
     -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_grab_pointer_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_grab_pointer_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_grab_pointer_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_grab_pointer_reply_t;
}
extern "C" {
    /**
 * @brief release the pointer
 *
 * @param c The connection
 * @param time Timestamp to avoid race conditions when running X over the network.
 * \n
 * The pointer will not be released if \a time is earlier than the
 * last-pointer-grab time or later than the current X server time.
 * @return A cookie
 *
 * Releases the pointer and any queued events if you actively grabbed the pointer
 * before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button
 * press.
 *
 * EnterNotify and LeaveNotify events are generated.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_ungrab_pointer_checked(c: *mut xcb_connection_t,
                                      time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief release the pointer
 *
 * @param c The connection
 * @param time Timestamp to avoid race conditions when running X over the network.
 * \n
 * The pointer will not be released if \a time is earlier than the
 * last-pointer-grab time or later than the current X server time.
 * @return A cookie
 *
 * Releases the pointer and any queued events if you actively grabbed the pointer
 * before using `xcb_grab_pointer`, `xcb_grab_button` or within a normal button
 * press.
 *
 * EnterNotify and LeaveNotify events are generated.
 *
 */
    pub fn xcb_ungrab_pointer(c: *mut xcb_connection_t, time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Grab pointer button(s)
 *
 * @param c The connection
 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not
 * reported to the \a grab_window.
 * @param grab_window Specifies the window on which the pointer should be grabbed.
 * @param event_mask Specifies which pointer events are reported to the client.
 * \n
 * TODO: which values?
 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.
 * @param pointer_mode \n
 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.
 * @param keyboard_mode \n
 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to
 * move the pointer out of that window).
 * \n
 * The special value `XCB_NONE` means don't confine the pointer.
 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the
 * cursor.
 * @param button A bitmask of #xcb_button_index_t values.
 * @param button \n
 * @param modifiers The modifiers to grab.
 * \n
 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all
 * possible modifier combinations.
 * @return A cookie
 *
 * This request establishes a passive grab. The pointer is actively grabbed as
 * described in GrabPointer, the last-pointer-grab time is set to the time at
 * which the button was pressed (as transmitted in the ButtonPress event), and the
 * ButtonPress event is reported if all of the following conditions are true:
 *
 * The pointer is not grabbed and the specified button is logically pressed when
 * the specified modifier keys are logically down, and no other buttons or
 * modifier keys are logically down.
 *
 * The grab-window contains the pointer.
 *
 * The confine-to window (if any) is viewable.
 *
 * A passive grab on the same button/key combination does not exist on any
 * ancestor of grab-window.
 *
 * The interpretation of the remaining arguments is the same as for GrabPointer.
 * The active grab is terminated automatically when the logical state of the
 * pointer has all buttons released, independent of the logical state of modifier
 * keys. Note that the logical state of a device (as seen by means of the
 * protocol) may lag the physical state if device event processing is frozen. This
 * request overrides all previous passive grabs by the same client on the same
 * button/key combinations on the same window. A modifier of AnyModifier is
 * equivalent to issuing the request for all possible modifier combinations
 * (including the combination of no modifiers). It is not required that all
 * specified modifiers have currently assigned keycodes. A button of AnyButton is
 * equivalent to issuing the request for all possible buttons. Otherwise, it is
 * not required that the button specified currently be assigned to a physical
 * button.
 *
 * An Access error is generated if some other client has already issued a
 * GrabButton request with the same button/key combination on the same window.
 * When using AnyModifier or AnyButton, the request fails completely (no grabs are
 * established), and an Access error is generated if there is a conflicting grab
 * for any combination. The request has no effect on an active grab.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_grab_button_checked(c: *mut xcb_connection_t, owner_events: u8,
                                   grab_window: xcb_window_t, event_mask: u16,
                                   pointer_mode: u8, keyboard_mode: u8,
                                   confine_to: xcb_window_t,
                                   cursor: xcb_cursor_t, button: u8,
                                   modifiers: u16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Grab pointer button(s)
 *
 * @param c The connection
 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not
 * reported to the \a grab_window.
 * @param grab_window Specifies the window on which the pointer should be grabbed.
 * @param event_mask Specifies which pointer events are reported to the client.
 * \n
 * TODO: which values?
 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.
 * @param pointer_mode \n
 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.
 * @param keyboard_mode \n
 * @param confine_to Specifies the window to confine the pointer in (the user will not be able to
 * move the pointer out of that window).
 * \n
 * The special value `XCB_NONE` means don't confine the pointer.
 * @param cursor Specifies the cursor that should be displayed or `XCB_NONE` to not change the
 * cursor.
 * @param button A bitmask of #xcb_button_index_t values.
 * @param button \n
 * @param modifiers The modifiers to grab.
 * \n
 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all
 * possible modifier combinations.
 * @return A cookie
 *
 * This request establishes a passive grab. The pointer is actively grabbed as
 * described in GrabPointer, the last-pointer-grab time is set to the time at
 * which the button was pressed (as transmitted in the ButtonPress event), and the
 * ButtonPress event is reported if all of the following conditions are true:
 *
 * The pointer is not grabbed and the specified button is logically pressed when
 * the specified modifier keys are logically down, and no other buttons or
 * modifier keys are logically down.
 *
 * The grab-window contains the pointer.
 *
 * The confine-to window (if any) is viewable.
 *
 * A passive grab on the same button/key combination does not exist on any
 * ancestor of grab-window.
 *
 * The interpretation of the remaining arguments is the same as for GrabPointer.
 * The active grab is terminated automatically when the logical state of the
 * pointer has all buttons released, independent of the logical state of modifier
 * keys. Note that the logical state of a device (as seen by means of the
 * protocol) may lag the physical state if device event processing is frozen. This
 * request overrides all previous passive grabs by the same client on the same
 * button/key combinations on the same window. A modifier of AnyModifier is
 * equivalent to issuing the request for all possible modifier combinations
 * (including the combination of no modifiers). It is not required that all
 * specified modifiers have currently assigned keycodes. A button of AnyButton is
 * equivalent to issuing the request for all possible buttons. Otherwise, it is
 * not required that the button specified currently be assigned to a physical
 * button.
 *
 * An Access error is generated if some other client has already issued a
 * GrabButton request with the same button/key combination on the same window.
 * When using AnyModifier or AnyButton, the request fails completely (no grabs are
 * established), and an Access error is generated if there is a conflicting grab
 * for any combination. The request has no effect on an active grab.
 *
 */
    pub fn xcb_grab_button(c: *mut xcb_connection_t, owner_events: u8,
                           grab_window: xcb_window_t, event_mask: u16,
                           pointer_mode: u8, keyboard_mode: u8,
                           confine_to: xcb_window_t, cursor: xcb_cursor_t,
                           button: u8, modifiers: u16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_ungrab_button_checked(c: *mut xcb_connection_t, button: u8,
                                     grab_window: xcb_window_t,
                                     modifiers: u16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_ungrab_button(c: *mut xcb_connection_t, button: u8,
                             grab_window: xcb_window_t, modifiers: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_change_active_pointer_grab_checked(c: *mut xcb_connection_t,
                                                  cursor: xcb_cursor_t,
                                                  time: xcb_timestamp_t,
                                                  event_mask: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_change_active_pointer_grab(c: *mut xcb_connection_t,
                                          cursor: xcb_cursor_t,
                                          time: xcb_timestamp_t,
                                          event_mask: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Grab the keyboard
 *
 * @param c The connection
 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not
 * reported to the \a grab_window.
 * @param grab_window Specifies the window on which the pointer should be grabbed.
 * @param time Timestamp to avoid race conditions when running X over the network.
 * \n
 * The special value `XCB_CURRENT_TIME` will be replaced with the current server
 * time.
 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.
 * @param pointer_mode \n
 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.
 * @param keyboard_mode \n
 * @return A cookie
 *
 * Actively grabs control of the keyboard and generates FocusIn and FocusOut
 * events. Further key events are reported only to the grabbing client.
 *
 * Any active keyboard grab by this client is overridden. If the keyboard is
 * actively grabbed by some other client, `AlreadyGrabbed` is returned. If
 * \a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard
 * is frozen by an active grab of another client, `GrabFrozen` is returned. If the
 * specified \a time is earlier than the last-keyboard-grab time or later than the
 * current X server time, `GrabInvalidTime` is returned. Otherwise, the
 * last-keyboard-grab time is set to the specified time.
 *
 */
    pub fn xcb_grab_keyboard(c: *mut xcb_connection_t, owner_events: u8,
                             grab_window: xcb_window_t, time: xcb_timestamp_t,
                             pointer_mode: u8, keyboard_mode: u8)
     -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    /**
 * @brief Grab the keyboard
 *
 * @param c The connection
 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not
 * reported to the \a grab_window.
 * @param grab_window Specifies the window on which the pointer should be grabbed.
 * @param time Timestamp to avoid race conditions when running X over the network.
 * \n
 * The special value `XCB_CURRENT_TIME` will be replaced with the current server
 * time.
 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.
 * @param pointer_mode \n
 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.
 * @param keyboard_mode \n
 * @return A cookie
 *
 * Actively grabs control of the keyboard and generates FocusIn and FocusOut
 * events. Further key events are reported only to the grabbing client.
 *
 * Any active keyboard grab by this client is overridden. If the keyboard is
 * actively grabbed by some other client, `AlreadyGrabbed` is returned. If
 * \a grab_window is not viewable, `GrabNotViewable` is returned. If the keyboard
 * is frozen by an active grab of another client, `GrabFrozen` is returned. If the
 * specified \a time is earlier than the last-keyboard-grab time or later than the
 * current X server time, `GrabInvalidTime` is returned. Otherwise, the
 * last-keyboard-grab time is set to the specified time.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_grab_keyboard_unchecked(c: *mut xcb_connection_t,
                                       owner_events: u8,
                                       grab_window: xcb_window_t,
                                       time: xcb_timestamp_t,
                                       pointer_mode: u8, keyboard_mode: u8)
     -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_grab_keyboard_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_grab_keyboard_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_grab_keyboard_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_grab_keyboard_reply_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_ungrab_keyboard_checked(c: *mut xcb_connection_t,
                                       time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_ungrab_keyboard(c: *mut xcb_connection_t,
                               time: xcb_timestamp_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Grab keyboard key(s)
 *
 * @param c The connection
 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not
 * reported to the \a grab_window.
 * @param grab_window Specifies the window on which the pointer should be grabbed.
 * @param modifiers The modifiers to grab.
 * \n
 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all
 * possible modifier combinations.
 * @param key The keycode of the key to grab.
 * \n
 * The special value `XCB_GRAB_ANY` means grab any key.
 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.
 * @param pointer_mode \n
 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.
 * @param keyboard_mode \n
 * @return A cookie
 *
 * Establishes a passive grab on the keyboard. In the future, the keyboard is
 * actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to
 * the time at which the key was pressed (as transmitted in the KeyPress event),
 * and the KeyPress event is reported if all of the following conditions are true:
 *
 * The keyboard is not grabbed and the specified key (which can itself be a
 * modifier key) is logically pressed when the specified modifier keys are
 * logically down, and no other modifier keys are logically down.
 *
 * Either the grab_window is an ancestor of (or is) the focus window, or the
 * grab_window is a descendant of the focus window and contains the pointer.
 *
 * A passive grab on the same key combination does not exist on any ancestor of
 * grab_window.
 *
 * The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated
 * automatically when the logical state of the keyboard has the specified key released (independent of the
 * logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.
 *
 * Note that the logical state of a device (as seen by client applications) may lag the physical state if
 * device event processing is frozen.
 *
 * A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified
 * have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for
 * all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode
 * and max_keycode in the connection setup, or a BadValue error results.
 *
 * If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess
 * error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error
 * results (no grabs are established) if there is a conflicting grab for any combination.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_grab_key_checked(c: *mut xcb_connection_t, owner_events: u8,
                                grab_window: xcb_window_t, modifiers: u16,
                                key: xcb_keycode_t, pointer_mode: u8,
                                keyboard_mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Grab keyboard key(s)
 *
 * @param c The connection
 * @param owner_events If 1, the \a grab_window will still get the pointer events. If 0, events are not
 * reported to the \a grab_window.
 * @param grab_window Specifies the window on which the pointer should be grabbed.
 * @param modifiers The modifiers to grab.
 * \n
 * Using the special value `XCB_MOD_MASK_ANY` means grab the pointer with all
 * possible modifier combinations.
 * @param key The keycode of the key to grab.
 * \n
 * The special value `XCB_GRAB_ANY` means grab any key.
 * @param pointer_mode A bitmask of #xcb_grab_mode_t values.
 * @param pointer_mode \n
 * @param keyboard_mode A bitmask of #xcb_grab_mode_t values.
 * @param keyboard_mode \n
 * @return A cookie
 *
 * Establishes a passive grab on the keyboard. In the future, the keyboard is
 * actively grabbed (as for `GrabKeyboard`), the last-keyboard-grab time is set to
 * the time at which the key was pressed (as transmitted in the KeyPress event),
 * and the KeyPress event is reported if all of the following conditions are true:
 *
 * The keyboard is not grabbed and the specified key (which can itself be a
 * modifier key) is logically pressed when the specified modifier keys are
 * logically down, and no other modifier keys are logically down.
 *
 * Either the grab_window is an ancestor of (or is) the focus window, or the
 * grab_window is a descendant of the focus window and contains the pointer.
 *
 * A passive grab on the same key combination does not exist on any ancestor of
 * grab_window.
 *
 * The interpretation of the remaining arguments is as for XGrabKeyboard.  The active grab is terminated
 * automatically when the logical state of the keyboard has the specified key released (independent of the
 * logical state of the modifier keys), at which point a KeyRelease event is reported to the grabbing window.
 *
 * Note that the logical state of a device (as seen by client applications) may lag the physical state if
 * device event processing is frozen.
 *
 * A modifiers argument of AnyModifier is equivalent to issuing the request for all possible modifier combinations (including the combination of no modifiers).  It is not required that all modifiers specified
 * have currently assigned KeyCodes.  A keycode argument of AnyKey is equivalent to issuing the request for
 * all possible KeyCodes.  Otherwise, the specified keycode must be in the range specified by min_keycode
 * and max_keycode in the connection setup, or a BadValue error results.
 *
 * If some other client has issued a XGrabKey with the same key combination on the same window, a BadAccess
 * error results.  When using AnyModifier or AnyKey, the request fails completely, and a BadAccess error
 * results (no grabs are established) if there is a conflicting grab for any combination.
 *
 */
    pub fn xcb_grab_key(c: *mut xcb_connection_t, owner_events: u8,
                        grab_window: xcb_window_t, modifiers: u16,
                        key: xcb_keycode_t, pointer_mode: u8,
                        keyboard_mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief release a key combination
 *
 * @param c The connection
 * @param key The keycode of the specified key combination.
 * \n
 * Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.
 * @param grab_window The window on which the grabbed key combination will be released.
 * @param modifiers The modifiers of the specified key combination.
 * \n
 * Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination
 * with every possible modifier combination.
 * @return A cookie
 *
 * Releases the key combination on \a grab_window if you grabbed it using
 * `xcb_grab_key` before.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_ungrab_key_checked(c: *mut xcb_connection_t,
                                  key: xcb_keycode_t,
                                  grab_window: xcb_window_t, modifiers: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief release a key combination
 *
 * @param c The connection
 * @param key The keycode of the specified key combination.
 * \n
 * Using the special value `XCB_GRAB_ANY` means releasing all possible key codes.
 * @param grab_window The window on which the grabbed key combination will be released.
 * @param modifiers The modifiers of the specified key combination.
 * \n
 * Using the special value `XCB_MOD_MASK_ANY` means releasing the key combination
 * with every possible modifier combination.
 * @return A cookie
 *
 * Releases the key combination on \a grab_window if you grabbed it using
 * `xcb_grab_key` before.
 *
 */
    pub fn xcb_ungrab_key(c: *mut xcb_connection_t, key: xcb_keycode_t,
                          grab_window: xcb_window_t, modifiers: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief release queued events
 *
 * @param c The connection
 * @param mode A bitmask of #xcb_allow_t values.
 * @param mode \n
 * @param time Timestamp to avoid race conditions when running X over the network.
 * \n
 * The special value `XCB_CURRENT_TIME` will be replaced with the current server
 * time.
 * @return A cookie
 *
 * Releases queued events if the client has caused a device (pointer/keyboard) to
 * freeze due to grabbing it actively. This request has no effect if \a time is
 * earlier than the last-grab time of the most recent active grab for this client
 * or if \a time is later than the current X server time.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_allow_events_checked(c: *mut xcb_connection_t, mode: u8,
                                    time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief release queued events
 *
 * @param c The connection
 * @param mode A bitmask of #xcb_allow_t values.
 * @param mode \n
 * @param time Timestamp to avoid race conditions when running X over the network.
 * \n
 * The special value `XCB_CURRENT_TIME` will be replaced with the current server
 * time.
 * @return A cookie
 *
 * Releases queued events if the client has caused a device (pointer/keyboard) to
 * freeze due to grabbing it actively. This request has no effect if \a time is
 * earlier than the last-grab time of the most recent active grab for this client
 * or if \a time is later than the current X server time.
 *
 */
    pub fn xcb_allow_events(c: *mut xcb_connection_t, mode: u8,
                            time: xcb_timestamp_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_grab_server_checked(c: *mut xcb_connection_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_grab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_ungrab_server_checked(c: *mut xcb_connection_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_ungrab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief get pointer coordinates
 *
 * @param c The connection
 * @param window A window to check if the pointer is on the same screen as \a window (see the
 * `same_screen` field in the reply).
 * @return A cookie
 *
 * Gets the root window the pointer is logically on and the pointer coordinates
 * relative to the root window's origin.
 *
 */
    pub fn xcb_query_pointer(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_query_pointer_cookie_t;
}
extern "C" {
    /**
 * @brief get pointer coordinates
 *
 * @param c The connection
 * @param window A window to check if the pointer is on the same screen as \a window (see the
 * `same_screen` field in the reply).
 * @return A cookie
 *
 * Gets the root window the pointer is logically on and the pointer coordinates
 * relative to the root window's origin.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_query_pointer_unchecked(c: *mut xcb_connection_t,
                                       window: xcb_window_t)
     -> xcb_query_pointer_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_query_pointer_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_query_pointer_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_query_pointer_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_pointer_reply_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_timecoord_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_timecoord_t)
 */
    pub fn xcb_timecoord_next(i: *mut xcb_timecoord_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_timecoord_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_timecoord_end(i: xcb_timecoord_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_sizeof(_buffer:
                                            *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_get_motion_events(c: *mut xcb_connection_t,
                                 window: xcb_window_t, start: xcb_timestamp_t,
                                 stop: xcb_timestamp_t)
     -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_motion_events_unchecked(c: *mut xcb_connection_t,
                                           window: xcb_window_t,
                                           start: xcb_timestamp_t,
                                           stop: xcb_timestamp_t)
     -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events(R:
                                            *const xcb_get_motion_events_reply_t)
     -> *mut xcb_timecoord_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events_length(R:
                                                   *const xcb_get_motion_events_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events_events_iterator(R:
                                                     *const xcb_get_motion_events_reply_t)
     -> xcb_timecoord_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_motion_events_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_motion_events_reply(c: *mut xcb_connection_t,
                                       cookie: xcb_get_motion_events_cookie_t,
                                       e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_motion_events_reply_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_translate_coordinates(c: *mut xcb_connection_t,
                                     src_window: xcb_window_t,
                                     dst_window: xcb_window_t, src_x: i16,
                                     src_y: i16)
     -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_translate_coordinates_unchecked(c: *mut xcb_connection_t,
                                               src_window: xcb_window_t,
                                               dst_window: xcb_window_t,
                                               src_x: i16, src_y: i16)
     -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_translate_coordinates_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_translate_coordinates_reply(c: *mut xcb_connection_t,
                                           cookie:
                                               xcb_translate_coordinates_cookie_t,
                                           e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_translate_coordinates_reply_t;
}
extern "C" {
    /**
 * @brief move mouse pointer
 *
 * @param c The connection
 * @param src_window If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the
 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,
 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to
 * \a src_window.
 * @param dst_window If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the
 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is
 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)
 * relative to the current position of the pointer.
 * @return A cookie
 *
 * Moves the mouse pointer to the specified position.
 *
 * If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the
 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,
 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to
 * \a src_window.
 *
 * If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the
 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is
 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)
 * relative to the current position of the pointer.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_warp_pointer_checked(c: *mut xcb_connection_t,
                                    src_window: xcb_window_t,
                                    dst_window: xcb_window_t, src_x: i16,
                                    src_y: i16, src_width: u16,
                                    src_height: u16, dst_x: i16, dst_y: i16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief move mouse pointer
 *
 * @param c The connection
 * @param src_window If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the
 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,
 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to
 * \a src_window.
 * @param dst_window If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the
 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is
 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)
 * relative to the current position of the pointer.
 * @return A cookie
 *
 * Moves the mouse pointer to the specified position.
 *
 * If \a src_window is not `XCB_NONE` (TODO), the move will only take place if the
 * pointer is inside \a src_window and within the rectangle specified by (\a src_x,
 * \a src_y, \a src_width, \a src_height). The rectangle coordinates are relative to
 * \a src_window.
 *
 * If \a dst_window is not `XCB_NONE` (TODO), the pointer will be moved to the
 * offsets (\a dst_x, \a dst_y) relative to \a dst_window. If \a dst_window is
 * `XCB_NONE` (TODO), the pointer will be moved by the offsets (\a dst_x, \a dst_y)
 * relative to the current position of the pointer.
 *
 */
    pub fn xcb_warp_pointer(c: *mut xcb_connection_t,
                            src_window: xcb_window_t,
                            dst_window: xcb_window_t, src_x: i16, src_y: i16,
                            src_width: u16, src_height: u16, dst_x: i16,
                            dst_y: i16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Sets input focus
 *
 * @param c The connection
 * @param revert_to A bitmask of #xcb_input_focus_t values.
 * @param revert_to Specifies what happens when the \a focus window becomes unviewable (if \a focus
 * is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).
 * @param focus The window to focus. All keyboard events will be reported to this window. The
 * window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).
 * \n
 * If \a focus is `XCB_NONE` (TODO), all keyboard events are
 * discarded until a new focus window is set.
 * \n
 * If \a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the
 * screen on which the pointer is on currently.
 * @param time Timestamp to avoid race conditions when running X over the network.
 * \n
 * The special value `XCB_CURRENT_TIME` will be replaced with the current server
 * time.
 * @return A cookie
 *
 * Changes the input focus and the last-focus-change time. If the specified \a time
 * is earlier than the current last-focus-change time, the request is ignored (to
 * avoid race conditions when running X over the network).
 *
 * A FocusIn and FocusOut event is generated when focus is changed.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_set_input_focus_checked(c: *mut xcb_connection_t,
                                       revert_to: u8, focus: xcb_window_t,
                                       time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Sets input focus
 *
 * @param c The connection
 * @param revert_to A bitmask of #xcb_input_focus_t values.
 * @param revert_to Specifies what happens when the \a focus window becomes unviewable (if \a focus
 * is neither `XCB_NONE` nor `XCB_POINTER_ROOT`).
 * @param focus The window to focus. All keyboard events will be reported to this window. The
 * window must be viewable (TODO), or a `xcb_match_error_t` occurs (TODO).
 * \n
 * If \a focus is `XCB_NONE` (TODO), all keyboard events are
 * discarded until a new focus window is set.
 * \n
 * If \a focus is `XCB_POINTER_ROOT` (TODO), focus is on the root window of the
 * screen on which the pointer is on currently.
 * @param time Timestamp to avoid race conditions when running X over the network.
 * \n
 * The special value `XCB_CURRENT_TIME` will be replaced with the current server
 * time.
 * @return A cookie
 *
 * Changes the input focus and the last-focus-change time. If the specified \a time
 * is earlier than the current last-focus-change time, the request is ignored (to
 * avoid race conditions when running X over the network).
 *
 * A FocusIn and FocusOut event is generated when focus is changed.
 *
 */
    pub fn xcb_set_input_focus(c: *mut xcb_connection_t, revert_to: u8,
                               focus: xcb_window_t, time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_get_input_focus(c: *mut xcb_connection_t)
     -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_input_focus_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_input_focus_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_input_focus_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_get_input_focus_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_input_focus_reply_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_query_keymap(c: *mut xcb_connection_t)
     -> xcb_query_keymap_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_query_keymap_unchecked(c: *mut xcb_connection_t)
     -> xcb_query_keymap_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_query_keymap_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_query_keymap_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_query_keymap_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_keymap_reply_t;
}
extern "C" {
    pub fn xcb_open_font_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief opens a font
 *
 * @param c The connection
 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.
 * @param name_len Length (in bytes) of \a name.
 * @param name A pattern describing an X core font.
 * @return A cookie
 *
 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").
 *
 * Note that X core fonts are deprecated (but still supported) in favor of
 * client-side rendering using Xft.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_open_font_checked(c: *mut xcb_connection_t, fid: xcb_font_t,
                                 name_len: u16,
                                 name: *const ::std::os::raw::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief opens a font
 *
 * @param c The connection
 * @param fid The ID with which you will refer to the font, created by `xcb_generate_id`.
 * @param name_len Length (in bytes) of \a name.
 * @param name A pattern describing an X core font.
 * @return A cookie
 *
 * Opens any X core font matching the given \a name (for example "-misc-fixed-*").
 *
 * Note that X core fonts are deprecated (but still supported) in favor of
 * client-side rendering using Xft.
 *
 */
    pub fn xcb_open_font(c: *mut xcb_connection_t, fid: xcb_font_t,
                         name_len: u16, name: *const ::std::os::raw::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_close_font_checked(c: *mut xcb_connection_t, font: xcb_font_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_close_font(c: *mut xcb_connection_t, font: xcb_font_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_fontprop_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_fontprop_t)
 */
    pub fn xcb_fontprop_next(i: *mut xcb_fontprop_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_fontprop_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_fontprop_end(i: xcb_fontprop_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_charinfo_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_charinfo_t)
 */
    pub fn xcb_charinfo_next(i: *mut xcb_charinfo_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_charinfo_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_charinfo_end(i: xcb_charinfo_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief query font metrics
 *
 * @param c The connection
 * @param font The fontable (Font or Graphics Context) to query.
 * @return A cookie
 *
 * Queries information associated with the font.
 *
 */
    pub fn xcb_query_font(c: *mut xcb_connection_t, font: xcb_fontable_t)
     -> xcb_query_font_cookie_t;
}
extern "C" {
    /**
 * @brief query font metrics
 *
 * @param c The connection
 * @param font The fontable (Font or Graphics Context) to query.
 * @return A cookie
 *
 * Queries information associated with the font.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_query_font_unchecked(c: *mut xcb_connection_t,
                                    font: xcb_fontable_t)
     -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_properties(R: *const xcb_query_font_reply_t)
     -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_query_font_properties_length(R: *const xcb_query_font_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_font_properties_iterator(R:
                                                  *const xcb_query_font_reply_t)
     -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos(R: *const xcb_query_font_reply_t)
     -> *mut xcb_charinfo_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos_length(R: *const xcb_query_font_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_font_char_infos_iterator(R:
                                                  *const xcb_query_font_reply_t)
     -> xcb_charinfo_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_query_font_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_query_font_reply(c: *mut xcb_connection_t,
                                cookie: xcb_query_font_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_font_reply_t;
}
extern "C" {
    pub fn xcb_query_text_extents_sizeof(_buffer:
                                             *const ::std::os::raw::c_void,
                                         string_len: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief get text extents
 *
 * @param c The connection
 * @param font The \a font to calculate text extents in. You can also pass a graphics context.
 * @param string_len The number of characters in \a string.
 * @param string The text to get text extents for.
 * @return A cookie
 *
 * Query text extents from the X11 server. This request returns the bounding box
 * of the specified 16-bit character string in the specified \a font or the font
 * contained in the specified graphics context.
 *
 * `font_ascent` is set to the maximum of the ascent metrics of all characters in
 * the string. `font_descent` is set to the maximum of the descent metrics.
 * `overall_width` is set to the sum of the character-width metrics of all
 * characters in the string. For each character in the string, let W be the sum of
 * the character-width metrics of all characters preceding it in the string. Let L
 * be the left-side-bearing metric of the character plus W. Let R be the
 * right-side-bearing metric of the character plus W. The lbearing member is set
 * to the minimum L of all characters in the string. The rbearing member is set to
 * the maximum R.
 *
 * For fonts defined with linear indexing rather than 2-byte matrix indexing, each
 * `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the
 * most significant byte. If the font has no defined default character, undefined
 * characters in the string are taken to have all zero metrics.
 *
 * Characters with all zero metrics are ignored. If the font has no defined
 * default_char, the undefined characters in the string are also ignored.
 *
 */
    pub fn xcb_query_text_extents(c: *mut xcb_connection_t,
                                  font: xcb_fontable_t, string_len: u32,
                                  string: *const xcb_char2b_t)
     -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    /**
 * @brief get text extents
 *
 * @param c The connection
 * @param font The \a font to calculate text extents in. You can also pass a graphics context.
 * @param string_len The number of characters in \a string.
 * @param string The text to get text extents for.
 * @return A cookie
 *
 * Query text extents from the X11 server. This request returns the bounding box
 * of the specified 16-bit character string in the specified \a font or the font
 * contained in the specified graphics context.
 *
 * `font_ascent` is set to the maximum of the ascent metrics of all characters in
 * the string. `font_descent` is set to the maximum of the descent metrics.
 * `overall_width` is set to the sum of the character-width metrics of all
 * characters in the string. For each character in the string, let W be the sum of
 * the character-width metrics of all characters preceding it in the string. Let L
 * be the left-side-bearing metric of the character plus W. Let R be the
 * right-side-bearing metric of the character plus W. The lbearing member is set
 * to the minimum L of all characters in the string. The rbearing member is set to
 * the maximum R.
 *
 * For fonts defined with linear indexing rather than 2-byte matrix indexing, each
 * `xcb_char2b_t` structure is interpreted as a 16-bit number with byte1 as the
 * most significant byte. If the font has no defined default character, undefined
 * characters in the string are taken to have all zero metrics.
 *
 * Characters with all zero metrics are ignored. If the font has no defined
 * default_char, the undefined characters in the string are also ignored.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_query_text_extents_unchecked(c: *mut xcb_connection_t,
                                            font: xcb_fontable_t,
                                            string_len: u32,
                                            string: *const xcb_char2b_t)
     -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_query_text_extents_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_query_text_extents_reply(c: *mut xcb_connection_t,
                                        cookie:
                                            xcb_query_text_extents_cookie_t,
                                        e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_text_extents_reply_t;
}
extern "C" {
    pub fn xcb_str_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_str_name(R: *const xcb_str_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_str_name_length(R: *const xcb_str_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_str_name_end(R: *const xcb_str_t) -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_str_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_str_t)
 */
    pub fn xcb_str_next(i: *mut xcb_str_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_str_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_str_end(i: xcb_str_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief get matching font names
 *
 * @param c The connection
 * @param max_names The maximum number of fonts to be returned.
 * @param pattern_len The length (in bytes) of \a pattern.
 * @param pattern A font pattern, for example "-misc-fixed-*".
 * \n
 * The asterisk (*) is a wildcard for any number of characters. The question mark
 * (?) is a wildcard for a single character. Use of uppercase or lowercase does
 * not matter.
 * @return A cookie
 *
 * Gets a list of available font names which match the given \a pattern.
 *
 */
    pub fn xcb_list_fonts(c: *mut xcb_connection_t, max_names: u16,
                          pattern_len: u16,
                          pattern: *const ::std::os::raw::c_char)
     -> xcb_list_fonts_cookie_t;
}
extern "C" {
    /**
 * @brief get matching font names
 *
 * @param c The connection
 * @param max_names The maximum number of fonts to be returned.
 * @param pattern_len The length (in bytes) of \a pattern.
 * @param pattern A font pattern, for example "-misc-fixed-*".
 * \n
 * The asterisk (*) is a wildcard for any number of characters. The question mark
 * (?) is a wildcard for a single character. Use of uppercase or lowercase does
 * not matter.
 * @return A cookie
 *
 * Gets a list of available font names which match the given \a pattern.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_list_fonts_unchecked(c: *mut xcb_connection_t, max_names: u16,
                                    pattern_len: u16,
                                    pattern: *const ::std::os::raw::c_char)
     -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_names_length(R: *const xcb_list_fonts_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_names_iterator(R: *const xcb_list_fonts_reply_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_list_fonts_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_list_fonts_reply(c: *mut xcb_connection_t,
                                cookie: xcb_list_fonts_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_fonts_reply_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_sizeof(_buffer:
                                               *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief get matching font names and information
 *
 * @param c The connection
 * @param max_names The maximum number of fonts to be returned.
 * @param pattern_len The length (in bytes) of \a pattern.
 * @param pattern A font pattern, for example "-misc-fixed-*".
 * \n
 * The asterisk (*) is a wildcard for any number of characters. The question mark
 * (?) is a wildcard for a single character. Use of uppercase or lowercase does
 * not matter.
 * @return A cookie
 *
 * Gets a list of available font names which match the given \a pattern.
 *
 */
    pub fn xcb_list_fonts_with_info(c: *mut xcb_connection_t, max_names: u16,
                                    pattern_len: u16,
                                    pattern: *const ::std::os::raw::c_char)
     -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    /**
 * @brief get matching font names and information
 *
 * @param c The connection
 * @param max_names The maximum number of fonts to be returned.
 * @param pattern_len The length (in bytes) of \a pattern.
 * @param pattern A font pattern, for example "-misc-fixed-*".
 * \n
 * The asterisk (*) is a wildcard for any number of characters. The question mark
 * (?) is a wildcard for a single character. Use of uppercase or lowercase does
 * not matter.
 * @return A cookie
 *
 * Gets a list of available font names which match the given \a pattern.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_list_fonts_with_info_unchecked(c: *mut xcb_connection_t,
                                              max_names: u16,
                                              pattern_len: u16,
                                              pattern:
                                                  *const ::std::os::raw::c_char)
     -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties(R:
                                                   *const xcb_list_fonts_with_info_reply_t)
     -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_length(R:
                                                          *const xcb_list_fonts_with_info_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_iterator(R:
                                                            *const xcb_list_fonts_with_info_reply_t)
     -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name(R:
                                             *const xcb_list_fonts_with_info_reply_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_length(R:
                                                    *const xcb_list_fonts_with_info_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_end(R:
                                                 *const xcb_list_fonts_with_info_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_list_fonts_with_info_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_list_fonts_with_info_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_list_fonts_with_info_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_fonts_with_info_reply_t;
}
extern "C" {
    pub fn xcb_set_font_path_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_set_font_path_checked(c: *mut xcb_connection_t, font_qty: u16,
                                     font: *const xcb_str_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_set_font_path(c: *mut xcb_connection_t, font_qty: u16,
                             font: *const xcb_str_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_get_font_path(c: *mut xcb_connection_t)
     -> xcb_get_font_path_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_font_path_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_path_length(R: *const xcb_get_font_path_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_font_path_path_iterator(R:
                                               *const xcb_get_font_path_reply_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_font_path_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_font_path_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_get_font_path_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_font_path_reply_t;
}
extern "C" {
    /**
 * @brief Creates a pixmap
 *
 * @param c The connection
 * @param depth TODO
 * @param pid The ID with which you will refer to the new pixmap, created by
 * `xcb_generate_id`.
 * @param drawable Drawable to get the screen from.
 * @param width The width of the new pixmap.
 * @param height The height of the new pixmap.
 * @return A cookie
 *
 * Creates a pixmap. The pixmap can only be used on the same screen as \a drawable
 * is on and only with drawables of the same \a depth.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_create_pixmap_checked(c: *mut xcb_connection_t, depth: u8,
                                     pid: xcb_pixmap_t,
                                     drawable: xcb_drawable_t, width: u16,
                                     height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Creates a pixmap
 *
 * @param c The connection
 * @param depth TODO
 * @param pid The ID with which you will refer to the new pixmap, created by
 * `xcb_generate_id`.
 * @param drawable Drawable to get the screen from.
 * @param width The width of the new pixmap.
 * @param height The height of the new pixmap.
 * @return A cookie
 *
 * Creates a pixmap. The pixmap can only be used on the same screen as \a drawable
 * is on and only with drawables of the same \a depth.
 *
 */
    pub fn xcb_create_pixmap(c: *mut xcb_connection_t, depth: u8,
                             pid: xcb_pixmap_t, drawable: xcb_drawable_t,
                             width: u16, height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Destroys a pixmap
 *
 * @param c The connection
 * @param pixmap The pixmap to destroy.
 * @return A cookie
 *
 * Deletes the association between the pixmap ID and the pixmap. The pixmap
 * storage will be freed when there are no more references to it.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_free_pixmap_checked(c: *mut xcb_connection_t,
                                   pixmap: xcb_pixmap_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Destroys a pixmap
 *
 * @param c The connection
 * @param pixmap The pixmap to destroy.
 * @return A cookie
 *
 * Deletes the association between the pixmap ID and the pixmap. The pixmap
 * storage will be freed when there are no more references to it.
 *
 */
    pub fn xcb_free_pixmap(c: *mut xcb_connection_t, pixmap: xcb_pixmap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Creates a graphics context
 *
 * @param c The connection
 * @param cid The ID with which you will refer to the graphics context, created by
 * `xcb_generate_id`.
 * @param drawable Drawable to get the root/depth from.
 * @return A cookie
 *
 * Creates a graphics context. The graphics context can be used with any drawable
 * that has the same root and depth as the specified drawable.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_create_gc_checked(c: *mut xcb_connection_t,
                                 cid: xcb_gcontext_t,
                                 drawable: xcb_drawable_t, value_mask: u32,
                                 value_list: *const u32) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Creates a graphics context
 *
 * @param c The connection
 * @param cid The ID with which you will refer to the graphics context, created by
 * `xcb_generate_id`.
 * @param drawable Drawable to get the root/depth from.
 * @return A cookie
 *
 * Creates a graphics context. The graphics context can be used with any drawable
 * that has the same root and depth as the specified drawable.
 *
 */
    pub fn xcb_create_gc(c: *mut xcb_connection_t, cid: xcb_gcontext_t,
                         drawable: xcb_drawable_t, value_mask: u32,
                         value_list: *const u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief change graphics context components
 *
 * @param c The connection
 * @param gc The graphics context to change.
 * @param value_mask A bitmask of #xcb_gc_t values.
 * @param value_mask \n
 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The
 * order has to correspond to the order of possible \a value_mask bits. See the
 * example.
 * @return A cookie
 *
 * Changes the components specified by \a value_mask for the specified graphics context.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_change_gc_checked(c: *mut xcb_connection_t, gc: xcb_gcontext_t,
                                 value_mask: u32, value_list: *const u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief change graphics context components
 *
 * @param c The connection
 * @param gc The graphics context to change.
 * @param value_mask A bitmask of #xcb_gc_t values.
 * @param value_mask \n
 * @param value_list Values for each of the components specified in the bitmask \a value_mask. The
 * order has to correspond to the order of possible \a value_mask bits. See the
 * example.
 * @return A cookie
 *
 * Changes the components specified by \a value_mask for the specified graphics context.
 *
 */
    pub fn xcb_change_gc(c: *mut xcb_connection_t, gc: xcb_gcontext_t,
                         value_mask: u32, value_list: *const u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_copy_gc_checked(c: *mut xcb_connection_t,
                               src_gc: xcb_gcontext_t, dst_gc: xcb_gcontext_t,
                               value_mask: u32) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_copy_gc(c: *mut xcb_connection_t, src_gc: xcb_gcontext_t,
                       dst_gc: xcb_gcontext_t, value_mask: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_set_dashes_checked(c: *mut xcb_connection_t,
                                  gc: xcb_gcontext_t, dash_offset: u16,
                                  dashes_len: u16, dashes: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_set_dashes(c: *mut xcb_connection_t, gc: xcb_gcontext_t,
                          dash_offset: u16, dashes_len: u16,
                          dashes: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_sizeof(_buffer:
                                              *const ::std::os::raw::c_void,
                                          rectangles_len: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_set_clip_rectangles_checked(c: *mut xcb_connection_t,
                                           ordering: u8, gc: xcb_gcontext_t,
                                           clip_x_origin: i16,
                                           clip_y_origin: i16,
                                           rectangles_len: u32,
                                           rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_set_clip_rectangles(c: *mut xcb_connection_t, ordering: u8,
                                   gc: xcb_gcontext_t, clip_x_origin: i16,
                                   clip_y_origin: i16, rectangles_len: u32,
                                   rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Destroys a graphics context
 *
 * @param c The connection
 * @param gc The graphics context to destroy.
 * @return A cookie
 *
 * Destroys the specified \a gc and all associated storage.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_free_gc_checked(c: *mut xcb_connection_t, gc: xcb_gcontext_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Destroys a graphics context
 *
 * @param c The connection
 * @param gc The graphics context to destroy.
 * @return A cookie
 *
 * Destroys the specified \a gc and all associated storage.
 *
 */
    pub fn xcb_free_gc(c: *mut xcb_connection_t, gc: xcb_gcontext_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_clear_area_checked(c: *mut xcb_connection_t, exposures: u8,
                                  window: xcb_window_t, x: i16, y: i16,
                                  width: u16, height: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_clear_area(c: *mut xcb_connection_t, exposures: u8,
                          window: xcb_window_t, x: i16, y: i16, width: u16,
                          height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief copy areas
 *
 * @param c The connection
 * @param src_drawable The source drawable (Window or Pixmap).
 * @param dst_drawable The destination drawable (Window or Pixmap).
 * @param gc The graphics context to use.
 * @param src_x The source X coordinate.
 * @param src_y The source Y coordinate.
 * @param dst_x The destination X coordinate.
 * @param dst_y The destination Y coordinate.
 * @param width The width of the area to copy (in pixels).
 * @param height The height of the area to copy (in pixels).
 * @return A cookie
 *
 * Copies the specified rectangle from \a src_drawable to \a dst_drawable.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_copy_area_checked(c: *mut xcb_connection_t,
                                 src_drawable: xcb_drawable_t,
                                 dst_drawable: xcb_drawable_t,
                                 gc: xcb_gcontext_t, src_x: i16, src_y: i16,
                                 dst_x: i16, dst_y: i16, width: u16,
                                 height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief copy areas
 *
 * @param c The connection
 * @param src_drawable The source drawable (Window or Pixmap).
 * @param dst_drawable The destination drawable (Window or Pixmap).
 * @param gc The graphics context to use.
 * @param src_x The source X coordinate.
 * @param src_y The source Y coordinate.
 * @param dst_x The destination X coordinate.
 * @param dst_y The destination Y coordinate.
 * @param width The width of the area to copy (in pixels).
 * @param height The height of the area to copy (in pixels).
 * @return A cookie
 *
 * Copies the specified rectangle from \a src_drawable to \a dst_drawable.
 *
 */
    pub fn xcb_copy_area(c: *mut xcb_connection_t,
                         src_drawable: xcb_drawable_t,
                         dst_drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                         src_x: i16, src_y: i16, dst_x: i16, dst_y: i16,
                         width: u16, height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_copy_plane_checked(c: *mut xcb_connection_t,
                                  src_drawable: xcb_drawable_t,
                                  dst_drawable: xcb_drawable_t,
                                  gc: xcb_gcontext_t, src_x: i16, src_y: i16,
                                  dst_x: i16, dst_y: i16, width: u16,
                                  height: u16, bit_plane: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_copy_plane(c: *mut xcb_connection_t,
                          src_drawable: xcb_drawable_t,
                          dst_drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                          src_x: i16, src_y: i16, dst_x: i16, dst_y: i16,
                          width: u16, height: u16, bit_plane: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_sizeof(_buffer: *const ::std::os::raw::c_void,
                                 points_len: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_poly_point_checked(c: *mut xcb_connection_t,
                                  coordinate_mode: u8,
                                  drawable: xcb_drawable_t,
                                  gc: xcb_gcontext_t, points_len: u32,
                                  points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_poly_point(c: *mut xcb_connection_t, coordinate_mode: u8,
                          drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                          points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line_sizeof(_buffer: *const ::std::os::raw::c_void,
                                points_len: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief draw lines
 *
 * @param c The connection
 * @param coordinate_mode A bitmask of #xcb_coord_mode_t values.
 * @param coordinate_mode \n
 * @param drawable The drawable to draw the line(s) on.
 * @param gc The graphics context to use.
 * @param points_len The number of `xcb_point_t` structures in \a points.
 * @param points An array of points.
 * @return A cookie
 *
 * Draws \a points_len-1 lines between each pair of points (point[i], point[i+1])
 * in the \a points array. The lines are drawn in the order listed in the array.
 * They join correctly at all intermediate points, and if the first and last
 * points coincide, the first and last lines also join correctly. For any given
 * line, a pixel is not drawn more than once. If thin (zero line-width) lines
 * intersect, the intersecting pixels are drawn multiple times. If wide lines
 * intersect, the intersecting pixels are drawn only once, as though the entire
 * request were a single, filled shape.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_poly_line_checked(c: *mut xcb_connection_t,
                                 coordinate_mode: u8,
                                 drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                 points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief draw lines
 *
 * @param c The connection
 * @param coordinate_mode A bitmask of #xcb_coord_mode_t values.
 * @param coordinate_mode \n
 * @param drawable The drawable to draw the line(s) on.
 * @param gc The graphics context to use.
 * @param points_len The number of `xcb_point_t` structures in \a points.
 * @param points An array of points.
 * @return A cookie
 *
 * Draws \a points_len-1 lines between each pair of points (point[i], point[i+1])
 * in the \a points array. The lines are drawn in the order listed in the array.
 * They join correctly at all intermediate points, and if the first and last
 * points coincide, the first and last lines also join correctly. For any given
 * line, a pixel is not drawn more than once. If thin (zero line-width) lines
 * intersect, the intersecting pixels are drawn multiple times. If wide lines
 * intersect, the intersecting pixels are drawn only once, as though the entire
 * request were a single, filled shape.
 *
 */
    pub fn xcb_poly_line(c: *mut xcb_connection_t, coordinate_mode: u8,
                         drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                         points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_segment_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_segment_t)
 */
    pub fn xcb_segment_next(i: *mut xcb_segment_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_segment_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_segment_end(i: xcb_segment_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_segment_sizeof(_buffer: *const ::std::os::raw::c_void,
                                   segments_len: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief draw lines
 *
 * @param c The connection
 * @param drawable A drawable (Window or Pixmap) to draw on.
 * @param gc The graphics context to use.
 * \n
 * TODO: document which attributes of a gc are used
 * @param segments_len The number of `xcb_segment_t` structures in \a segments.
 * @param segments An array of `xcb_segment_t` structures.
 * @return A cookie
 *
 * Draws multiple, unconnected lines. For each segment, a line is drawn between
 * (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of
 * `xcb_segment_t` structures and does not perform joining at coincident
 * endpoints. For any given line, a pixel is not drawn more than once. If lines
 * intersect, the intersecting pixels are drawn multiple times.
 *
 * TODO: include the xcb_segment_t data structure
 *
 * TODO: an example
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_poly_segment_checked(c: *mut xcb_connection_t,
                                    drawable: xcb_drawable_t,
                                    gc: xcb_gcontext_t, segments_len: u32,
                                    segments: *const xcb_segment_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief draw lines
 *
 * @param c The connection
 * @param drawable A drawable (Window or Pixmap) to draw on.
 * @param gc The graphics context to use.
 * \n
 * TODO: document which attributes of a gc are used
 * @param segments_len The number of `xcb_segment_t` structures in \a segments.
 * @param segments An array of `xcb_segment_t` structures.
 * @return A cookie
 *
 * Draws multiple, unconnected lines. For each segment, a line is drawn between
 * (x1, y1) and (x2, y2). The lines are drawn in the order listed in the array of
 * `xcb_segment_t` structures and does not perform joining at coincident
 * endpoints. For any given line, a pixel is not drawn more than once. If lines
 * intersect, the intersecting pixels are drawn multiple times.
 *
 * TODO: include the xcb_segment_t data structure
 *
 * TODO: an example
 *
 */
    pub fn xcb_poly_segment(c: *mut xcb_connection_t,
                            drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                            segments_len: u32, segments: *const xcb_segment_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_sizeof(_buffer: *const ::std::os::raw::c_void,
                                     rectangles_len: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_poly_rectangle_checked(c: *mut xcb_connection_t,
                                      drawable: xcb_drawable_t,
                                      gc: xcb_gcontext_t, rectangles_len: u32,
                                      rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_poly_rectangle(c: *mut xcb_connection_t,
                              drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                              rectangles_len: u32,
                              rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc_sizeof(_buffer: *const ::std::os::raw::c_void,
                               arcs_len: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_poly_arc_checked(c: *mut xcb_connection_t,
                                drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                arcs_len: u32, arcs: *const xcb_arc_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_poly_arc(c: *mut xcb_connection_t, drawable: xcb_drawable_t,
                        gc: xcb_gcontext_t, arcs_len: u32,
                        arcs: *const xcb_arc_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly_sizeof(_buffer: *const ::std::os::raw::c_void,
                                points_len: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_fill_poly_checked(c: *mut xcb_connection_t,
                                 drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                 shape: u8, coordinate_mode: u8,
                                 points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_fill_poly(c: *mut xcb_connection_t, drawable: xcb_drawable_t,
                         gc: xcb_gcontext_t, shape: u8, coordinate_mode: u8,
                         points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_sizeof(_buffer:
                                              *const ::std::os::raw::c_void,
                                          rectangles_len: u32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Fills rectangles
 *
 * @param c The connection
 * @param drawable The drawable (Window or Pixmap) to draw on.
 * @param gc The graphics context to use.
 * \n
 * The following graphics context components are used: function, plane-mask,
 * fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.
 * \n
 * The following graphics context mode-dependent components are used:
 * foreground, background, tile, stipple, tile-stipple-x-origin, and
 * tile-stipple-y-origin.
 * @param rectangles_len The number of `xcb_rectangle_t` structures in \a rectangles.
 * @param rectangles The rectangles to fill.
 * @return A cookie
 *
 * Fills the specified rectangle(s) in the order listed in the array. For any
 * given rectangle, each pixel is not drawn more than once. If rectangles
 * intersect, the intersecting pixels are drawn multiple times.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_poly_fill_rectangle_checked(c: *mut xcb_connection_t,
                                           drawable: xcb_drawable_t,
                                           gc: xcb_gcontext_t,
                                           rectangles_len: u32,
                                           rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Fills rectangles
 *
 * @param c The connection
 * @param drawable The drawable (Window or Pixmap) to draw on.
 * @param gc The graphics context to use.
 * \n
 * The following graphics context components are used: function, plane-mask,
 * fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.
 * \n
 * The following graphics context mode-dependent components are used:
 * foreground, background, tile, stipple, tile-stipple-x-origin, and
 * tile-stipple-y-origin.
 * @param rectangles_len The number of `xcb_rectangle_t` structures in \a rectangles.
 * @param rectangles The rectangles to fill.
 * @return A cookie
 *
 * Fills the specified rectangle(s) in the order listed in the array. For any
 * given rectangle, each pixel is not drawn more than once. If rectangles
 * intersect, the intersecting pixels are drawn multiple times.
 *
 */
    pub fn xcb_poly_fill_rectangle(c: *mut xcb_connection_t,
                                   drawable: xcb_drawable_t,
                                   gc: xcb_gcontext_t, rectangles_len: u32,
                                   rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_sizeof(_buffer: *const ::std::os::raw::c_void,
                                    arcs_len: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_poly_fill_arc_checked(c: *mut xcb_connection_t,
                                     drawable: xcb_drawable_t,
                                     gc: xcb_gcontext_t, arcs_len: u32,
                                     arcs: *const xcb_arc_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_poly_fill_arc(c: *mut xcb_connection_t,
                             drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                             arcs_len: u32, arcs: *const xcb_arc_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image_sizeof(_buffer: *const ::std::os::raw::c_void,
                                data_len: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_put_image_checked(c: *mut xcb_connection_t, format: u8,
                                 drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                 width: u16, height: u16, dst_x: i16,
                                 dst_y: i16, left_pad: u8, depth: u8,
                                 data_len: u32, data: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_put_image(c: *mut xcb_connection_t, format: u8,
                         drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                         width: u16, height: u16, dst_x: i16, dst_y: i16,
                         left_pad: u8, depth: u8, data_len: u32,
                         data: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_get_image(c: *mut xcb_connection_t, format: u8,
                         drawable: xcb_drawable_t, x: i16, y: i16, width: u16,
                         height: u16, plane_mask: u32)
     -> xcb_get_image_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_image_unchecked(c: *mut xcb_connection_t, format: u8,
                                   drawable: xcb_drawable_t, x: i16, y: i16,
                                   width: u16, height: u16, plane_mask: u32)
     -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_data(R: *const xcb_get_image_reply_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_get_image_data_length(R: *const xcb_get_image_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_image_data_end(R: *const xcb_get_image_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_image_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_image_reply(c: *mut xcb_connection_t,
                               cookie: xcb_get_image_cookie_t,
                               e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_image_reply_t;
}
extern "C" {
    pub fn xcb_poly_text_8_sizeof(_buffer: *const ::std::os::raw::c_void,
                                  items_len: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_poly_text_8_checked(c: *mut xcb_connection_t,
                                   drawable: xcb_drawable_t,
                                   gc: xcb_gcontext_t, x: i16, y: i16,
                                   items_len: u32, items: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_poly_text_8(c: *mut xcb_connection_t, drawable: xcb_drawable_t,
                           gc: xcb_gcontext_t, x: i16, y: i16, items_len: u32,
                           items: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16_sizeof(_buffer: *const ::std::os::raw::c_void,
                                   items_len: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_poly_text_16_checked(c: *mut xcb_connection_t,
                                    drawable: xcb_drawable_t,
                                    gc: xcb_gcontext_t, x: i16, y: i16,
                                    items_len: u32, items: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_poly_text_16(c: *mut xcb_connection_t,
                            drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                            x: i16, y: i16, items_len: u32, items: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Draws text
 *
 * @param c The connection
 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to
 * using 8 bits!
 * @param drawable The drawable (Window or Pixmap) to draw text on.
 * @param gc The graphics context to use.
 * \n
 * The following graphics context components are used: plane-mask, foreground,
 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.
 * @param x The x coordinate of the first character, relative to the origin of \a drawable.
 * @param y The y coordinate of the first character, relative to the origin of \a drawable.
 * @param string The string to draw. Only the first 255 characters are relevant due to the data
 * type of \a string_len.
 * @return A cookie
 *
 * Fills the destination rectangle with the background pixel from \a gc, then
 * paints the text with the foreground pixel from \a gc. The upper-left corner of
 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,
 * the height is font-ascent + font-descent. The overall-width, font-ascent and
 * font-descent are as returned by `xcb_query_text_extents` (TODO).
 *
 * Note that using X core fonts is deprecated (but still supported) in favor of
 * client-side rendering using Xft.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_image_text_8_checked(c: *mut xcb_connection_t, string_len: u8,
                                    drawable: xcb_drawable_t,
                                    gc: xcb_gcontext_t, x: i16, y: i16,
                                    string: *const ::std::os::raw::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Draws text
 *
 * @param c The connection
 * @param string_len The length of the \a string. Note that this parameter limited by 255 due to
 * using 8 bits!
 * @param drawable The drawable (Window or Pixmap) to draw text on.
 * @param gc The graphics context to use.
 * \n
 * The following graphics context components are used: plane-mask, foreground,
 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.
 * @param x The x coordinate of the first character, relative to the origin of \a drawable.
 * @param y The y coordinate of the first character, relative to the origin of \a drawable.
 * @param string The string to draw. Only the first 255 characters are relevant due to the data
 * type of \a string_len.
 * @return A cookie
 *
 * Fills the destination rectangle with the background pixel from \a gc, then
 * paints the text with the foreground pixel from \a gc. The upper-left corner of
 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,
 * the height is font-ascent + font-descent. The overall-width, font-ascent and
 * font-descent are as returned by `xcb_query_text_extents` (TODO).
 *
 * Note that using X core fonts is deprecated (but still supported) in favor of
 * client-side rendering using Xft.
 *
 */
    pub fn xcb_image_text_8(c: *mut xcb_connection_t, string_len: u8,
                            drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                            x: i16, y: i16,
                            string: *const ::std::os::raw::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief Draws text
 *
 * @param c The connection
 * @param string_len The length of the \a string in characters. Note that this parameter limited by
 * 255 due to using 8 bits!
 * @param drawable The drawable (Window or Pixmap) to draw text on.
 * @param gc The graphics context to use.
 * \n
 * The following graphics context components are used: plane-mask, foreground,
 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.
 * @param x The x coordinate of the first character, relative to the origin of \a drawable.
 * @param y The y coordinate of the first character, relative to the origin of \a drawable.
 * @param string The string to draw. Only the first 255 characters are relevant due to the data
 * type of \a string_len. Every character uses 2 bytes (hence the 16 in this
 * request's name).
 * @return A cookie
 *
 * Fills the destination rectangle with the background pixel from \a gc, then
 * paints the text with the foreground pixel from \a gc. The upper-left corner of
 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,
 * the height is font-ascent + font-descent. The overall-width, font-ascent and
 * font-descent are as returned by `xcb_query_text_extents` (TODO).
 *
 * Note that using X core fonts is deprecated (but still supported) in favor of
 * client-side rendering using Xft.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_image_text_16_checked(c: *mut xcb_connection_t, string_len: u8,
                                     drawable: xcb_drawable_t,
                                     gc: xcb_gcontext_t, x: i16, y: i16,
                                     string: *const xcb_char2b_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Draws text
 *
 * @param c The connection
 * @param string_len The length of the \a string in characters. Note that this parameter limited by
 * 255 due to using 8 bits!
 * @param drawable The drawable (Window or Pixmap) to draw text on.
 * @param gc The graphics context to use.
 * \n
 * The following graphics context components are used: plane-mask, foreground,
 * background, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.
 * @param x The x coordinate of the first character, relative to the origin of \a drawable.
 * @param y The y coordinate of the first character, relative to the origin of \a drawable.
 * @param string The string to draw. Only the first 255 characters are relevant due to the data
 * type of \a string_len. Every character uses 2 bytes (hence the 16 in this
 * request's name).
 * @return A cookie
 *
 * Fills the destination rectangle with the background pixel from \a gc, then
 * paints the text with the foreground pixel from \a gc. The upper-left corner of
 * the filled rectangle is at [x, y - font-ascent]. The width is overall-width,
 * the height is font-ascent + font-descent. The overall-width, font-ascent and
 * font-descent are as returned by `xcb_query_text_extents` (TODO).
 *
 * Note that using X core fonts is deprecated (but still supported) in favor of
 * client-side rendering using Xft.
 *
 */
    pub fn xcb_image_text_16(c: *mut xcb_connection_t, string_len: u8,
                             drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                             x: i16, y: i16, string: *const xcb_char2b_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_create_colormap_checked(c: *mut xcb_connection_t, alloc: u8,
                                       mid: xcb_colormap_t,
                                       window: xcb_window_t,
                                       visual: xcb_visualid_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_create_colormap(c: *mut xcb_connection_t, alloc: u8,
                               mid: xcb_colormap_t, window: xcb_window_t,
                               visual: xcb_visualid_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_free_colormap_checked(c: *mut xcb_connection_t,
                                     cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_free_colormap(c: *mut xcb_connection_t, cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_copy_colormap_and_free_checked(c: *mut xcb_connection_t,
                                              mid: xcb_colormap_t,
                                              src_cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_copy_colormap_and_free(c: *mut xcb_connection_t,
                                      mid: xcb_colormap_t,
                                      src_cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_install_colormap_checked(c: *mut xcb_connection_t,
                                        cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_install_colormap(c: *mut xcb_connection_t,
                                cmap: xcb_colormap_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_uninstall_colormap_checked(c: *mut xcb_connection_t,
                                          cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_uninstall_colormap(c: *mut xcb_connection_t,
                                  cmap: xcb_colormap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_sizeof(_buffer:
                                                   *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_list_installed_colormaps(c: *mut xcb_connection_t,
                                        window: xcb_window_t)
     -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_list_installed_colormaps_unchecked(c: *mut xcb_connection_t,
                                                  window: xcb_window_t)
     -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps(R:
                                                  *const xcb_list_installed_colormaps_reply_t)
     -> *mut xcb_colormap_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_length(R:
                                                         *const xcb_list_installed_colormaps_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_end(R:
                                                      *const xcb_list_installed_colormaps_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_list_installed_colormaps_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_list_installed_colormaps_reply(c: *mut xcb_connection_t,
                                              cookie:
                                                  xcb_list_installed_colormaps_cookie_t,
                                              e:
                                                  *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_installed_colormaps_reply_t;
}
extern "C" {
    /**
 * @brief Allocate a color
 *
 * @param c The connection
 * @param cmap TODO
 * @param red The red value of your color.
 * @param green The green value of your color.
 * @param blue The blue value of your color.
 * @return A cookie
 *
 * Allocates a read-only colormap entry corresponding to the closest RGB value
 * supported by the hardware. If you are using TrueColor, you can take a shortcut
 * and directly calculate the color pixel value to avoid the round trip. But, for
 * example, on 16-bit color setups (VNC), you can easily get the closest supported
 * RGB value to the RGB value you are specifying.
 *
 */
    pub fn xcb_alloc_color(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                           red: u16, green: u16, blue: u16)
     -> xcb_alloc_color_cookie_t;
}
extern "C" {
    /**
 * @brief Allocate a color
 *
 * @param c The connection
 * @param cmap TODO
 * @param red The red value of your color.
 * @param green The green value of your color.
 * @param blue The blue value of your color.
 * @return A cookie
 *
 * Allocates a read-only colormap entry corresponding to the closest RGB value
 * supported by the hardware. If you are using TrueColor, you can take a shortcut
 * and directly calculate the color pixel value to avoid the round trip. But, for
 * example, on 16-bit color setups (VNC), you can easily get the closest supported
 * RGB value to the RGB value you are specifying.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_alloc_color_unchecked(c: *mut xcb_connection_t,
                                     cmap: xcb_colormap_t, red: u16,
                                     green: u16, blue: u16)
     -> xcb_alloc_color_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_alloc_color_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_alloc_color_reply(c: *mut xcb_connection_t,
                                 cookie: xcb_alloc_color_cookie_t,
                                 e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_sizeof(_buffer:
                                            *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_alloc_named_color(c: *mut xcb_connection_t,
                                 cmap: xcb_colormap_t, name_len: u16,
                                 name: *const ::std::os::raw::c_char)
     -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_alloc_named_color_unchecked(c: *mut xcb_connection_t,
                                           cmap: xcb_colormap_t,
                                           name_len: u16,
                                           name:
                                               *const ::std::os::raw::c_char)
     -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_alloc_named_color_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_alloc_named_color_reply(c: *mut xcb_connection_t,
                                       cookie: xcb_alloc_named_color_cookie_t,
                                       e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_named_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_sizeof(_buffer:
                                            *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_alloc_color_cells(c: *mut xcb_connection_t, contiguous: u8,
                                 cmap: xcb_colormap_t, colors: u16,
                                 planes: u16)
     -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_alloc_color_cells_unchecked(c: *mut xcb_connection_t,
                                           contiguous: u8,
                                           cmap: xcb_colormap_t, colors: u16,
                                           planes: u16)
     -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels(R:
                                            *const xcb_alloc_color_cells_reply_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_length(R:
                                                   *const xcb_alloc_color_cells_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_end(R:
                                                *const xcb_alloc_color_cells_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks(R:
                                           *const xcb_alloc_color_cells_reply_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_length(R:
                                                  *const xcb_alloc_color_cells_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_end(R:
                                               *const xcb_alloc_color_cells_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_alloc_color_cells_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_alloc_color_cells_reply(c: *mut xcb_connection_t,
                                       cookie: xcb_alloc_color_cells_cookie_t,
                                       e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_color_cells_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_sizeof(_buffer:
                                             *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_alloc_color_planes(c: *mut xcb_connection_t, contiguous: u8,
                                  cmap: xcb_colormap_t, colors: u16,
                                  reds: u16, greens: u16, blues: u16)
     -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_alloc_color_planes_unchecked(c: *mut xcb_connection_t,
                                            contiguous: u8,
                                            cmap: xcb_colormap_t, colors: u16,
                                            reds: u16, greens: u16,
                                            blues: u16)
     -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels(R:
                                             *const xcb_alloc_color_planes_reply_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_length(R:
                                                    *const xcb_alloc_color_planes_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_end(R:
                                                 *const xcb_alloc_color_planes_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_alloc_color_planes_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_alloc_color_planes_reply(c: *mut xcb_connection_t,
                                        cookie:
                                            xcb_alloc_color_planes_cookie_t,
                                        e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_color_planes_reply_t;
}
extern "C" {
    pub fn xcb_free_colors_sizeof(_buffer: *const ::std::os::raw::c_void,
                                  pixels_len: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_free_colors_checked(c: *mut xcb_connection_t,
                                   cmap: xcb_colormap_t, plane_mask: u32,
                                   pixels_len: u32, pixels: *const u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_free_colors(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                           plane_mask: u32, pixels_len: u32,
                           pixels: *const u32) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_coloritem_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_coloritem_t)
 */
    pub fn xcb_coloritem_next(i: *mut xcb_coloritem_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_coloritem_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_coloritem_end(i: xcb_coloritem_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_store_colors_sizeof(_buffer: *const ::std::os::raw::c_void,
                                   items_len: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_store_colors_checked(c: *mut xcb_connection_t,
                                    cmap: xcb_colormap_t, items_len: u32,
                                    items: *const xcb_coloritem_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_store_colors(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                            items_len: u32, items: *const xcb_coloritem_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color_sizeof(_buffer:
                                            *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_store_named_color_checked(c: *mut xcb_connection_t, flags: u8,
                                         cmap: xcb_colormap_t, pixel: u32,
                                         name_len: u16,
                                         name: *const ::std::os::raw::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_store_named_color(c: *mut xcb_connection_t, flags: u8,
                                 cmap: xcb_colormap_t, pixel: u32,
                                 name_len: u16,
                                 name: *const ::std::os::raw::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_rgb_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_rgb_t)
 */
    pub fn xcb_rgb_next(i: *mut xcb_rgb_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_rgb_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_rgb_end(i: xcb_rgb_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_sizeof(_buffer: *const ::std::os::raw::c_void,
                                   pixels_len: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_query_colors(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                            pixels_len: u32, pixels: *const u32)
     -> xcb_query_colors_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_query_colors_unchecked(c: *mut xcb_connection_t,
                                      cmap: xcb_colormap_t, pixels_len: u32,
                                      pixels: *const u32)
     -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_colors(R: *const xcb_query_colors_reply_t)
     -> *mut xcb_rgb_t;
}
extern "C" {
    pub fn xcb_query_colors_colors_length(R: *const xcb_query_colors_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_query_colors_colors_iterator(R:
                                                *const xcb_query_colors_reply_t)
     -> xcb_rgb_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_query_colors_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_query_colors_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_query_colors_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_colors_reply_t;
}
extern "C" {
    pub fn xcb_lookup_color_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_lookup_color(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                            name_len: u16,
                            name: *const ::std::os::raw::c_char)
     -> xcb_lookup_color_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_lookup_color_unchecked(c: *mut xcb_connection_t,
                                      cmap: xcb_colormap_t, name_len: u16,
                                      name: *const ::std::os::raw::c_char)
     -> xcb_lookup_color_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_lookup_color_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_lookup_color_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_lookup_color_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_lookup_color_reply_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_create_cursor_checked(c: *mut xcb_connection_t,
                                     cid: xcb_cursor_t, source: xcb_pixmap_t,
                                     mask: xcb_pixmap_t, fore_red: u16,
                                     fore_green: u16, fore_blue: u16,
                                     back_red: u16, back_green: u16,
                                     back_blue: u16, x: u16, y: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_create_cursor(c: *mut xcb_connection_t, cid: xcb_cursor_t,
                             source: xcb_pixmap_t, mask: xcb_pixmap_t,
                             fore_red: u16, fore_green: u16, fore_blue: u16,
                             back_red: u16, back_green: u16, back_blue: u16,
                             x: u16, y: u16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief create cursor
 *
 * @param c The connection
 * @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.
 * @param source_font In which font to look for the cursor glyph.
 * @param mask_font In which font to look for the mask glyph.
 * @param source_char The glyph of \a source_font to use.
 * @param mask_char The glyph of \a mask_font to use as a mask: Pixels which are set to 1 define
 * which source pixels are displayed. All pixels which are set to 0 are not
 * displayed.
 * @param fore_red The red value of the foreground color.
 * @param fore_green The green value of the foreground color.
 * @param fore_blue The blue value of the foreground color.
 * @param back_red The red value of the background color.
 * @param back_green The green value of the background color.
 * @param back_blue The blue value of the background color.
 * @return A cookie
 *
 * Creates a cursor from a font glyph. X provides a set of standard cursor shapes
 * in a special font named cursor. Applications are encouraged to use this
 * interface for their cursors because the font can be customized for the
 * individual display type.
 *
 * All pixels which are set to 1 in the source will use the foreground color (as
 * specified by \a fore_red, \a fore_green and \a fore_blue). All pixels set to 0
 * will use the background color (as specified by \a back_red, \a back_green and
 * \a back_blue).
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_create_glyph_cursor_checked(c: *mut xcb_connection_t,
                                           cid: xcb_cursor_t,
                                           source_font: xcb_font_t,
                                           mask_font: xcb_font_t,
                                           source_char: u16, mask_char: u16,
                                           fore_red: u16, fore_green: u16,
                                           fore_blue: u16, back_red: u16,
                                           back_green: u16, back_blue: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief create cursor
 *
 * @param c The connection
 * @param cid The ID with which you will refer to the cursor, created by `xcb_generate_id`.
 * @param source_font In which font to look for the cursor glyph.
 * @param mask_font In which font to look for the mask glyph.
 * @param source_char The glyph of \a source_font to use.
 * @param mask_char The glyph of \a mask_font to use as a mask: Pixels which are set to 1 define
 * which source pixels are displayed. All pixels which are set to 0 are not
 * displayed.
 * @param fore_red The red value of the foreground color.
 * @param fore_green The green value of the foreground color.
 * @param fore_blue The blue value of the foreground color.
 * @param back_red The red value of the background color.
 * @param back_green The green value of the background color.
 * @param back_blue The blue value of the background color.
 * @return A cookie
 *
 * Creates a cursor from a font glyph. X provides a set of standard cursor shapes
 * in a special font named cursor. Applications are encouraged to use this
 * interface for their cursors because the font can be customized for the
 * individual display type.
 *
 * All pixels which are set to 1 in the source will use the foreground color (as
 * specified by \a fore_red, \a fore_green and \a fore_blue). All pixels set to 0
 * will use the background color (as specified by \a back_red, \a back_green and
 * \a back_blue).
 *
 */
    pub fn xcb_create_glyph_cursor(c: *mut xcb_connection_t,
                                   cid: xcb_cursor_t, source_font: xcb_font_t,
                                   mask_font: xcb_font_t, source_char: u16,
                                   mask_char: u16, fore_red: u16,
                                   fore_green: u16, fore_blue: u16,
                                   back_red: u16, back_green: u16,
                                   back_blue: u16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Deletes a cursor
 *
 * @param c The connection
 * @param cursor The cursor to destroy.
 * @return A cookie
 *
 * Deletes the association between the cursor resource ID and the specified
 * cursor. The cursor is freed when no other resource references it.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_free_cursor_checked(c: *mut xcb_connection_t,
                                   cursor: xcb_cursor_t) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief Deletes a cursor
 *
 * @param c The connection
 * @param cursor The cursor to destroy.
 * @return A cookie
 *
 * Deletes the association between the cursor resource ID and the specified
 * cursor. The cursor is freed when no other resource references it.
 *
 */
    pub fn xcb_free_cursor(c: *mut xcb_connection_t, cursor: xcb_cursor_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_recolor_cursor_checked(c: *mut xcb_connection_t,
                                      cursor: xcb_cursor_t, fore_red: u16,
                                      fore_green: u16, fore_blue: u16,
                                      back_red: u16, back_green: u16,
                                      back_blue: u16) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_recolor_cursor(c: *mut xcb_connection_t, cursor: xcb_cursor_t,
                              fore_red: u16, fore_green: u16, fore_blue: u16,
                              back_red: u16, back_green: u16, back_blue: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_query_best_size(c: *mut xcb_connection_t, _class: u8,
                               drawable: xcb_drawable_t, width: u16,
                               height: u16) -> xcb_query_best_size_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_query_best_size_unchecked(c: *mut xcb_connection_t, _class: u8,
                                         drawable: xcb_drawable_t, width: u16,
                                         height: u16)
     -> xcb_query_best_size_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_query_best_size_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_query_best_size_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_query_best_size_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_best_size_reply_t;
}
extern "C" {
    pub fn xcb_query_extension_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief check if extension is present
 *
 * @param c The connection
 * @param name_len The length of \a name in bytes.
 * @param name The name of the extension to query, for example "RANDR". This is case
 * sensitive!
 * @return A cookie
 *
 * Determines if the specified extension is present on this X11 server.
 *
 * Every extension has a unique `major_opcode` to identify requests, the minor
 * opcodes and request formats are extension-specific. If the extension provides
 * events and errors, the `first_event` and `first_error` fields in the reply are
 * set accordingly.
 *
 * There should rarely be a need to use this request directly, XCB provides the
 * `xcb_get_extension_data` function instead.
 *
 */
    pub fn xcb_query_extension(c: *mut xcb_connection_t, name_len: u16,
                               name: *const ::std::os::raw::c_char)
     -> xcb_query_extension_cookie_t;
}
extern "C" {
    /**
 * @brief check if extension is present
 *
 * @param c The connection
 * @param name_len The length of \a name in bytes.
 * @param name The name of the extension to query, for example "RANDR". This is case
 * sensitive!
 * @return A cookie
 *
 * Determines if the specified extension is present on this X11 server.
 *
 * Every extension has a unique `major_opcode` to identify requests, the minor
 * opcodes and request formats are extension-specific. If the extension provides
 * events and errors, the `first_event` and `first_error` fields in the reply are
 * set accordingly.
 *
 * There should rarely be a need to use this request directly, XCB provides the
 * `xcb_get_extension_data` function instead.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_query_extension_unchecked(c: *mut xcb_connection_t,
                                         name_len: u16,
                                         name: *const ::std::os::raw::c_char)
     -> xcb_query_extension_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_query_extension_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_query_extension_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_query_extension_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_list_extensions_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_list_extensions(c: *mut xcb_connection_t)
     -> xcb_list_extensions_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_list_extensions_unchecked(c: *mut xcb_connection_t)
     -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_names_length(R:
                                                *const xcb_list_extensions_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_extensions_names_iterator(R:
                                                  *const xcb_list_extensions_reply_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_list_extensions_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_list_extensions_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_list_extensions_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_extensions_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_sizeof(_buffer:
                                                  *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_change_keyboard_mapping_checked(c: *mut xcb_connection_t,
                                               keycode_count: u8,
                                               first_keycode: xcb_keycode_t,
                                               keysyms_per_keycode: u8,
                                               keysyms: *const xcb_keysym_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_change_keyboard_mapping(c: *mut xcb_connection_t,
                                       keycode_count: u8,
                                       first_keycode: xcb_keycode_t,
                                       keysyms_per_keycode: u8,
                                       keysyms: *const xcb_keysym_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_sizeof(_buffer:
                                               *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_get_keyboard_mapping(c: *mut xcb_connection_t,
                                    first_keycode: xcb_keycode_t, count: u8)
     -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_keyboard_mapping_unchecked(c: *mut xcb_connection_t,
                                              first_keycode: xcb_keycode_t,
                                              count: u8)
     -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms(R:
                                                *const xcb_get_keyboard_mapping_reply_t)
     -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_length(R:
                                                       *const xcb_get_keyboard_mapping_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_end(R:
                                                    *const xcb_get_keyboard_mapping_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_keyboard_mapping_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_keyboard_mapping_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_get_keyboard_mapping_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_keyboard_mapping_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_sizeof(_buffer:
                                                  *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_change_keyboard_control_checked(c: *mut xcb_connection_t,
                                               value_mask: u32,
                                               value_list: *const u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_change_keyboard_control(c: *mut xcb_connection_t,
                                       value_mask: u32,
                                       value_list: *const u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_get_keyboard_control(c: *mut xcb_connection_t)
     -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_keyboard_control_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_keyboard_control_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_keyboard_control_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_get_keyboard_control_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_keyboard_control_reply_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_bell_checked(c: *mut xcb_connection_t, percent: i8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_bell(c: *mut xcb_connection_t, percent: i8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_change_pointer_control_checked(c: *mut xcb_connection_t,
                                              acceleration_numerator: i16,
                                              acceleration_denominator: i16,
                                              threshold: i16,
                                              do_acceleration: u8,
                                              do_threshold: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_change_pointer_control(c: *mut xcb_connection_t,
                                      acceleration_numerator: i16,
                                      acceleration_denominator: i16,
                                      threshold: i16, do_acceleration: u8,
                                      do_threshold: u8) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_get_pointer_control(c: *mut xcb_connection_t)
     -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_pointer_control_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_pointer_control_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_pointer_control_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_get_pointer_control_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_pointer_control_reply_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_set_screen_saver_checked(c: *mut xcb_connection_t,
                                        timeout: i16, interval: i16,
                                        prefer_blanking: u8,
                                        allow_exposures: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_set_screen_saver(c: *mut xcb_connection_t, timeout: i16,
                                interval: i16, prefer_blanking: u8,
                                allow_exposures: u8) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_get_screen_saver(c: *mut xcb_connection_t)
     -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_screen_saver_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_screen_saver_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_screen_saver_reply(c: *mut xcb_connection_t,
                                      cookie: xcb_get_screen_saver_cookie_t,
                                      e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_screen_saver_reply_t;
}
extern "C" {
    pub fn xcb_change_hosts_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_change_hosts_checked(c: *mut xcb_connection_t, mode: u8,
                                    family: u8, address_len: u16,
                                    address: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_change_hosts(c: *mut xcb_connection_t, mode: u8, family: u8,
                            address_len: u16, address: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_host_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_host_address(R: *const xcb_host_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_host_address_length(R: *const xcb_host_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_host_address_end(R: *const xcb_host_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Get the next element of the iterator
 * @param i Pointer to a xcb_host_iterator_t
 *
 * Get the next element in the iterator. The member rem is
 * decreased by one. The member data points to the next
 * element. The member index is increased by sizeof(xcb_host_t)
 */
    pub fn xcb_host_next(i: *mut xcb_host_iterator_t);
}
extern "C" {
    /**
 * Return the iterator pointing to the last element
 * @param i An xcb_host_iterator_t
 * @return  The iterator pointing to the last element
 *
 * Set the current element in the iterator to the last element.
 * The member rem is set to 0. The member data points to the
 * last element.
 */
    pub fn xcb_host_end(i: xcb_host_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_sizeof(_buffer: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_list_hosts(c: *mut xcb_connection_t)
     -> xcb_list_hosts_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_list_hosts_unchecked(c: *mut xcb_connection_t)
     -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_length(R: *const xcb_list_hosts_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_iterator(R: *const xcb_list_hosts_reply_t)
     -> xcb_host_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_list_hosts_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_list_hosts_reply(c: *mut xcb_connection_t,
                                cookie: xcb_list_hosts_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_hosts_reply_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_set_access_control_checked(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_set_access_control(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_set_close_down_mode_checked(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_set_close_down_mode(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief kills a client
 *
 * @param c The connection
 * @param resource Any resource belonging to the client (for example a Window), used to identify
 * the client connection.
 * \n
 * The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients
 * that have terminated in `RetainTemporary` (TODO) are destroyed.
 * @return A cookie
 *
 * Forces a close down of the client that created the specified \a resource.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_kill_client_checked(c: *mut xcb_connection_t, resource: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 * @brief kills a client
 *
 * @param c The connection
 * @param resource Any resource belonging to the client (for example a Window), used to identify
 * the client connection.
 * \n
 * The special value of `XCB_KILL_ALL_TEMPORARY`, the resources of all clients
 * that have terminated in `RetainTemporary` (TODO) are destroyed.
 * @return A cookie
 *
 * Forces a close down of the client that created the specified \a resource.
 *
 */
    pub fn xcb_kill_client(c: *mut xcb_connection_t, resource: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_sizeof(_buffer:
                                            *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_rotate_properties_checked(c: *mut xcb_connection_t,
                                         window: xcb_window_t, atoms_len: u16,
                                         delta: i16, atoms: *const xcb_atom_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_rotate_properties(c: *mut xcb_connection_t,
                                 window: xcb_window_t, atoms_len: u16,
                                 delta: i16, atoms: *const xcb_atom_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_force_screen_saver_checked(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_force_screen_saver(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_sizeof(_buffer:
                                              *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_set_pointer_mapping(c: *mut xcb_connection_t, map_len: u8,
                                   map: *const u8)
     -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_set_pointer_mapping_unchecked(c: *mut xcb_connection_t,
                                             map_len: u8, map: *const u8)
     -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_set_pointer_mapping_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_set_pointer_mapping_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_set_pointer_mapping_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_set_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_sizeof(_buffer:
                                              *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_get_pointer_mapping(c: *mut xcb_connection_t)
     -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_pointer_mapping_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map(R:
                                           *const xcb_get_pointer_mapping_reply_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_length(R:
                                                  *const xcb_get_pointer_mapping_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_end(R:
                                               *const xcb_get_pointer_mapping_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_pointer_mapping_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_pointer_mapping_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_get_pointer_mapping_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_sizeof(_buffer:
                                               *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_set_modifier_mapping(c: *mut xcb_connection_t,
                                    keycodes_per_modifier: u8,
                                    keycodes: *const xcb_keycode_t)
     -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_set_modifier_mapping_unchecked(c: *mut xcb_connection_t,
                                              keycodes_per_modifier: u8,
                                              keycodes: *const xcb_keycode_t)
     -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_set_modifier_mapping_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_set_modifier_mapping_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_set_modifier_mapping_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_set_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_sizeof(_buffer:
                                               *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_get_modifier_mapping(c: *mut xcb_connection_t)
     -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will cause
 * a reply to be generated. Any returned error will be
 * placed in the event queue.
 */
    pub fn xcb_get_modifier_mapping_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes(R:
                                                 *const xcb_get_modifier_mapping_reply_t)
     -> *mut xcb_keycode_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_length(R:
                                                        *const xcb_get_modifier_mapping_reply_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_end(R:
                                                     *const xcb_get_modifier_mapping_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    /**
 * Return the reply
 * @param c      The connection
 * @param cookie The cookie
 * @param e      The xcb_generic_error_t supplied
 *
 * Returns the reply of the request asked by
 *
 * The parameter @p e supplied to this function must be NULL if
 * xcb_get_modifier_mapping_unchecked(). is used.
 * Otherwise, it stores the error if any.
 *
 * The returned value must be freed by the caller using free().
 */
    pub fn xcb_get_modifier_mapping_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_get_modifier_mapping_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_modifier_mapping_reply_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 * This form can be used only if the request will not cause
 * a reply to be generated. Any returned error will be
 * saved for handling by xcb_request_check().
 */
    pub fn xcb_no_operation_checked(c: *mut xcb_connection_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    /**
 *
 * @param c The connection
 * @return A cookie
 *
 * Delivers a request to the X server.
 *
 */
    pub fn xcb_no_operation(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
