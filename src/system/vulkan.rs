#![allow(dead_code, non_camel_case_types, non_upper_case_globals, non_snake_case)]
use libc::{c_void};

pub type ptrdiff_t = isize;
pub type size_t = usize;
pub type wchar_t = ::std::os::raw::c_int;

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __clang_max_align_nonce2: f64,
}

impl ::std::default::Default for max_align_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

pub type int8_t = i8;
pub type int16_t = i16;
pub type int32_t = i32;
pub type int64_t = i64;
pub type uint8_t = u8;
pub type uint16_t = u16;
pub type uint32_t = u32;
pub type uint64_t = u64;
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intptr_t = isize;
pub type uintptr_t = usize;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type VkFlags = uint32_t;
pub type VkBool32 = uint32_t;
pub type VkDeviceSize = uint64_t;
pub type VkSampleMask = uint32_t;

pub enum VkInstance_T {}

pub type VkInstance = *mut VkInstance_T;

pub enum VkPhysicalDevice_T {}

pub type VkPhysicalDevice = *mut VkPhysicalDevice_T;

pub enum VkDevice_T {}

pub type VkDevice = *mut VkDevice_T;

pub enum VkQueue_T {}

pub type VkQueue = *mut VkQueue_T;

pub enum VkSemaphore_T {}

pub type VkSemaphore = *mut VkSemaphore_T;

pub enum VkCommandBuffer_T {}

pub type VkCommandBuffer = *mut VkCommandBuffer_T;

pub enum VkFence_T {}

pub type VkFence = *mut VkFence_T;

pub enum VkDeviceMemory_T {}

pub type VkDeviceMemory = *mut VkDeviceMemory_T;

pub enum VkBuffer_T {}

pub type VkBuffer = *mut VkBuffer_T;

pub enum VkImage_T {}

pub type VkImage = *mut VkImage_T;

pub enum VkEvent_T {}

pub type VkEvent = *mut VkEvent_T;

pub enum VkQueryPool_T {}

pub type VkQueryPool = *mut VkQueryPool_T;

pub enum VkBufferView_T {}

pub type VkBufferView = *mut VkBufferView_T;

pub enum VkImageView_T {}

pub type VkImageView = *mut VkImageView_T;

pub enum VkShaderModule_T {}

pub type VkShaderModule = *mut VkShaderModule_T;

pub enum VkPipelineCache_T {}

pub type VkPipelineCache = *mut VkPipelineCache_T;

pub enum VkPipelineLayout_T {}

pub type VkPipelineLayout = *mut VkPipelineLayout_T;

pub enum VkRenderPass_T {}

pub type VkRenderPass = *mut VkRenderPass_T;

pub enum VkPipeline_T {}

pub type VkPipeline = *mut VkPipeline_T;

pub enum VkDescriptorSetLayout_T {}

pub type VkDescriptorSetLayout = *mut VkDescriptorSetLayout_T;

pub enum VkSampler_T {}

pub type VkSampler = *mut VkSampler_T;

pub enum VkDescriptorPool_T {}

pub type VkDescriptorPool = *mut VkDescriptorPool_T;

pub enum VkDescriptorSet_T {}

pub type VkDescriptorSet = *mut VkDescriptorSet_T;

pub enum VkFramebuffer_T {}

pub type VkFramebuffer = *mut VkFramebuffer_T;

pub enum VkCommandPool_T {}

pub type VkCommandPool = *mut VkCommandPool_T;

pub const VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE:
VkPipelineCacheHeaderVersion =
VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
pub const VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE:
VkPipelineCacheHeaderVersion =
VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
pub const VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE:
VkPipelineCacheHeaderVersion =
VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 2147483647,
}

pub const VK_RESULT_BEGIN_RANGE: VkResult =
VkResult::VK_ERROR_FORMAT_NOT_SUPPORTED;
pub const VK_RESULT_END_RANGE: VkResult = VkResult::VK_INCOMPLETE;

#[derive(Copy, Clone)]
#[repr(i32)]
#[derive(Debug)]
pub enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_RESULT_RANGE_SIZE = 17,
    VK_RESULT_MAX_ENUM = 2147483647,
}

pub const VK_STRUCTURE_TYPE_BEGIN_RANGE: VkStructureType =
VkStructureType::VK_STRUCTURE_TYPE_APPLICATION_INFO;
pub const VK_STRUCTURE_TYPE_END_RANGE: VkStructureType =
VkStructureType::VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_RANGE_SIZE = 49,
    VK_STRUCTURE_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE: VkSystemAllocationScope =
VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_COMMAND;
pub const VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE: VkSystemAllocationScope =
VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = 5,
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 2147483647,
}

pub const VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE: VkInternalAllocationType =
VkInternalAllocationType::VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
pub const VK_INTERNAL_ALLOCATION_TYPE_END_RANGE: VkInternalAllocationType =
VkInternalAllocationType::VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = 1,
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_FORMAT_BEGIN_RANGE: VkFormat = VkFormat::VK_FORMAT_UNDEFINED;
pub const VK_FORMAT_END_RANGE: VkFormat =
VkFormat::VK_FORMAT_ASTC_12x12_SRGB_BLOCK;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_RANGE_SIZE = 185,
    VK_FORMAT_MAX_ENUM = 2147483647,
}

pub const VK_IMAGE_TYPE_BEGIN_RANGE: VkImageType =
VkImageType::VK_IMAGE_TYPE_1D;
pub const VK_IMAGE_TYPE_END_RANGE: VkImageType =
VkImageType::VK_IMAGE_TYPE_3D;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_RANGE_SIZE = 3,
    VK_IMAGE_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_IMAGE_TILING_BEGIN_RANGE: VkImageTiling =
VkImageTiling::VK_IMAGE_TILING_OPTIMAL;
pub const VK_IMAGE_TILING_END_RANGE: VkImageTiling =
VkImageTiling::VK_IMAGE_TILING_LINEAR;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_RANGE_SIZE = 2,
    VK_IMAGE_TILING_MAX_ENUM = 2147483647,
}

pub const VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE: VkPhysicalDeviceType =
VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_OTHER;
pub const VK_PHYSICAL_DEVICE_TYPE_END_RANGE: VkPhysicalDeviceType =
VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_CPU;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = 5,
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_QUERY_TYPE_BEGIN_RANGE: VkQueryType =
VkQueryType::VK_QUERY_TYPE_OCCLUSION;
pub const VK_QUERY_TYPE_END_RANGE: VkQueryType =
VkQueryType::VK_QUERY_TYPE_TIMESTAMP;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_RANGE_SIZE = 3,
    VK_QUERY_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_SHARING_MODE_BEGIN_RANGE: VkSharingMode =
VkSharingMode::VK_SHARING_MODE_EXCLUSIVE;
pub const VK_SHARING_MODE_END_RANGE: VkSharingMode =
VkSharingMode::VK_SHARING_MODE_CONCURRENT;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_RANGE_SIZE = 2,
    VK_SHARING_MODE_MAX_ENUM = 2147483647,
}

pub const VK_IMAGE_LAYOUT_BEGIN_RANGE: VkImageLayout =
VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED;
pub const VK_IMAGE_LAYOUT_END_RANGE: VkImageLayout =
VkImageLayout::VK_IMAGE_LAYOUT_PREINITIALIZED;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_RANGE_SIZE = 9,
    VK_IMAGE_LAYOUT_MAX_ENUM = 2147483647,
}

pub const VK_IMAGE_VIEW_TYPE_BEGIN_RANGE: VkImageViewType =
VkImageViewType::VK_IMAGE_VIEW_TYPE_1D;
pub const VK_IMAGE_VIEW_TYPE_END_RANGE: VkImageViewType =
VkImageViewType::VK_IMAGE_VIEW_TYPE_CUBE_ARRAY;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_RANGE_SIZE = 7,
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_COMPONENT_SWIZZLE_BEGIN_RANGE: VkComponentSwizzle =
VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;
pub const VK_COMPONENT_SWIZZLE_END_RANGE: VkComponentSwizzle =
VkComponentSwizzle::VK_COMPONENT_SWIZZLE_A;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_RANGE_SIZE = 7,
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 2147483647,
}

pub const VK_VERTEX_INPUT_RATE_BEGIN_RANGE: VkVertexInputRate =
VkVertexInputRate::VK_VERTEX_INPUT_RATE_VERTEX;
pub const VK_VERTEX_INPUT_RATE_END_RANGE: VkVertexInputRate =
VkVertexInputRate::VK_VERTEX_INPUT_RATE_INSTANCE;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_RANGE_SIZE = 2,
    VK_VERTEX_INPUT_RATE_MAX_ENUM = 2147483647,
}

pub const VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE: VkPrimitiveTopology =
VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_POINT_LIST;
pub const VK_PRIMITIVE_TOPOLOGY_END_RANGE: VkPrimitiveTopology =
VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_PATCH_LIST;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = 11,
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 2147483647,
}

pub const VK_POLYGON_MODE_BEGIN_RANGE: VkPolygonMode =
VkPolygonMode::VK_POLYGON_MODE_FILL;
pub const VK_POLYGON_MODE_END_RANGE: VkPolygonMode =
VkPolygonMode::VK_POLYGON_MODE_POINT;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_RANGE_SIZE = 3,
    VK_POLYGON_MODE_MAX_ENUM = 2147483647,
}

pub const VK_FRONT_FACE_BEGIN_RANGE: VkFrontFace =
VkFrontFace::VK_FRONT_FACE_COUNTER_CLOCKWISE;
pub const VK_FRONT_FACE_END_RANGE: VkFrontFace =
VkFrontFace::VK_FRONT_FACE_CLOCKWISE;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_RANGE_SIZE = 2,
    VK_FRONT_FACE_MAX_ENUM = 2147483647,
}

pub const VK_COMPARE_OP_BEGIN_RANGE: VkCompareOp =
VkCompareOp::VK_COMPARE_OP_NEVER;
pub const VK_COMPARE_OP_END_RANGE: VkCompareOp =
VkCompareOp::VK_COMPARE_OP_ALWAYS;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_RANGE_SIZE = 8,
    VK_COMPARE_OP_MAX_ENUM = 2147483647,
}

pub const VK_STENCIL_OP_BEGIN_RANGE: VkStencilOp =
VkStencilOp::VK_STENCIL_OP_KEEP;
pub const VK_STENCIL_OP_END_RANGE: VkStencilOp =
VkStencilOp::VK_STENCIL_OP_DECREMENT_AND_WRAP;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_RANGE_SIZE = 8,
    VK_STENCIL_OP_MAX_ENUM = 2147483647,
}

pub const VK_LOGIC_OP_BEGIN_RANGE: VkLogicOp = VkLogicOp::VK_LOGIC_OP_CLEAR;
pub const VK_LOGIC_OP_END_RANGE: VkLogicOp = VkLogicOp::VK_LOGIC_OP_SET;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_RANGE_SIZE = 16,
    VK_LOGIC_OP_MAX_ENUM = 2147483647,
}

pub const VK_BLEND_FACTOR_BEGIN_RANGE: VkBlendFactor =
VkBlendFactor::VK_BLEND_FACTOR_ZERO;
pub const VK_BLEND_FACTOR_END_RANGE: VkBlendFactor =
VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_RANGE_SIZE = 19,
    VK_BLEND_FACTOR_MAX_ENUM = 2147483647,
}

pub const VK_BLEND_OP_BEGIN_RANGE: VkBlendOp = VkBlendOp::VK_BLEND_OP_ADD;
pub const VK_BLEND_OP_END_RANGE: VkBlendOp = VkBlendOp::VK_BLEND_OP_MAX;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_RANGE_SIZE = 5,
    VK_BLEND_OP_MAX_ENUM = 2147483647,
}

pub const VK_DYNAMIC_STATE_BEGIN_RANGE: VkDynamicState =
VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT;
pub const VK_DYNAMIC_STATE_END_RANGE: VkDynamicState =
VkDynamicState::VK_DYNAMIC_STATE_STENCIL_REFERENCE;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_RANGE_SIZE = 9,
    VK_DYNAMIC_STATE_MAX_ENUM = 2147483647,
}

pub const VK_FILTER_BEGIN_RANGE: VkFilter = VkFilter::VK_FILTER_NEAREST;
pub const VK_FILTER_END_RANGE: VkFilter = VkFilter::VK_FILTER_LINEAR;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_RANGE_SIZE = 2,
    VK_FILTER_MAX_ENUM = 2147483647,
}

pub const VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE: VkSamplerMipmapMode =
VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_NEAREST;
pub const VK_SAMPLER_MIPMAP_MODE_END_RANGE: VkSamplerMipmapMode =
VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_LINEAR;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = 2,
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 2147483647,
}

pub const VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE: VkSamplerAddressMode =
VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_REPEAT;
pub const VK_SAMPLER_ADDRESS_MODE_END_RANGE: VkSamplerAddressMode =
VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
pub const VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE: VkSamplerAddressMode =
VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 2147483647,
}

pub const VK_BORDER_COLOR_BEGIN_RANGE: VkBorderColor =
VkBorderColor::VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK;
pub const VK_BORDER_COLOR_END_RANGE: VkBorderColor =
VkBorderColor::VK_BORDER_COLOR_INT_OPAQUE_WHITE;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_RANGE_SIZE = 6,
    VK_BORDER_COLOR_MAX_ENUM = 2147483647,
}

pub const VK_DESCRIPTOR_TYPE_BEGIN_RANGE: VkDescriptorType =
VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLER;
pub const VK_DESCRIPTOR_TYPE_END_RANGE: VkDescriptorType =
VkDescriptorType::VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_RANGE_SIZE = 11,
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE: VkAttachmentLoadOp =
VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_LOAD;
pub const VK_ATTACHMENT_LOAD_OP_END_RANGE: VkAttachmentLoadOp =
VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_DONT_CARE;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = 3,
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 2147483647,
}

pub const VK_ATTACHMENT_STORE_OP_BEGIN_RANGE: VkAttachmentStoreOp =
VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_STORE;
pub const VK_ATTACHMENT_STORE_OP_END_RANGE: VkAttachmentStoreOp =
VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_RANGE_SIZE = 2,
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 2147483647,
}

pub const VK_PIPELINE_BIND_POINT_BEGIN_RANGE: VkPipelineBindPoint =
VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS;
pub const VK_PIPELINE_BIND_POINT_END_RANGE: VkPipelineBindPoint =
VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_COMPUTE;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_RANGE_SIZE = 2,
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 2147483647,
}

pub const VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE: VkCommandBufferLevel =
VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_PRIMARY;
pub const VK_COMMAND_BUFFER_LEVEL_END_RANGE: VkCommandBufferLevel =
VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_SECONDARY;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = 2,
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 2147483647,
}

pub const VK_INDEX_TYPE_BEGIN_RANGE: VkIndexType =
VkIndexType::VK_INDEX_TYPE_UINT16;
pub const VK_INDEX_TYPE_END_RANGE: VkIndexType =
VkIndexType::VK_INDEX_TYPE_UINT32;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_RANGE_SIZE = 2,
    VK_INDEX_TYPE_MAX_ENUM = 2147483647,
}

pub const VK_SUBPASS_CONTENTS_BEGIN_RANGE: VkSubpassContents =
VkSubpassContents::VK_SUBPASS_CONTENTS_INLINE;
pub const VK_SUBPASS_CONTENTS_END_RANGE: VkSubpassContents =
VkSubpassContents::VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_RANGE_SIZE = 2,
    VK_SUBPASS_CONTENTS_MAX_ENUM = 2147483647,
}

pub type VkInstanceCreateFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 1,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 2,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 4,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 8,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 16,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 32,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 64,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 128,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 256,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 512,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 1024,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 2048,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 4096,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 8192,
    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkFormatFeatureFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 1,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 2,
    VK_IMAGE_USAGE_SAMPLED_BIT = 4,
    VK_IMAGE_USAGE_STORAGE_BIT = 8,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128,
    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkImageUsageFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 1,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 4,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 8,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 16,
    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkImageCreateFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 1,
    VK_SAMPLE_COUNT_2_BIT = 2,
    VK_SAMPLE_COUNT_4_BIT = 4,
    VK_SAMPLE_COUNT_8_BIT = 8,
    VK_SAMPLE_COUNT_16_BIT = 16,
    VK_SAMPLE_COUNT_32_BIT = 32,
    VK_SAMPLE_COUNT_64_BIT = 64,
    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkSampleCountFlags = VkFlags;

#[repr(u32)]
#[derive(Copy, Clone, Debug)]
pub enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 1,
    VK_QUEUE_COMPUTE_BIT = 2,
    VK_QUEUE_TRANSFER_BIT = 4,
    VK_QUEUE_SPARSE_BINDING_BIT = 8,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkQueueFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 2,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 4,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 8,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 16,
    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkMemoryPropertyFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkMemoryHeapFlags = VkFlags;
pub type VkDeviceCreateFlags = VkFlags;
pub type VkDeviceQueueCreateFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 1,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 2,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 4,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 8,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 16,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 32,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 64,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 128,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 256,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 512,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 1024,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 2048,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 4096,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 8192,
    VK_PIPELINE_STAGE_HOST_BIT = 16384,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 32768,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 65536,
    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkPipelineStageFlags = VkFlags;
pub type VkMemoryMapFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 1,
    VK_IMAGE_ASPECT_DEPTH_BIT = 2,
    VK_IMAGE_ASPECT_STENCIL_BIT = 4,
    VK_IMAGE_ASPECT_METADATA_BIT = 8,
    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkImageAspectFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 1,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 2,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 4,
    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkSparseImageFormatFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 1,
    VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkSparseMemoryBindFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 1,
    VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkFenceCreateFlags = VkFlags;
pub type VkSemaphoreCreateFlags = VkFlags;
pub type VkEventCreateFlags = VkFlags;
pub type VkQueryPoolCreateFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 1,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 2,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 4,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 8,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 16,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 32,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 64,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 128,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 256,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT
    = 512,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 1024,
    VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkQueryPipelineStatisticFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 1,
    VK_QUERY_RESULT_WAIT_BIT = 2,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 4,
    VK_QUERY_RESULT_PARTIAL_BIT = 8,
    VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkQueryResultFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 1,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 4,
    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkBufferCreateFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 1,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 2,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 4,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 8,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 16,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 32,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 64,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 128,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 256,
    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkBufferUsageFlags = VkFlags;
pub type VkBufferViewCreateFlags = VkFlags;
pub type VkImageViewCreateFlags = VkFlags;
pub type VkShaderModuleCreateFlags = VkFlags;
pub type VkPipelineCacheCreateFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 1,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 2,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 4,
    VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkPipelineCreateFlags = VkFlags;
pub type VkPipelineShaderStageCreateFlags = VkFlags;

pub const VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM: VkShaderStageFlagBits =
VkShaderStageFlagBits::VK_SHADER_STAGE_ALL;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 1,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4,
    VK_SHADER_STAGE_GEOMETRY_BIT = 8,
    VK_SHADER_STAGE_FRAGMENT_BIT = 16,
    VK_SHADER_STAGE_COMPUTE_BIT = 32,
    VK_SHADER_STAGE_ALL_GRAPHICS = 31,
    VK_SHADER_STAGE_ALL = 2147483647,
}

pub type VkPipelineVertexInputStateCreateFlags = VkFlags;
pub type VkPipelineInputAssemblyStateCreateFlags = VkFlags;
pub type VkPipelineTessellationStateCreateFlags = VkFlags;
pub type VkPipelineViewportStateCreateFlags = VkFlags;
pub type VkPipelineRasterizationStateCreateFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 1,
    VK_CULL_MODE_BACK_BIT = 2,
    VK_CULL_MODE_FRONT_AND_BACK = 3,
    VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkCullModeFlags = VkFlags;
pub type VkPipelineMultisampleStateCreateFlags = VkFlags;
pub type VkPipelineDepthStencilStateCreateFlags = VkFlags;
pub type VkPipelineColorBlendStateCreateFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 1,
    VK_COLOR_COMPONENT_G_BIT = 2,
    VK_COLOR_COMPONENT_B_BIT = 4,
    VK_COLOR_COMPONENT_A_BIT = 8,
    VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkColorComponentFlags = VkFlags;
pub type VkPipelineDynamicStateCreateFlags = VkFlags;
pub type VkPipelineLayoutCreateFlags = VkFlags;
pub type VkShaderStageFlags = VkFlags;
pub type VkSamplerCreateFlags = VkFlags;
pub type VkDescriptorSetLayoutCreateFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 1,
    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkDescriptorPoolCreateFlags = VkFlags;
pub type VkDescriptorPoolResetFlags = VkFlags;
pub type VkFramebufferCreateFlags = VkFlags;
pub type VkRenderPassCreateFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 1,
    VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkAttachmentDescriptionFlags = VkFlags;
pub type VkSubpassDescriptionFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 1,
    VK_ACCESS_INDEX_READ_BIT = 2,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 4,
    VK_ACCESS_UNIFORM_READ_BIT = 8,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 16,
    VK_ACCESS_SHADER_READ_BIT = 32,
    VK_ACCESS_SHADER_WRITE_BIT = 64,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 128,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 256,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024,
    VK_ACCESS_TRANSFER_READ_BIT = 2048,
    VK_ACCESS_TRANSFER_WRITE_BIT = 4096,
    VK_ACCESS_HOST_READ_BIT = 8192,
    VK_ACCESS_HOST_WRITE_BIT = 16384,
    VK_ACCESS_MEMORY_READ_BIT = 32768,
    VK_ACCESS_MEMORY_WRITE_BIT = 65536,
    VK_ACCESS_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkAccessFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 1,
    VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkDependencyFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 1,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 2,
    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkCommandPoolCreateFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 1,
    VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkCommandPoolResetFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 2,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 4,
    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkCommandBufferUsageFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 1,
    VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkQueryControlFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 1,
    VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkCommandBufferResetFlags = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 1,
    VK_STENCIL_FACE_BACK_BIT = 2,
    VK_STENCIL_FRONT_AND_BACK = 3,
    VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 2147483647,
}

pub type VkStencilFaceFlags = VkFlags;
pub type PFN_vkAllocationFunction =
::std::option::Option<unsafe extern "C" fn(pUserData:
                                           *mut ::std::os::raw::c_void,
                                           size: size_t,
                                           alignment: size_t,
                                           allocationScope:
                                           VkSystemAllocationScope)
                                           -> *mut ::std::os::raw::c_void>;
pub type PFN_vkReallocationFunction =
::std::option::Option<unsafe extern "C" fn(pUserData:
                                           *mut ::std::os::raw::c_void,
                                           pOriginal:
                                           *mut ::std::os::raw::c_void,
                                           size: size_t,
                                           alignment: size_t,
                                           allocationScope:
                                           VkSystemAllocationScope)
                                           -> *mut ::std::os::raw::c_void>;
pub type PFN_vkFreeFunction =
::std::option::Option<unsafe extern "C" fn(pUserData:
                                           *mut ::std::os::raw::c_void,
                                           pMemory:
                                           *mut ::std::os::raw::c_void)>;
pub type PFN_vkInternalAllocationNotification =
::std::option::Option<unsafe extern "C" fn(pUserData:
                                           *mut ::std::os::raw::c_void,
                                           size: size_t,
                                           allocationType:
                                           VkInternalAllocationType,
                                           allocationScope:
                                           VkSystemAllocationScope)>;
pub type PFN_vkInternalFreeNotification =
::std::option::Option<unsafe extern "C" fn(pUserData:
                                           *mut ::std::os::raw::c_void,
                                           size: size_t,
                                           allocationType:
                                           VkInternalAllocationType,
                                           allocationScope:
                                           VkSystemAllocationScope)>;
pub type PFN_vkVoidFunction = unsafe extern "C" fn();

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkApplicationInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pApplicationName: *const ::std::os::raw::c_char,
    pub applicationVersion: uint32_t,
    pub pEngineName: *const ::std::os::raw::c_char,
    pub engineVersion: uint32_t,
    pub apiVersion: uint32_t,
}

impl ::std::default::Default for VkApplicationInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkInstanceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkInstanceCreateFlags,
    pub pApplicationInfo: *const VkApplicationInfo,
    pub enabledLayerCount: uint32_t,
    pub ppEnabledLayerNames: *const *const ::std::os::raw::c_char,
    pub enabledExtensionCount: uint32_t,
    pub ppEnabledExtensionNames: *const *const ::std::os::raw::c_char,
}

impl ::std::default::Default for VkInstanceCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkAllocationCallbacks {
    pub pUserData: *mut ::std::os::raw::c_void,
    pub pfnAllocation: PFN_vkAllocationFunction,
    pub pfnReallocation: PFN_vkReallocationFunction,
    pub pfnFree: PFN_vkFreeFunction,
    pub pfnInternalAllocation: PFN_vkInternalAllocationNotification,
    pub pfnInternalFree: PFN_vkInternalFreeNotification,
}

impl ::std::default::Default for VkAllocationCallbacks {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPhysicalDeviceFeatures {
    pub robustBufferAccess: VkBool32,
    pub fullDrawIndexUint32: VkBool32,
    pub imageCubeArray: VkBool32,
    pub independentBlend: VkBool32,
    pub geometryShader: VkBool32,
    pub tessellationShader: VkBool32,
    pub sampleRateShading: VkBool32,
    pub dualSrcBlend: VkBool32,
    pub logicOp: VkBool32,
    pub multiDrawIndirect: VkBool32,
    pub drawIndirectFirstInstance: VkBool32,
    pub depthClamp: VkBool32,
    pub depthBiasClamp: VkBool32,
    pub fillModeNonSolid: VkBool32,
    pub depthBounds: VkBool32,
    pub wideLines: VkBool32,
    pub largePoints: VkBool32,
    pub alphaToOne: VkBool32,
    pub multiViewport: VkBool32,
    pub samplerAnisotropy: VkBool32,
    pub textureCompressionETC2: VkBool32,
    pub textureCompressionASTC_LDR: VkBool32,
    pub textureCompressionBC: VkBool32,
    pub occlusionQueryPrecise: VkBool32,
    pub pipelineStatisticsQuery: VkBool32,
    pub vertexPipelineStoresAndAtomics: VkBool32,
    pub fragmentStoresAndAtomics: VkBool32,
    pub shaderTessellationAndGeometryPointSize: VkBool32,
    pub shaderImageGatherExtended: VkBool32,
    pub shaderStorageImageExtendedFormats: VkBool32,
    pub shaderStorageImageMultisample: VkBool32,
    pub shaderStorageImageReadWithoutFormat: VkBool32,
    pub shaderStorageImageWriteWithoutFormat: VkBool32,
    pub shaderUniformBufferArrayDynamicIndexing: VkBool32,
    pub shaderSampledImageArrayDynamicIndexing: VkBool32,
    pub shaderStorageBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageImageArrayDynamicIndexing: VkBool32,
    pub shaderClipDistance: VkBool32,
    pub shaderCullDistance: VkBool32,
    pub shaderFloat64: VkBool32,
    pub shaderInt64: VkBool32,
    pub shaderInt16: VkBool32,
    pub shaderResourceResidency: VkBool32,
    pub shaderResourceMinLod: VkBool32,
    pub sparseBinding: VkBool32,
    pub sparseResidencyBuffer: VkBool32,
    pub sparseResidencyImage2D: VkBool32,
    pub sparseResidencyImage3D: VkBool32,
    pub sparseResidency2Samples: VkBool32,
    pub sparseResidency4Samples: VkBool32,
    pub sparseResidency8Samples: VkBool32,
    pub sparseResidency16Samples: VkBool32,
    pub sparseResidencyAliased: VkBool32,
    pub variableMultisampleRate: VkBool32,
    pub inheritedQueries: VkBool32,
}

impl ::std::default::Default for VkPhysicalDeviceFeatures {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkFormatProperties {
    pub linearTilingFeatures: VkFormatFeatureFlags,
    pub optimalTilingFeatures: VkFormatFeatureFlags,
    pub bufferFeatures: VkFormatFeatureFlags,
}

impl ::std::default::Default for VkFormatProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkExtent3D {
    pub width: uint32_t,
    pub height: uint32_t,
    pub depth: uint32_t,
}

impl ::std::default::Default for VkExtent3D {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkImageFormatProperties {
    pub maxExtent: VkExtent3D,
    pub maxMipLevels: uint32_t,
    pub maxArrayLayers: uint32_t,
    pub sampleCounts: VkSampleCountFlags,
    pub maxResourceSize: VkDeviceSize,
}

impl ::std::default::Default for VkImageFormatProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPhysicalDeviceLimits {
    pub maxImageDimension1D: uint32_t,
    pub maxImageDimension2D: uint32_t,
    pub maxImageDimension3D: uint32_t,
    pub maxImageDimensionCube: uint32_t,
    pub maxImageArrayLayers: uint32_t,
    pub maxTexelBufferElements: uint32_t,
    pub maxUniformBufferRange: uint32_t,
    pub maxStorageBufferRange: uint32_t,
    pub maxPushConstantsSize: uint32_t,
    pub maxMemoryAllocationCount: uint32_t,
    pub maxSamplerAllocationCount: uint32_t,
    pub bufferImageGranularity: VkDeviceSize,
    pub sparseAddressSpaceSize: VkDeviceSize,
    pub maxBoundDescriptorSets: uint32_t,
    pub maxPerStageDescriptorSamplers: uint32_t,
    pub maxPerStageDescriptorUniformBuffers: uint32_t,
    pub maxPerStageDescriptorStorageBuffers: uint32_t,
    pub maxPerStageDescriptorSampledImages: uint32_t,
    pub maxPerStageDescriptorStorageImages: uint32_t,
    pub maxPerStageDescriptorInputAttachments: uint32_t,
    pub maxPerStageResources: uint32_t,
    pub maxDescriptorSetSamplers: uint32_t,
    pub maxDescriptorSetUniformBuffers: uint32_t,
    pub maxDescriptorSetUniformBuffersDynamic: uint32_t,
    pub maxDescriptorSetStorageBuffers: uint32_t,
    pub maxDescriptorSetStorageBuffersDynamic: uint32_t,
    pub maxDescriptorSetSampledImages: uint32_t,
    pub maxDescriptorSetStorageImages: uint32_t,
    pub maxDescriptorSetInputAttachments: uint32_t,
    pub maxVertexInputAttributes: uint32_t,
    pub maxVertexInputBindings: uint32_t,
    pub maxVertexInputAttributeOffset: uint32_t,
    pub maxVertexInputBindingStride: uint32_t,
    pub maxVertexOutputComponents: uint32_t,
    pub maxTessellationGenerationLevel: uint32_t,
    pub maxTessellationPatchSize: uint32_t,
    pub maxTessellationControlPerVertexInputComponents: uint32_t,
    pub maxTessellationControlPerVertexOutputComponents: uint32_t,
    pub maxTessellationControlPerPatchOutputComponents: uint32_t,
    pub maxTessellationControlTotalOutputComponents: uint32_t,
    pub maxTessellationEvaluationInputComponents: uint32_t,
    pub maxTessellationEvaluationOutputComponents: uint32_t,
    pub maxGeometryShaderInvocations: uint32_t,
    pub maxGeometryInputComponents: uint32_t,
    pub maxGeometryOutputComponents: uint32_t,
    pub maxGeometryOutputVertices: uint32_t,
    pub maxGeometryTotalOutputComponents: uint32_t,
    pub maxFragmentInputComponents: uint32_t,
    pub maxFragmentOutputAttachments: uint32_t,
    pub maxFragmentDualSrcAttachments: uint32_t,
    pub maxFragmentCombinedOutputResources: uint32_t,
    pub maxComputeSharedMemorySize: uint32_t,
    pub maxComputeWorkGroupCount: [uint32_t; 3usize],
    pub maxComputeWorkGroupInvocations: uint32_t,
    pub maxComputeWorkGroupSize: [uint32_t; 3usize],
    pub subPixelPrecisionBits: uint32_t,
    pub subTexelPrecisionBits: uint32_t,
    pub mipmapPrecisionBits: uint32_t,
    pub maxDrawIndexedIndexValue: uint32_t,
    pub maxDrawIndirectCount: uint32_t,
    pub maxSamplerLodBias: f32,
    pub maxSamplerAnisotropy: f32,
    pub maxViewports: uint32_t,
    pub maxViewportDimensions: [uint32_t; 2usize],
    pub viewportBoundsRange: [f32; 2usize],
    pub viewportSubPixelBits: uint32_t,
    pub minMemoryMapAlignment: size_t,
    pub minTexelBufferOffsetAlignment: VkDeviceSize,
    pub minUniformBufferOffsetAlignment: VkDeviceSize,
    pub minStorageBufferOffsetAlignment: VkDeviceSize,
    pub minTexelOffset: int32_t,
    pub maxTexelOffset: uint32_t,
    pub minTexelGatherOffset: int32_t,
    pub maxTexelGatherOffset: uint32_t,
    pub minInterpolationOffset: f32,
    pub maxInterpolationOffset: f32,
    pub subPixelInterpolationOffsetBits: uint32_t,
    pub maxFramebufferWidth: uint32_t,
    pub maxFramebufferHeight: uint32_t,
    pub maxFramebufferLayers: uint32_t,
    pub framebufferColorSampleCounts: VkSampleCountFlags,
    pub framebufferDepthSampleCounts: VkSampleCountFlags,
    pub framebufferStencilSampleCounts: VkSampleCountFlags,
    pub framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
    pub maxColorAttachments: uint32_t,
    pub sampledImageColorSampleCounts: VkSampleCountFlags,
    pub sampledImageIntegerSampleCounts: VkSampleCountFlags,
    pub sampledImageDepthSampleCounts: VkSampleCountFlags,
    pub sampledImageStencilSampleCounts: VkSampleCountFlags,
    pub storageImageSampleCounts: VkSampleCountFlags,
    pub maxSampleMaskWords: uint32_t,
    pub timestampComputeAndGraphics: VkBool32,
    pub timestampPeriod: f32,
    pub maxClipDistances: uint32_t,
    pub maxCullDistances: uint32_t,
    pub maxCombinedClipAndCullDistances: uint32_t,
    pub discreteQueuePriorities: uint32_t,
    pub pointSizeRange: [f32; 2usize],
    pub lineWidthRange: [f32; 2usize],
    pub pointSizeGranularity: f32,
    pub lineWidthGranularity: f32,
    pub strictLines: VkBool32,
    pub standardSampleLocations: VkBool32,
    pub optimalBufferCopyOffsetAlignment: VkDeviceSize,
    pub optimalBufferCopyRowPitchAlignment: VkDeviceSize,
    pub nonCoherentAtomSize: VkDeviceSize,
}

impl ::std::default::Default for VkPhysicalDeviceLimits {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPhysicalDeviceSparseProperties {
    pub residencyStandard2DBlockShape: VkBool32,
    pub residencyStandard2DMultisampleBlockShape: VkBool32,
    pub residencyStandard3DBlockShape: VkBool32,
    pub residencyAlignedMipSize: VkBool32,
    pub residencyNonResidentStrict: VkBool32,
}

impl ::std::default::Default for VkPhysicalDeviceSparseProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy)]
pub struct VkPhysicalDeviceProperties {
    pub apiVersion: uint32_t,
    pub driverVersion: uint32_t,
    pub vendorID: uint32_t,
    pub deviceID: uint32_t,
    pub deviceType: VkPhysicalDeviceType,
    pub deviceName: [::std::os::raw::c_char; 256usize],
    pub pipelineCacheUUID: [uint8_t; 16usize],
    pub limits: VkPhysicalDeviceLimits,
    pub sparseProperties: VkPhysicalDeviceSparseProperties,
}

impl ::std::clone::Clone for VkPhysicalDeviceProperties {
    fn clone(&self) -> Self { *self }
}

impl ::std::default::Default for VkPhysicalDeviceProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkQueueFamilyProperties {
    pub queueFlags: VkQueueFlags,
    pub queueCount: uint32_t,
    pub timestampValidBits: uint32_t,
    pub minImageTransferGranularity: VkExtent3D,
}

impl ::std::default::Default for VkQueueFamilyProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkMemoryType {
    pub propertyFlags: VkMemoryPropertyFlags,
    pub heapIndex: uint32_t,
}

impl ::std::default::Default for VkMemoryType {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkMemoryHeap {
    pub size: VkDeviceSize,
    pub flags: VkMemoryHeapFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkMemoryHeap {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPhysicalDeviceMemoryProperties {
    pub memoryTypeCount: uint32_t,
    pub memoryTypes: [VkMemoryType; 32usize],
    pub memoryHeapCount: uint32_t,
    pub memoryHeaps: [VkMemoryHeap; 16usize],
}

impl ::std::default::Default for VkPhysicalDeviceMemoryProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDeviceQueueCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceQueueCreateFlags,
    pub queueFamilyIndex: uint32_t,
    pub queueCount: uint32_t,
    pub pQueuePriorities: *const f32,
}

impl ::std::default::Default for VkDeviceQueueCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDeviceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceCreateFlags,
    pub queueCreateInfoCount: uint32_t,
    pub pQueueCreateInfos: *const VkDeviceQueueCreateInfo,
    pub enabledLayerCount: uint32_t,
    pub ppEnabledLayerNames: *const *const ::std::os::raw::c_char,
    pub enabledExtensionCount: uint32_t,
    pub ppEnabledExtensionNames: *const *const ::std::os::raw::c_char,
    pub pEnabledFeatures: *const VkPhysicalDeviceFeatures,
}

impl ::std::default::Default for VkDeviceCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy)]
pub struct VkExtensionProperties {
    pub extensionName: [::std::os::raw::c_char; 256usize],
    pub specVersion: uint32_t,
}

impl ::std::clone::Clone for VkExtensionProperties {
    fn clone(&self) -> Self { *self }
}

impl ::std::default::Default for VkExtensionProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy)]
pub struct VkLayerProperties {
    pub layerName: [::std::os::raw::c_char; 256usize],
    pub specVersion: uint32_t,
    pub implementationVersion: uint32_t,
    pub description: [::std::os::raw::c_char; 256usize],
}

impl ::std::clone::Clone for VkLayerProperties {
    fn clone(&self) -> Self { *self }
}

impl ::std::default::Default for VkLayerProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: uint32_t,
    pub pWaitSemaphores: *const VkSemaphore,
    pub pWaitDstStageMask: *const VkPipelineStageFlags,
    pub commandBufferCount: uint32_t,
    pub pCommandBuffers: *const VkCommandBuffer,
    pub signalSemaphoreCount: uint32_t,
    pub pSignalSemaphores: *const VkSemaphore,
}

impl ::std::default::Default for VkSubmitInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkMemoryAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub allocationSize: VkDeviceSize,
    pub memoryTypeIndex: uint32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkMemoryAllocateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkMappedMemoryRange {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}

impl ::std::default::Default for VkMappedMemoryRange {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkMemoryRequirements {
    pub size: VkDeviceSize,
    pub alignment: VkDeviceSize,
    pub memoryTypeBits: uint32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkMemoryRequirements {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSparseImageFormatProperties {
    pub aspectMask: VkImageAspectFlags,
    pub imageGranularity: VkExtent3D,
    pub flags: VkSparseImageFormatFlags,
}

impl ::std::default::Default for VkSparseImageFormatProperties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSparseImageMemoryRequirements {
    pub formatProperties: VkSparseImageFormatProperties,
    pub imageMipTailFirstLod: uint32_t,
    pub imageMipTailSize: VkDeviceSize,
    pub imageMipTailOffset: VkDeviceSize,
    pub imageMipTailStride: VkDeviceSize,
}

impl ::std::default::Default for VkSparseImageMemoryRequirements {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSparseMemoryBind {
    pub resourceOffset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkSparseMemoryBind {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSparseBufferMemoryBindInfo {
    pub buffer: VkBuffer,
    pub bindCount: uint32_t,
    pub pBinds: *const VkSparseMemoryBind,
}

impl ::std::default::Default for VkSparseBufferMemoryBindInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSparseImageOpaqueMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: uint32_t,
    pub pBinds: *const VkSparseMemoryBind,
}

impl ::std::default::Default for VkSparseImageOpaqueMemoryBindInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkImageSubresource {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: uint32_t,
    pub arrayLayer: uint32_t,
}

impl ::std::default::Default for VkImageSubresource {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkOffset3D {
    pub x: int32_t,
    pub y: int32_t,
    pub z: int32_t,
}

impl ::std::default::Default for VkOffset3D {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSparseImageMemoryBind {
    pub subresource: VkImageSubresource,
    pub offset: VkOffset3D,
    pub extent: VkExtent3D,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkSparseImageMemoryBind {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSparseImageMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: uint32_t,
    pub pBinds: *const VkSparseImageMemoryBind,
}

impl ::std::default::Default for VkSparseImageMemoryBindInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkBindSparseInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: uint32_t,
    pub pWaitSemaphores: *const VkSemaphore,
    pub bufferBindCount: uint32_t,
    pub pBufferBinds: *const VkSparseBufferMemoryBindInfo,
    pub imageOpaqueBindCount: uint32_t,
    pub pImageOpaqueBinds: *const VkSparseImageOpaqueMemoryBindInfo,
    pub imageBindCount: uint32_t,
    pub pImageBinds: *const VkSparseImageMemoryBindInfo,
    pub signalSemaphoreCount: uint32_t,
    pub pSignalSemaphores: *const VkSemaphore,
}

impl ::std::default::Default for VkBindSparseInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkFenceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkFenceCreateFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkFenceCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSemaphoreCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSemaphoreCreateFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkSemaphoreCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkEventCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkEventCreateFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkEventCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkQueryPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkQueryPoolCreateFlags,
    pub queryType: VkQueryType,
    pub queryCount: uint32_t,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}

impl ::std::default::Default for VkQueryPoolCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkBufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferCreateFlags,
    pub size: VkDeviceSize,
    pub usage: VkBufferUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: uint32_t,
    pub pQueueFamilyIndices: *const uint32_t,
}

impl ::std::default::Default for VkBufferCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkBufferViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferViewCreateFlags,
    pub buffer: VkBuffer,
    pub format: VkFormat,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}

impl ::std::default::Default for VkBufferViewCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkImageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageCreateFlags,
    pub imageType: VkImageType,
    pub format: VkFormat,
    pub extent: VkExtent3D,
    pub mipLevels: uint32_t,
    pub arrayLayers: uint32_t,
    pub samples: VkSampleCountFlagBits,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: uint32_t,
    pub pQueueFamilyIndices: *const uint32_t,
    pub initialLayout: VkImageLayout,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkImageCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSubresourceLayout {
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub rowPitch: VkDeviceSize,
    pub arrayPitch: VkDeviceSize,
    pub depthPitch: VkDeviceSize,
}

impl ::std::default::Default for VkSubresourceLayout {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkComponentMapping {
    pub r: VkComponentSwizzle,
    pub g: VkComponentSwizzle,
    pub b: VkComponentSwizzle,
    pub a: VkComponentSwizzle,
}

impl ::std::default::Default for VkComponentMapping {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkImageSubresourceRange {
    pub aspectMask: VkImageAspectFlags,
    pub baseMipLevel: uint32_t,
    pub levelCount: uint32_t,
    pub baseArrayLayer: uint32_t,
    pub layerCount: uint32_t,
}

impl ::std::default::Default for VkImageSubresourceRange {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkImageViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageViewCreateFlags,
    pub image: VkImage,
    pub viewType: VkImageViewType,
    pub format: VkFormat,
    pub components: VkComponentMapping,
    pub subresourceRange: VkImageSubresourceRange,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkImageViewCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkShaderModuleCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkShaderModuleCreateFlags,
    pub codeSize: size_t,
    pub pCode: *const uint32_t,
}

impl ::std::default::Default for VkShaderModuleCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineCacheCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCacheCreateFlags,
    pub initialDataSize: size_t,
    pub pInitialData: *const ::std::os::raw::c_void,
}

impl ::std::default::Default for VkPipelineCacheCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSpecializationMapEntry {
    pub constantID: uint32_t,
    pub offset: uint32_t,
    pub size: size_t,
}

impl ::std::default::Default for VkSpecializationMapEntry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSpecializationInfo {
    pub mapEntryCount: uint32_t,
    pub pMapEntries: *const VkSpecializationMapEntry,
    pub dataSize: size_t,
    pub pData: *const ::std::os::raw::c_void,
}

impl ::std::default::Default for VkSpecializationInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineShaderStageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineShaderStageCreateFlags,
    pub stage: VkShaderStageFlagBits,
    pub module: VkShaderModule,
    pub pName: *const ::std::os::raw::c_char,
    pub pSpecializationInfo: *const VkSpecializationInfo,
}

impl ::std::default::Default for VkPipelineShaderStageCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkVertexInputBindingDescription {
    pub binding: uint32_t,
    pub stride: uint32_t,
    pub inputRate: VkVertexInputRate,
}

impl ::std::default::Default for VkVertexInputBindingDescription {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkVertexInputAttributeDescription {
    pub location: uint32_t,
    pub binding: uint32_t,
    pub format: VkFormat,
    pub offset: uint32_t,
}

impl ::std::default::Default for VkVertexInputAttributeDescription {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineVertexInputStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineVertexInputStateCreateFlags,
    pub vertexBindingDescriptionCount: uint32_t,
    pub pVertexBindingDescriptions: *const VkVertexInputBindingDescription,
    pub vertexAttributeDescriptionCount: uint32_t,
    pub pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription,
}

impl ::std::default::Default for VkPipelineVertexInputStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineInputAssemblyStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineInputAssemblyStateCreateFlags,
    pub topology: VkPrimitiveTopology,
    pub primitiveRestartEnable: VkBool32,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkPipelineInputAssemblyStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineTessellationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineTessellationStateCreateFlags,
    pub patchControlPoints: uint32_t,
}

impl ::std::default::Default for VkPipelineTessellationStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkViewport {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub minDepth: f32,
    pub maxDepth: f32,
}

impl ::std::default::Default for VkViewport {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkOffset2D {
    pub x: int32_t,
    pub y: int32_t,
}

impl ::std::default::Default for VkOffset2D {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkExtent2D {
    pub width: uint32_t,
    pub height: uint32_t,
}

impl ::std::default::Default for VkExtent2D {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkRect2D {
    pub offset: VkOffset2D,
    pub extent: VkExtent2D,
}

impl ::std::default::Default for VkRect2D {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineViewportStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineViewportStateCreateFlags,
    pub viewportCount: uint32_t,
    pub pViewports: *const VkViewport,
    pub scissorCount: uint32_t,
    pub pScissors: *const VkRect2D,
}

impl ::std::default::Default for VkPipelineViewportStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineRasterizationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineRasterizationStateCreateFlags,
    pub depthClampEnable: VkBool32,
    pub rasterizerDiscardEnable: VkBool32,
    pub polygonMode: VkPolygonMode,
    pub cullMode: VkCullModeFlags,
    pub frontFace: VkFrontFace,
    pub depthBiasEnable: VkBool32,
    pub depthBiasConstantFactor: f32,
    pub depthBiasClamp: f32,
    pub depthBiasSlopeFactor: f32,
    pub lineWidth: f32,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkPipelineRasterizationStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineMultisampleStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineMultisampleStateCreateFlags,
    pub rasterizationSamples: VkSampleCountFlagBits,
    pub sampleShadingEnable: VkBool32,
    pub minSampleShading: f32,
    pub pSampleMask: *const VkSampleMask,
    pub alphaToCoverageEnable: VkBool32,
    pub alphaToOneEnable: VkBool32,
}

impl ::std::default::Default for VkPipelineMultisampleStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkStencilOpState {
    pub failOp: VkStencilOp,
    pub passOp: VkStencilOp,
    pub depthFailOp: VkStencilOp,
    pub compareOp: VkCompareOp,
    pub compareMask: uint32_t,
    pub writeMask: uint32_t,
    pub reference: uint32_t,
}

impl ::std::default::Default for VkStencilOpState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineDepthStencilStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDepthStencilStateCreateFlags,
    pub depthTestEnable: VkBool32,
    pub depthWriteEnable: VkBool32,
    pub depthCompareOp: VkCompareOp,
    pub depthBoundsTestEnable: VkBool32,
    pub stencilTestEnable: VkBool32,
    pub front: VkStencilOpState,
    pub back: VkStencilOpState,
    pub minDepthBounds: f32,
    pub maxDepthBounds: f32,
}

impl ::std::default::Default for VkPipelineDepthStencilStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineColorBlendAttachmentState {
    pub blendEnable: VkBool32,
    pub srcColorBlendFactor: VkBlendFactor,
    pub dstColorBlendFactor: VkBlendFactor,
    pub colorBlendOp: VkBlendOp,
    pub srcAlphaBlendFactor: VkBlendFactor,
    pub dstAlphaBlendFactor: VkBlendFactor,
    pub alphaBlendOp: VkBlendOp,
    pub colorWriteMask: VkColorComponentFlags,
}

impl ::std::default::Default for VkPipelineColorBlendAttachmentState {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineColorBlendStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineColorBlendStateCreateFlags,
    pub logicOpEnable: VkBool32,
    pub logicOp: VkLogicOp,
    pub attachmentCount: uint32_t,
    pub pAttachments: *const VkPipelineColorBlendAttachmentState,
    pub blendConstants: [f32; 4usize],
}

impl ::std::default::Default for VkPipelineColorBlendStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineDynamicStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDynamicStateCreateFlags,
    pub dynamicStateCount: uint32_t,
    pub pDynamicStates: *const VkDynamicState,
}

impl ::std::default::Default for VkPipelineDynamicStateCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkGraphicsPipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stageCount: uint32_t,
    pub pStages: *const VkPipelineShaderStageCreateInfo,
    pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
    pub pInputAssemblyState: *const VkPipelineInputAssemblyStateCreateInfo,
    pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
    pub pViewportState: *const VkPipelineViewportStateCreateInfo,
    pub pRasterizationState: *const VkPipelineRasterizationStateCreateInfo,
    pub pMultisampleState: *const VkPipelineMultisampleStateCreateInfo,
    pub pDepthStencilState: *const VkPipelineDepthStencilStateCreateInfo,
    pub pColorBlendState: *const VkPipelineColorBlendStateCreateInfo,
    pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
    pub layout: VkPipelineLayout,
    pub renderPass: VkRenderPass,
    pub subpass: uint32_t,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: int32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkGraphicsPipelineCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkComputePipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stage: VkPipelineShaderStageCreateInfo,
    pub layout: VkPipelineLayout,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: int32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkComputePipelineCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPushConstantRange {
    pub stageFlags: VkShaderStageFlags,
    pub offset: uint32_t,
    pub size: uint32_t,
}

impl ::std::default::Default for VkPushConstantRange {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPipelineLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineLayoutCreateFlags,
    pub setLayoutCount: uint32_t,
    pub pSetLayouts: *const VkDescriptorSetLayout,
    pub pushConstantRangeCount: uint32_t,
    pub pPushConstantRanges: *const VkPushConstantRange,
}

impl ::std::default::Default for VkPipelineLayoutCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSamplerCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSamplerCreateFlags,
    pub magFilter: VkFilter,
    pub minFilter: VkFilter,
    pub mipmapMode: VkSamplerMipmapMode,
    pub addressModeU: VkSamplerAddressMode,
    pub addressModeV: VkSamplerAddressMode,
    pub addressModeW: VkSamplerAddressMode,
    pub mipLodBias: f32,
    pub anisotropyEnable: VkBool32,
    pub maxAnisotropy: f32,
    pub compareEnable: VkBool32,
    pub compareOp: VkCompareOp,
    pub minLod: f32,
    pub maxLod: f32,
    pub borderColor: VkBorderColor,
    pub unnormalizedCoordinates: VkBool32,
}

impl ::std::default::Default for VkSamplerCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDescriptorSetLayoutBinding {
    pub binding: uint32_t,
    pub descriptorType: VkDescriptorType,
    pub descriptorCount: uint32_t,
    pub stageFlags: VkShaderStageFlags,
    pub pImmutableSamplers: *const VkSampler,
}

impl ::std::default::Default for VkDescriptorSetLayoutBinding {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDescriptorSetLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorSetLayoutCreateFlags,
    pub bindingCount: uint32_t,
    pub pBindings: *const VkDescriptorSetLayoutBinding,
}

impl ::std::default::Default for VkDescriptorSetLayoutCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDescriptorPoolSize {
    pub type_: VkDescriptorType,
    pub descriptorCount: uint32_t,
}

impl ::std::default::Default for VkDescriptorPoolSize {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDescriptorPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorPoolCreateFlags,
    pub maxSets: uint32_t,
    pub poolSizeCount: uint32_t,
    pub pPoolSizes: *const VkDescriptorPoolSize,
}

impl ::std::default::Default for VkDescriptorPoolCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDescriptorSetAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub descriptorPool: VkDescriptorPool,
    pub descriptorSetCount: uint32_t,
    pub pSetLayouts: *const VkDescriptorSetLayout,
}

impl ::std::default::Default for VkDescriptorSetAllocateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDescriptorImageInfo {
    pub sampler: VkSampler,
    pub imageView: VkImageView,
    pub imageLayout: VkImageLayout,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkDescriptorImageInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDescriptorBufferInfo {
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}

impl ::std::default::Default for VkDescriptorBufferInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkWriteDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: uint32_t,
    pub dstArrayElement: uint32_t,
    pub descriptorCount: uint32_t,
    pub descriptorType: VkDescriptorType,
    pub pImageInfo: *const VkDescriptorImageInfo,
    pub pBufferInfo: *const VkDescriptorBufferInfo,
    pub pTexelBufferView: *const VkBufferView,
}

impl ::std::default::Default for VkWriteDescriptorSet {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkCopyDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcSet: VkDescriptorSet,
    pub srcBinding: uint32_t,
    pub srcArrayElement: uint32_t,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: uint32_t,
    pub dstArrayElement: uint32_t,
    pub descriptorCount: uint32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkCopyDescriptorSet {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkFramebufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkFramebufferCreateFlags,
    pub renderPass: VkRenderPass,
    pub attachmentCount: uint32_t,
    pub pAttachments: *const VkImageView,
    pub width: uint32_t,
    pub height: uint32_t,
    pub layers: uint32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkFramebufferCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkAttachmentDescription {
    pub flags: VkAttachmentDescriptionFlags,
    pub format: VkFormat,
    pub samples: VkSampleCountFlagBits,
    pub loadOp: VkAttachmentLoadOp,
    pub storeOp: VkAttachmentStoreOp,
    pub stencilLoadOp: VkAttachmentLoadOp,
    pub stencilStoreOp: VkAttachmentStoreOp,
    pub initialLayout: VkImageLayout,
    pub finalLayout: VkImageLayout,
}

impl ::std::default::Default for VkAttachmentDescription {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkAttachmentReference {
    pub attachment: uint32_t,
    pub layout: VkImageLayout,
}

impl ::std::default::Default for VkAttachmentReference {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSubpassDescription {
    pub flags: VkSubpassDescriptionFlags,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub inputAttachmentCount: uint32_t,
    pub pInputAttachments: *const VkAttachmentReference,
    pub colorAttachmentCount: uint32_t,
    pub pColorAttachments: *const VkAttachmentReference,
    pub pResolveAttachments: *const VkAttachmentReference,
    pub pDepthStencilAttachment: *const VkAttachmentReference,
    pub preserveAttachmentCount: uint32_t,
    pub pPreserveAttachments: *const uint32_t,
}

impl ::std::default::Default for VkSubpassDescription {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSubpassDependency {
    pub srcSubpass: uint32_t,
    pub dstSubpass: uint32_t,
    pub srcStageMask: VkPipelineStageFlags,
    pub dstStageMask: VkPipelineStageFlags,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub dependencyFlags: VkDependencyFlags,
}

impl ::std::default::Default for VkSubpassDependency {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkRenderPassCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkRenderPassCreateFlags,
    pub attachmentCount: uint32_t,
    pub pAttachments: *const VkAttachmentDescription,
    pub subpassCount: uint32_t,
    pub pSubpasses: *const VkSubpassDescription,
    pub dependencyCount: uint32_t,
    pub pDependencies: *const VkSubpassDependency,
}

impl ::std::default::Default for VkRenderPassCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkCommandPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkCommandPoolCreateFlags,
    pub queueFamilyIndex: uint32_t,
}

impl ::std::default::Default for VkCommandPoolCreateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkCommandBufferAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub commandPool: VkCommandPool,
    pub level: VkCommandBufferLevel,
    pub commandBufferCount: uint32_t,
}

impl ::std::default::Default for VkCommandBufferAllocateInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkCommandBufferInheritanceInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub renderPass: VkRenderPass,
    pub subpass: uint32_t,
    pub framebuffer: VkFramebuffer,
    pub occlusionQueryEnable: VkBool32,
    pub queryFlags: VkQueryControlFlags,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkCommandBufferInheritanceInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkCommandBufferBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkCommandBufferUsageFlags,
    pub pInheritanceInfo: *const VkCommandBufferInheritanceInfo,
}

impl ::std::default::Default for VkCommandBufferBeginInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkBufferCopy {
    pub srcOffset: VkDeviceSize,
    pub dstOffset: VkDeviceSize,
    pub size: VkDeviceSize,
}

impl ::std::default::Default for VkBufferCopy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkImageSubresourceLayers {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: uint32_t,
    pub baseArrayLayer: uint32_t,
    pub layerCount: uint32_t,
}

impl ::std::default::Default for VkImageSubresourceLayers {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkImageCopy {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}

impl ::std::default::Default for VkImageCopy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkImageBlit {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffsets: [VkOffset3D; 2usize],
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffsets: [VkOffset3D; 2usize],
}

impl ::std::default::Default for VkImageBlit {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkBufferImageCopy {
    pub bufferOffset: VkDeviceSize,
    pub bufferRowLength: uint32_t,
    pub bufferImageHeight: uint32_t,
    pub imageSubresource: VkImageSubresourceLayers,
    pub imageOffset: VkOffset3D,
    pub imageExtent: VkExtent3D,
}

impl ::std::default::Default for VkBufferImageCopy {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkClearColorValue {
    pub _bindgen_data_: [u32; 4usize],
}

impl VkClearColorValue {
    pub unsafe fn float32(&mut self) -> *mut [f32; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn int32(&mut self) -> *mut [int32_t; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn uint32(&mut self) -> *mut [uint32_t; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}

impl ::std::default::Default for VkClearColorValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkClearDepthStencilValue {
    pub depth: f32,
    pub stencil: uint32_t,
}

impl ::std::default::Default for VkClearDepthStencilValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkClearValue {
    pub _bindgen_data_: [u32; 4usize],
}

impl VkClearValue {
    pub unsafe fn color(&mut self) -> *mut VkClearColorValue {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn depthStencil(&mut self) -> *mut VkClearDepthStencilValue {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}

impl ::std::default::Default for VkClearValue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkClearAttachment {
    pub aspectMask: VkImageAspectFlags,
    pub colorAttachment: uint32_t,
    pub clearValue: VkClearValue,
}

impl ::std::default::Default for VkClearAttachment {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkClearRect {
    pub rect: VkRect2D,
    pub baseArrayLayer: uint32_t,
    pub layerCount: uint32_t,
}

impl ::std::default::Default for VkClearRect {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkImageResolve {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}

impl ::std::default::Default for VkImageResolve {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
}

impl ::std::default::Default for VkMemoryBarrier {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkBufferMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub srcQueueFamilyIndex: uint32_t,
    pub dstQueueFamilyIndex: uint32_t,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}

impl ::std::default::Default for VkBufferMemoryBarrier {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkImageMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub oldLayout: VkImageLayout,
    pub newLayout: VkImageLayout,
    pub srcQueueFamilyIndex: uint32_t,
    pub dstQueueFamilyIndex: uint32_t,
    pub image: VkImage,
    pub subresourceRange: VkImageSubresourceRange,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkImageMemoryBarrier {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkRenderPassBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub renderPass: VkRenderPass,
    pub framebuffer: VkFramebuffer,
    pub renderArea: VkRect2D,
    pub clearValueCount: uint32_t,
    pub pClearValues: *const VkClearValue,
}

impl ::std::default::Default for VkRenderPassBeginInfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDispatchIndirectCommand {
    pub x: uint32_t,
    pub y: uint32_t,
    pub z: uint32_t,
}

impl ::std::default::Default for VkDispatchIndirectCommand {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDrawIndexedIndirectCommand {
    pub indexCount: uint32_t,
    pub instanceCount: uint32_t,
    pub firstIndex: uint32_t,
    pub vertexOffset: int32_t,
    pub firstInstance: uint32_t,
}

impl ::std::default::Default for VkDrawIndexedIndirectCommand {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDrawIndirectCommand {
    pub vertexCount: uint32_t,
    pub instanceCount: uint32_t,
    pub firstVertex: uint32_t,
    pub firstInstance: uint32_t,
}

impl ::std::default::Default for VkDrawIndirectCommand {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

pub type PFN_vkCreateInstance = unsafe extern "C" fn(
    pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks,
    pInstance: *mut VkInstance) -> VkResult;
pub type PFN_vkDestroyInstance = unsafe extern "C" fn(
    instance: VkInstance, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkEnumeratePhysicalDevices = unsafe extern "C" fn(
    instance: VkInstance, pPhysicalDeviceCount: *mut uint32_t,
    pPhysicalDevices: *mut VkPhysicalDevice) -> VkResult;
pub type PFN_vkGetPhysicalDeviceFeatures = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures);
pub type PFN_vkGetPhysicalDeviceFormatProperties = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, format: VkFormat, pFormatProperties: *mut VkFormatProperties);
pub type PFN_vkGetPhysicalDeviceImageFormatProperties = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType, tiling: VkImageTiling,
    usage: VkImageUsageFlags, flags: VkImageCreateFlags,
    pImageFormatProperties: *mut VkImageFormatProperties) -> VkResult;
pub type PFN_vkGetPhysicalDeviceProperties = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties);
pub type PFN_vkGetPhysicalDeviceQueueFamilyProperties = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t,
    pQueueFamilyProperties: *mut VkQueueFamilyProperties);
pub type PFN_vkGetPhysicalDeviceMemoryProperties = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties);
pub type PFN_vkGetInstanceProcAddr = unsafe extern "C" fn(
    instance: VkInstance, pName: *const ::std::os::raw::c_char) -> PFN_vkVoidFunction;
pub type PFN_vkGetDeviceProcAddr = unsafe extern "C" fn(
    device: VkDevice, pName: *const ::std::os::raw::c_char) -> PFN_vkVoidFunction;
pub type PFN_vkCreateDevice = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, pCreateInfo: *const VkDeviceCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pDevice: *mut VkDevice) -> VkResult;
pub type PFN_vkDestroyDevice = unsafe extern "C" fn(
    device: VkDevice, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkEnumerateInstanceExtensionProperties = unsafe extern "C" fn(
    pLayerName: *const ::std::os::raw::c_char, pPropertyCount: *mut uint32_t,
    pProperties: *mut VkExtensionProperties) -> VkResult;
pub type PFN_vkEnumerateDeviceExtensionProperties = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, pLayerName: *const ::std::os::raw::c_char,
    pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult;
pub type PFN_vkEnumerateInstanceLayerProperties = unsafe extern "C" fn(
    pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult;
pub type PFN_vkEnumerateDeviceLayerProperties = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t,
    pProperties: *mut VkLayerProperties) -> VkResult;
pub type PFN_vkGetDeviceQueue = unsafe extern "C" fn(
    device: VkDevice, queueFamilyIndex: uint32_t, queueIndex: uint32_t, pQueue: *mut VkQueue);
pub type PFN_vkQueueSubmit = unsafe extern "C" fn(
    queue: VkQueue, submitCount: uint32_t, pSubmits: *const VkSubmitInfo,
    fence: VkFence) -> VkResult;
pub type PFN_vkQueueWaitIdle = extern "C" fn(queue: VkQueue) -> VkResult;
pub type PFN_vkDeviceWaitIdle = extern "C" fn(device: VkDevice) -> VkResult;
pub type PFN_vkAllocateMemory = unsafe extern "C" fn(
    device: VkDevice, pAllocateInfo: *const VkMemoryAllocateInfo,
    pAllocator: *const VkAllocationCallbacks, pMemory: *mut VkDeviceMemory) -> VkResult;
pub type PFN_vkFreeMemory = unsafe extern "C" fn(
    device: VkDevice, memory: VkDeviceMemory, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkMapMemory = unsafe extern "C" fn(
    device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize,
    flags: VkMemoryMapFlags, ppData: *mut *mut ::std::os::raw::c_void) -> VkResult;
pub type PFN_vkUnmapMemory = extern "C" fn(device: VkDevice, memory: VkDeviceMemory);
pub type PFN_vkFlushMappedMemoryRanges = unsafe extern "C" fn(
    device: VkDevice, memoryRangeCount: uint32_t,
    pMemoryRanges: *const VkMappedMemoryRange) -> VkResult;
pub type PFN_vkInvalidateMappedMemoryRanges = unsafe extern "C" fn(
    device: VkDevice, memoryRangeCount: uint32_t,
    pMemoryRanges: *const VkMappedMemoryRange) -> VkResult;
pub type PFN_vkGetDeviceMemoryCommitment = unsafe extern "C" fn(
    device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *mut VkDeviceSize);
pub type PFN_vkBindBufferMemory = extern "C" fn(
    device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory,
    memoryOffset: VkDeviceSize) -> VkResult;
pub type PFN_vkBindImageMemory = extern "C" fn(
    device: VkDevice, image: VkImage, memory: VkDeviceMemory,
    memoryOffset: VkDeviceSize) -> VkResult;
pub type PFN_vkGetBufferMemoryRequirements = unsafe extern "C" fn(
    device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *mut VkMemoryRequirements);
pub type PFN_vkGetImageMemoryRequirements = unsafe extern "C" fn(
    device: VkDevice, image: VkImage, pMemoryRequirements: *mut VkMemoryRequirements);
pub type PFN_vkGetImageSparseMemoryRequirements = unsafe extern "C" fn(
    device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *mut uint32_t,
    pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements);
pub type PFN_vkGetPhysicalDeviceSparseImageFormatProperties = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType,
    samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling,
    pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties);
pub type PFN_vkQueueBindSparse = unsafe extern "C" fn(
    queue: VkQueue, bindInfoCount: uint32_t, pBindInfo: *const VkBindSparseInfo,
    fence: VkFence) -> VkResult;
pub type PFN_vkCreateFence = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkFenceCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> VkResult;
pub type PFN_vkDestroyFence = unsafe extern "C" fn(
    device: VkDevice, fence: VkFence, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkResetFences = unsafe extern "C" fn(
    device: VkDevice, fenceCount: uint32_t, pFences: *const VkFence) -> VkResult;
pub type PFN_vkGetFenceStatus = extern "C" fn(device: VkDevice, fence: VkFence) -> VkResult;
pub type PFN_vkWaitForFences = unsafe extern "C" fn(
    device: VkDevice, fenceCount: uint32_t, pFences: *const VkFence, waitAll: VkBool32,
    timeout: uint64_t) -> VkResult;
pub type PFN_vkCreateSemaphore = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkSemaphoreCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pSemaphore: *mut VkSemaphore) -> VkResult;
pub type PFN_vkDestroySemaphore = unsafe extern "C" fn(
    device: VkDevice, semaphore: VkSemaphore, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkCreateEvent = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkEventCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pEvent: *mut VkEvent) -> VkResult;
pub type PFN_vkDestroyEvent = unsafe extern "C" fn(
    device: VkDevice, event: VkEvent, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkGetEventStatus = extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult;
pub type PFN_vkSetEvent = extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult;
pub type PFN_vkResetEvent = extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult;
pub type PFN_vkCreateQueryPool = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkQueryPoolCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pQueryPool: *mut VkQueryPool) -> VkResult;
pub type PFN_vkDestroyQueryPool = unsafe extern "C" fn(
    device: VkDevice, queryPool: VkQueryPool, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkGetQueryPoolResults = unsafe extern "C" fn(
    device: VkDevice, queryPool: VkQueryPool, firstQuery: uint32_t, queryCount: uint32_t,
    dataSize: size_t, pData: *mut ::std::os::raw::c_void, stride: VkDeviceSize,
    flags: VkQueryResultFlags) -> VkResult;
pub type PFN_vkCreateBuffer = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkBufferCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pBuffer: *mut VkBuffer) -> VkResult;
pub type PFN_vkDestroyBuffer = unsafe extern "C" fn(
    device: VkDevice, buffer: VkBuffer, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkCreateBufferView = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkBufferViewCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pView: *mut VkBufferView) -> VkResult;
pub type PFN_vkDestroyBufferView = unsafe extern "C" fn(
    device: VkDevice, bufferView: VkBufferView, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkCreateImage = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkImageCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pImage: *mut VkImage) -> VkResult;
pub type PFN_vkDestroyImage = unsafe extern "C" fn(
    device: VkDevice, image: VkImage, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkGetImageSubresourceLayout = unsafe extern "C" fn(
    device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource,
    pLayout: *mut VkSubresourceLayout);
pub type PFN_vkCreateImageView = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkImageViewCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pView: *mut VkImageView) -> VkResult;
pub type PFN_vkDestroyImageView = unsafe extern "C" fn(
    device: VkDevice, imageView: VkImageView, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkCreateShaderModule = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pShaderModule: *mut VkShaderModule) -> VkResult;
pub type PFN_vkDestroyShaderModule = unsafe extern "C" fn(
    device: VkDevice, shaderModule: VkShaderModule, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkCreatePipelineCache = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkPipelineCacheCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pPipelineCache: *mut VkPipelineCache) -> VkResult;
pub type PFN_vkDestroyPipelineCache = unsafe extern "C" fn(
    device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkGetPipelineCacheData = unsafe extern "C" fn(
    device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *mut size_t,
    pData: *mut ::std::os::raw::c_void) -> VkResult;
pub type PFN_vkMergePipelineCaches = unsafe extern "C" fn(
    device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: uint32_t,
    pSrcCaches: *const VkPipelineCache) -> VkResult;
pub type PFN_vkCreateGraphicsPipelines = unsafe extern "C" fn(
    device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32_t,
    pCreateInfos: *const VkGraphicsPipelineCreateInfo, pAllocator: *const VkAllocationCallbacks,
    pPipelines: *mut VkPipeline) -> VkResult;
pub type PFN_vkCreateComputePipelines = unsafe extern "C" fn(
    device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32_t,
    pCreateInfos: *const VkComputePipelineCreateInfo, pAllocator: *const VkAllocationCallbacks,
    pPipelines: *mut VkPipeline) -> VkResult;
pub type PFN_vkDestroyPipeline = unsafe extern "C" fn(
    device: VkDevice, pipeline: VkPipeline, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkCreatePipelineLayout = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkPipelineLayoutCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pPipelineLayout: *mut VkPipelineLayout) -> VkResult;
pub type PFN_vkDestroyPipelineLayout =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           pipelineLayout:
                                           VkPipelineLayout,
                                           pAllocator:
                                           *const VkAllocationCallbacks)>;
pub type PFN_vkCreateSampler =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           pCreateInfo:
                                           *const VkSamplerCreateInfo,
                                           pAllocator:
                                           *const VkAllocationCallbacks,
                                           pSampler: *mut VkSampler)
                                           -> VkResult>;
pub type PFN_vkDestroySampler =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           sampler: VkSampler,
                                           pAllocator:
                                           *const VkAllocationCallbacks)>;
pub type PFN_vkCreateDescriptorSetLayout =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           pCreateInfo:
                                           *const VkDescriptorSetLayoutCreateInfo,
                                           pAllocator:
                                           *const VkAllocationCallbacks,
                                           pSetLayout:
                                           *mut VkDescriptorSetLayout)
                                           -> VkResult>;
pub type PFN_vkDestroyDescriptorSetLayout =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           descriptorSetLayout:
                                           VkDescriptorSetLayout,
                                           pAllocator:
                                           *const VkAllocationCallbacks)>;
pub type PFN_vkCreateDescriptorPool =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           pCreateInfo:
                                           *const VkDescriptorPoolCreateInfo,
                                           pAllocator:
                                           *const VkAllocationCallbacks,
                                           pDescriptorPool:
                                           *mut VkDescriptorPool)
                                           -> VkResult>;
pub type PFN_vkDestroyDescriptorPool =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           descriptorPool:
                                           VkDescriptorPool,
                                           pAllocator:
                                           *const VkAllocationCallbacks)>;
pub type PFN_vkResetDescriptorPool =
::std::option::Option<extern "C" fn(device: VkDevice,
                                    descriptorPool: VkDescriptorPool,
                                    flags: VkDescriptorPoolResetFlags)
                                    -> VkResult>;
pub type PFN_vkAllocateDescriptorSets =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           pAllocateInfo:
                                           *const VkDescriptorSetAllocateInfo,
                                           pDescriptorSets:
                                           *mut VkDescriptorSet)
                                           -> VkResult>;
pub type PFN_vkFreeDescriptorSets =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           descriptorPool:
                                           VkDescriptorPool,
                                           descriptorSetCount: uint32_t,
                                           pDescriptorSets:
                                           *const VkDescriptorSet)
                                           -> VkResult>;
pub type PFN_vkUpdateDescriptorSets =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           descriptorWriteCount: uint32_t,
                                           pDescriptorWrites:
                                           *const VkWriteDescriptorSet,
                                           descriptorCopyCount: uint32_t,
                                           pDescriptorCopies:
                                           *const VkCopyDescriptorSet)>;
pub type PFN_vkCreateFramebuffer =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           pCreateInfo:
                                           *const VkFramebufferCreateInfo,
                                           pAllocator:
                                           *const VkAllocationCallbacks,
                                           pFramebuffer:
                                           *mut VkFramebuffer)
                                           -> VkResult>;
pub type PFN_vkDestroyFramebuffer =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           framebuffer: VkFramebuffer,
                                           pAllocator:
                                           *const VkAllocationCallbacks)>;
pub type PFN_vkCreateRenderPass = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult;
pub type PFN_vkDestroyRenderPass = unsafe extern "C" fn(
    device: VkDevice, renderPass: VkRenderPass, pAllocator: *const VkAllocationCallbacks);
pub type PFN_vkGetRenderAreaGranularity = unsafe extern "C" fn(
    device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D);
pub type PFN_vkCreateCommandPool = unsafe extern "C" fn(
    device: VkDevice, pCreateInfo: *const VkCommandPoolCreateInfo,
    pAllocator: *const VkAllocationCallbacks, pCommandPool: *mut VkCommandPool) -> VkResult;
pub type PFN_vkDestroyCommandPool =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           commandPool: VkCommandPool,
                                           pAllocator:
                                           *const VkAllocationCallbacks)>;
pub type PFN_vkResetCommandPool =
::std::option::Option<extern "C" fn(device: VkDevice,
                                    commandPool: VkCommandPool,
                                    flags: VkCommandPoolResetFlags)
                                    -> VkResult>;
pub type PFN_vkAllocateCommandBuffers =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           pAllocateInfo:
                                           *const VkCommandBufferAllocateInfo,
                                           pCommandBuffers:
                                           *mut VkCommandBuffer)
                                           -> VkResult>;
pub type PFN_vkFreeCommandBuffers =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           commandPool: VkCommandPool,
                                           commandBufferCount: uint32_t,
                                           pCommandBuffers:
                                           *const VkCommandBuffer)>;
pub type PFN_vkBeginCommandBuffer =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           pBeginInfo:
                                           *const VkCommandBufferBeginInfo)
                                           -> VkResult>;
pub type PFN_vkEndCommandBuffer =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer)
    -> VkResult>;
pub type PFN_vkResetCommandBuffer =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    flags: VkCommandBufferResetFlags)
                                    -> VkResult>;
pub type PFN_vkCmdBindPipeline =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    pipelineBindPoint:
                                    VkPipelineBindPoint,
                                    pipeline: VkPipeline)>;
pub type PFN_vkCmdSetViewport =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           firstViewport: uint32_t,
                                           viewportCount: uint32_t,
                                           pViewports:
                                           *const VkViewport)>;
pub type PFN_vkCmdSetScissor =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           firstScissor: uint32_t,
                                           scissorCount: uint32_t,
                                           pScissors: *const VkRect2D)>;
pub type PFN_vkCmdSetLineWidth =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    lineWidth: f32)>;
pub type PFN_vkCmdSetDepthBias =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    depthBiasConstantFactor: f32,
                                    depthBiasClamp: f32,
                                    depthBiasSlopeFactor: f32)>;
pub type PFN_vkCmdSetBlendConstants =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    blendConstants: *mut f32)>;
pub type PFN_vkCmdSetDepthBounds =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    minDepthBounds: f32,
                                    maxDepthBounds: f32)>;
pub type PFN_vkCmdSetStencilCompareMask =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    faceMask: VkStencilFaceFlags,
                                    compareMask: uint32_t)>;
pub type PFN_vkCmdSetStencilWriteMask =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    faceMask: VkStencilFaceFlags,
                                    writeMask: uint32_t)>;
pub type PFN_vkCmdSetStencilReference =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    faceMask: VkStencilFaceFlags,
                                    reference: uint32_t)>;
pub type PFN_vkCmdBindDescriptorSets =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           pipelineBindPoint:
                                           VkPipelineBindPoint,
                                           layout: VkPipelineLayout,
                                           firstSet: uint32_t,
                                           descriptorSetCount: uint32_t,
                                           pDescriptorSets:
                                           *const VkDescriptorSet,
                                           dynamicOffsetCount: uint32_t,
                                           pDynamicOffsets:
                                           *const uint32_t)>;
pub type PFN_vkCmdBindIndexBuffer =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    buffer: VkBuffer,
                                    offset: VkDeviceSize,
                                    indexType: VkIndexType)>;
pub type PFN_vkCmdBindVertexBuffers =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           firstBinding: uint32_t,
                                           bindingCount: uint32_t,
                                           pBuffers: *const VkBuffer,
                                           pOffsets:
                                           *const VkDeviceSize)>;
pub type PFN_vkCmdDraw =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    vertexCount: uint32_t,
                                    instanceCount: uint32_t,
                                    firstVertex: uint32_t,
                                    firstInstance: uint32_t)>;
pub type PFN_vkCmdDrawIndexed =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    indexCount: uint32_t,
                                    instanceCount: uint32_t,
                                    firstIndex: uint32_t,
                                    vertexOffset: int32_t,
                                    firstInstance: uint32_t)>;
pub type PFN_vkCmdDrawIndirect =
::std::option::Option<extern "C" fn(
    commandBuffer: VkCommandBuffer,
    buffer: VkBuffer,
    offset: VkDeviceSize,
    drawCount: uint32_t,
    stride: uint32_t)>;
pub type PFN_vkCmdDrawIndexedIndirect =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    buffer: VkBuffer,
                                    offset: VkDeviceSize,
                                    drawCount: uint32_t,
                                    stride: uint32_t)>;
pub type PFN_vkCmdDispatch =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    x: uint32_t, y: uint32_t,
                                    z: uint32_t)>;
pub type PFN_vkCmdDispatchIndirect =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    buffer: VkBuffer,
                                    offset: VkDeviceSize)>;
pub type PFN_vkCmdCopyBuffer =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           srcBuffer: VkBuffer,
                                           dstBuffer: VkBuffer,
                                           regionCount: uint32_t,
                                           pRegions:
                                           *const VkBufferCopy)>;
pub type PFN_vkCmdCopyImage =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           srcImage: VkImage,
                                           srcImageLayout: VkImageLayout,
                                           dstImage: VkImage,
                                           dstImageLayout: VkImageLayout,
                                           regionCount: uint32_t,
                                           pRegions: *const VkImageCopy)>;
pub type PFN_vkCmdBlitImage =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           srcImage: VkImage,
                                           srcImageLayout: VkImageLayout,
                                           dstImage: VkImage,
                                           dstImageLayout: VkImageLayout,
                                           regionCount: uint32_t,
                                           pRegions: *const VkImageBlit,
                                           filter: VkFilter)>;
pub type PFN_vkCmdCopyBufferToImage =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           srcBuffer: VkBuffer,
                                           dstImage: VkImage,
                                           dstImageLayout: VkImageLayout,
                                           regionCount: uint32_t,
                                           pRegions:
                                           *const VkBufferImageCopy)>;
pub type PFN_vkCmdCopyImageToBuffer =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           srcImage: VkImage,
                                           srcImageLayout: VkImageLayout,
                                           dstBuffer: VkBuffer,
                                           regionCount: uint32_t,
                                           pRegions:
                                           *const VkBufferImageCopy)>;
pub type PFN_vkCmdUpdateBuffer =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           dstBuffer: VkBuffer,
                                           dstOffset: VkDeviceSize,
                                           dataSize: VkDeviceSize,
                                           pData: *const uint32_t)>;
pub type PFN_vkCmdFillBuffer =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    dstBuffer: VkBuffer,
                                    dstOffset: VkDeviceSize,
                                    size: VkDeviceSize, data: uint32_t)>;
pub type PFN_vkCmdClearColorImage =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           image: VkImage,
                                           imageLayout: VkImageLayout,
                                           pColor:
                                           *const VkClearColorValue,
                                           rangeCount: uint32_t,
                                           pRanges:
                                           *const VkImageSubresourceRange)>;
pub type PFN_vkCmdClearDepthStencilImage =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           image: VkImage,
                                           imageLayout: VkImageLayout,
                                           pDepthStencil:
                                           *const VkClearDepthStencilValue,
                                           rangeCount: uint32_t,
                                           pRanges:
                                           *const VkImageSubresourceRange)>;
pub type PFN_vkCmdClearAttachments =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           attachmentCount: uint32_t,
                                           pAttachments:
                                           *const VkClearAttachment,
                                           rectCount: uint32_t,
                                           pRects: *const VkClearRect)>;
pub type PFN_vkCmdResolveImage =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           srcImage: VkImage,
                                           srcImageLayout: VkImageLayout,
                                           dstImage: VkImage,
                                           dstImageLayout: VkImageLayout,
                                           regionCount: uint32_t,
                                           pRegions:
                                           *const VkImageResolve)>;
pub type PFN_vkCmdSetEvent =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    event: VkEvent,
                                    stageMask: VkPipelineStageFlags)>;
pub type PFN_vkCmdResetEvent =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    event: VkEvent,
                                    stageMask: VkPipelineStageFlags)>;
pub type PFN_vkCmdWaitEvents =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           eventCount: uint32_t,
                                           pEvents: *const VkEvent,
                                           srcStageMask:
                                           VkPipelineStageFlags,
                                           dstStageMask:
                                           VkPipelineStageFlags,
                                           memoryBarrierCount: uint32_t,
                                           pMemoryBarriers:
                                           *const VkMemoryBarrier,
                                           bufferMemoryBarrierCount:
                                           uint32_t,
                                           pBufferMemoryBarriers:
                                           *const VkBufferMemoryBarrier,
                                           imageMemoryBarrierCount:
                                           uint32_t,
                                           pImageMemoryBarriers:
                                           *const VkImageMemoryBarrier)>;
pub type PFN_vkCmdPipelineBarrier =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           srcStageMask:
                                           VkPipelineStageFlags,
                                           dstStageMask:
                                           VkPipelineStageFlags,
                                           dependencyFlags:
                                           VkDependencyFlags,
                                           memoryBarrierCount: uint32_t,
                                           pMemoryBarriers:
                                           *const VkMemoryBarrier,
                                           bufferMemoryBarrierCount:
                                           uint32_t,
                                           pBufferMemoryBarriers:
                                           *const VkBufferMemoryBarrier,
                                           imageMemoryBarrierCount:
                                           uint32_t,
                                           pImageMemoryBarriers:
                                           *const VkImageMemoryBarrier)>;
pub type PFN_vkCmdBeginQuery =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    queryPool: VkQueryPool,
                                    query: uint32_t,
                                    flags: VkQueryControlFlags)>;
pub type PFN_vkCmdEndQuery =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    queryPool: VkQueryPool,
                                    query: uint32_t)>;
pub type PFN_vkCmdResetQueryPool =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    queryPool: VkQueryPool,
                                    firstQuery: uint32_t,
                                    queryCount: uint32_t)>;
pub type PFN_vkCmdWriteTimestamp =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    pipelineStage:
                                    VkPipelineStageFlagBits,
                                    queryPool: VkQueryPool,
                                    query: uint32_t)>;
pub type PFN_vkCmdCopyQueryPoolResults =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    queryPool: VkQueryPool,
                                    firstQuery: uint32_t,
                                    queryCount: uint32_t,
                                    dstBuffer: VkBuffer,
                                    dstOffset: VkDeviceSize,
                                    stride: VkDeviceSize,
                                    flags: VkQueryResultFlags)>;
pub type PFN_vkCmdPushConstants =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           layout: VkPipelineLayout,
                                           stageFlags: VkShaderStageFlags,
                                           offset: uint32_t,
                                           size: uint32_t,
                                           pValues:
                                           *const ::std::os::raw::c_void)>;
pub type PFN_vkCmdBeginRenderPass =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           pRenderPassBegin:
                                           *const VkRenderPassBeginInfo,
                                           contents: VkSubpassContents)>;
pub type PFN_vkCmdNextSubpass =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer,
                                    contents: VkSubpassContents)>;
pub type PFN_vkCmdEndRenderPass =
::std::option::Option<extern "C" fn(commandBuffer: VkCommandBuffer)>;
pub type PFN_vkCmdExecuteCommands =
::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                           commandBufferCount: uint32_t,
                                           pCommandBuffers:
                                           *const VkCommandBuffer)>;

pub enum VkSurfaceKHR_T {}

pub type VkSurfaceKHR = *mut VkSurfaceKHR_T;

pub const VK_COLOR_SPACE_BEGIN_RANGE_KHR: VkColorSpaceKHR =
VkColorSpaceKHR::VK_COLORSPACE_SRGB_NONLINEAR_KHR;
pub const VK_COLOR_SPACE_END_RANGE_KHR: VkColorSpaceKHR =
VkColorSpaceKHR::VK_COLORSPACE_SRGB_NONLINEAR_KHR;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkColorSpaceKHR {
    VK_COLORSPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLOR_SPACE_RANGE_SIZE_KHR = 1,
    VK_COLOR_SPACE_MAX_ENUM_KHR = 2147483647,
}

pub const VK_PRESENT_MODE_BEGIN_RANGE_KHR: VkPresentModeKHR =
VkPresentModeKHR::VK_PRESENT_MODE_IMMEDIATE_KHR;
pub const VK_PRESENT_MODE_END_RANGE_KHR: VkPresentModeKHR =
VkPresentModeKHR::VK_PRESENT_MODE_FIFO_RELAXED_KHR;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_RANGE_SIZE_KHR = 4,
    VK_PRESENT_MODE_MAX_ENUM_KHR = 2147483647,
}

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 1,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 2,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 4,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 8,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 16,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 32,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 64,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 128,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 256,
    VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}

pub type VkSurfaceTransformFlagsKHR = VkFlags;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 2,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 4,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 8,
    VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}

pub type VkCompositeAlphaFlagsKHR = VkFlags;

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSurfaceCapabilitiesKHR {
    pub minImageCount: uint32_t,
    pub maxImageCount: uint32_t,
    pub currentExtent: VkExtent2D,
    pub minImageExtent: VkExtent2D,
    pub maxImageExtent: VkExtent2D,
    pub maxImageArrayLayers: uint32_t,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub currentTransform: VkSurfaceTransformFlagBitsKHR,
    pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
    pub supportedUsageFlags: VkImageUsageFlags,
}

impl ::std::default::Default for VkSurfaceCapabilitiesKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSurfaceFormatKHR {
    pub format: VkFormat,
    pub colorSpace: VkColorSpaceKHR,
}

impl ::std::default::Default for VkSurfaceFormatKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

pub type PFN_vkDestroySurfaceKHR =
::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                           surface: VkSurfaceKHR,
                                           pAllocator:
                                           *const VkAllocationCallbacks)>;
pub type PFN_vkGetPhysicalDeviceSurfaceSupportKHR =
::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                           VkPhysicalDevice,
                                           queueFamilyIndex: uint32_t,
                                           surface: VkSurfaceKHR,
                                           pSupported: *mut VkBool32)
                                           -> VkResult>;
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice,
    surface: VkSurfaceKHR,
    pSurfaceCapabilities: *mut VkSurfaceCapabilitiesKHR) -> VkResult;
pub type PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice,
    surface: VkSurfaceKHR,
    pSurfaceFormatCount: *mut uint32_t,
    pSurfaceFormats: *mut VkSurfaceFormatKHR) -> VkResult;
pub type PFN_vkGetPhysicalDeviceSurfacePresentModesKHR =
::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                           VkPhysicalDevice,
                                           surface: VkSurfaceKHR,
                                           pPresentModeCount:
                                           *mut uint32_t,
                                           pPresentModes:
                                           *mut VkPresentModeKHR)
                                           -> VkResult>;

pub enum VkSwapchainKHR_T {}

pub type VkSwapchainKHR = *mut VkSwapchainKHR_T;
pub type VkSwapchainCreateFlagsKHR = VkFlags;

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkSwapchainCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSwapchainCreateFlagsKHR,
    pub surface: VkSurfaceKHR,
    pub minImageCount: uint32_t,
    pub imageFormat: VkFormat,
    pub imageColorSpace: VkColorSpaceKHR,
    pub imageExtent: VkExtent2D,
    pub imageArrayLayers: uint32_t,
    pub imageUsage: VkImageUsageFlags,
    pub imageSharingMode: VkSharingMode,
    pub queueFamilyIndexCount: uint32_t,
    pub pQueueFamilyIndices: *const uint32_t,
    pub preTransform: VkSurfaceTransformFlagBitsKHR,
    pub compositeAlpha: VkCompositeAlphaFlagBitsKHR,
    pub presentMode: VkPresentModeKHR,
    pub clipped: VkBool32,
    pub oldSwapchain: VkSwapchainKHR,
}

impl ::std::default::Default for VkSwapchainCreateInfoKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: uint32_t,
    pub pWaitSemaphores: *const VkSemaphore,
    pub swapchainCount: uint32_t,
    pub pSwapchains: *const VkSwapchainKHR,
    pub pImageIndices: *const uint32_t,
    pub pResults: *mut VkResult,
}

impl ::std::default::Default for VkPresentInfoKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

pub type PFN_vkCreateSwapchainKHR = unsafe extern "C" fn(
    device: VkDevice,
    pCreateInfo: *const VkSwapchainCreateInfoKHR,
    pAllocator: *const VkAllocationCallbacks,
    pSwapchain: *mut VkSwapchainKHR) -> VkResult;
pub type PFN_vkDestroySwapchainKHR =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           swapchain: VkSwapchainKHR,
                                           pAllocator:
                                           *const VkAllocationCallbacks)>;
pub type PFN_vkGetSwapchainImagesKHR =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           swapchain: VkSwapchainKHR,
                                           pSwapchainImageCount:
                                           *mut uint32_t,
                                           pSwapchainImages: *mut VkImage)
                                           -> VkResult>;
pub type PFN_vkAcquireNextImageKHR =
::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                           swapchain: VkSwapchainKHR,
                                           timeout: uint64_t,
                                           semaphore: VkSemaphore,
                                           fence: VkFence,
                                           pImageIndex: *mut uint32_t)
                                           -> VkResult>;
pub type PFN_vkQueuePresentKHR =
::std::option::Option<unsafe extern "C" fn(queue: VkQueue,
                                           pPresentInfo:
                                           *const VkPresentInfoKHR)
                                           -> VkResult>;

pub enum VkDisplayKHR_T {}

pub type VkDisplayKHR = *mut VkDisplayKHR_T;

pub enum VkDisplayModeKHR_T {}

pub type VkDisplayModeKHR = *mut VkDisplayModeKHR_T;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 2,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 4,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 8,
    VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}

pub type VkDisplayPlaneAlphaFlagsKHR = VkFlags;
pub type VkDisplayModeCreateFlagsKHR = VkFlags;
pub type VkDisplaySurfaceCreateFlagsKHR = VkFlags;

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDisplayPropertiesKHR {
    pub display: VkDisplayKHR,
    pub displayName: *const ::std::os::raw::c_char,
    pub physicalDimensions: VkExtent2D,
    pub physicalResolution: VkExtent2D,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub planeReorderPossible: VkBool32,
    pub persistentContent: VkBool32,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkDisplayPropertiesKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDisplayModeParametersKHR {
    pub visibleRegion: VkExtent2D,
    pub refreshRate: uint32_t,
}

impl ::std::default::Default for VkDisplayModeParametersKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDisplayModePropertiesKHR {
    pub displayMode: VkDisplayModeKHR,
    pub parameters: VkDisplayModeParametersKHR,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkDisplayModePropertiesKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDisplayModeCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDisplayModeCreateFlagsKHR,
    pub parameters: VkDisplayModeParametersKHR,
}

impl ::std::default::Default for VkDisplayModeCreateInfoKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDisplayPlaneCapabilitiesKHR {
    pub supportedAlpha: VkDisplayPlaneAlphaFlagsKHR,
    pub minSrcPosition: VkOffset2D,
    pub maxSrcPosition: VkOffset2D,
    pub minSrcExtent: VkExtent2D,
    pub maxSrcExtent: VkExtent2D,
    pub minDstPosition: VkOffset2D,
    pub maxDstPosition: VkOffset2D,
    pub minDstExtent: VkExtent2D,
    pub maxDstExtent: VkExtent2D,
}

impl ::std::default::Default for VkDisplayPlaneCapabilitiesKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDisplayPlanePropertiesKHR {
    pub currentDisplay: VkDisplayKHR,
    pub currentStackIndex: uint32_t,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkDisplayPlanePropertiesKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDisplaySurfaceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDisplaySurfaceCreateFlagsKHR,
    pub displayMode: VkDisplayModeKHR,
    pub planeIndex: uint32_t,
    pub planeStackIndex: uint32_t,
    pub transform: VkSurfaceTransformFlagBitsKHR,
    pub globalAlpha: f32,
    pub alphaMode: VkDisplayPlaneAlphaFlagBitsKHR,
    pub imageExtent: VkExtent2D,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkDisplaySurfaceCreateInfoKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

pub type PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t,
    pProperties: *mut VkDisplayPropertiesKHR) -> VkResult;
pub type PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t,
    pProperties: *mut VkDisplayPlanePropertiesKHR) -> VkResult;
pub type PFN_vkGetDisplayPlaneSupportedDisplaysKHR = unsafe extern "C" fn(
    physicalDevice: VkPhysicalDevice, planeIndex: uint32_t, pDisplayCount: *mut uint32_t,
    pDisplays: *mut VkDisplayKHR) -> VkResult;
pub type PFN_vkGetDisplayModePropertiesKHR =
::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                           VkPhysicalDevice,
                                           display: VkDisplayKHR,
                                           pPropertyCount: *mut uint32_t,
                                           pProperties:
                                           *mut VkDisplayModePropertiesKHR)
                                           -> VkResult>;
pub type PFN_vkCreateDisplayModeKHR =
::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                           VkPhysicalDevice,
                                           display: VkDisplayKHR,
                                           pCreateInfo:
                                           *const VkDisplayModeCreateInfoKHR,
                                           pAllocator:
                                           *const VkAllocationCallbacks,
                                           pMode: *mut VkDisplayModeKHR)
                                           -> VkResult>;
pub type PFN_vkGetDisplayPlaneCapabilitiesKHR =
::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                           VkPhysicalDevice,
                                           mode: VkDisplayModeKHR,
                                           planeIndex: uint32_t,
                                           pCapabilities:
                                           *mut VkDisplayPlaneCapabilitiesKHR)
                                           -> VkResult>;
pub type PFN_vkCreateDisplayPlaneSurfaceKHR = unsafe extern "C" fn(
    instance: VkInstance, pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR,
    pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR) -> VkResult;

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDisplayPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcRect: VkRect2D,
    pub dstRect: VkRect2D,
    pub persistent: VkBool32,
    _bindgen_padding_0_: [u8; 4usize],
}

impl ::std::default::Default for VkDisplayPresentInfoKHR {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

pub type PFN_vkCreateSharedSwapchainsKHR = unsafe extern "C" fn(
    device: VkDevice, swapchainCount: uint32_t, pCreateInfos: *const VkSwapchainCreateInfoKHR,
    pAllocator: *const VkAllocationCallbacks, pSwapchains: *mut VkSwapchainKHR) -> VkResult;
pub enum VkDebugReportCallbackEXT_T {}
pub type VkDebugReportCallbackEXT = *mut VkDebugReportCallbackEXT_T;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT: VkDebugReportObjectTypeEXT = VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT: VkDebugReportObjectTypeEXT = VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = 29,
    VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 2147483647,
}

pub const VK_DEBUG_REPORT_ERROR_BEGIN_RANGE_EXT: VkDebugReportErrorEXT = VkDebugReportErrorEXT::VK_DEBUG_REPORT_ERROR_NONE_EXT;
pub const VK_DEBUG_REPORT_ERROR_END_RANGE_EXT: VkDebugReportErrorEXT = VkDebugReportErrorEXT::VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkDebugReportErrorEXT {
    VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
    VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,
    VK_DEBUG_REPORT_ERROR_RANGE_SIZE_EXT = 2,
    VK_DEBUG_REPORT_ERROR_MAX_ENUM_EXT = 2147483647,
}

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 1,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 2,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 4,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 8,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 16,
    VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 2147483647,
}

pub type VkDebugReportFlagsEXT = VkFlags;
pub type PFN_vkDebugReportCallbackEXT = unsafe extern "C" fn(
    flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT, object: uint64_t,
    location: size_t, messageCode: int32_t, pLayerPrefix: *const ::std::os::raw::c_char,
    pMessage: *const ::std::os::raw::c_char, pUserData: *mut c_void) -> VkBool32;

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct VkDebugReportCallbackCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDebugReportFlagsEXT,
    pub pfnCallback: PFN_vkDebugReportCallbackEXT,
    pub pUserData: *mut ::std::os::raw::c_void,
}

impl ::std::default::Default for VkDebugReportCallbackCreateInfoEXT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

pub type PFN_vkCreateDebugReportCallbackEXT = unsafe extern "C" fn(
    instance: VkInstance, pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT,
    pAllocator: *const VkAllocationCallbacks, pCallback: *mut VkDebugReportCallbackEXT) -> VkResult;

pub type PFN_vkDestroyDebugReportCallbackEXT = unsafe extern "C" fn(
    instance: VkInstance, callback: VkDebugReportCallbackEXT,
    pAllocator: *const VkAllocationCallbacks);

pub type PFN_vkDebugReportMessageEXT = unsafe extern "C" fn(
    instance: VkInstance, flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT,
    object: uint64_t, location: size_t, messageCode: int32_t,
    pLayerPrefix: *const ::std::os::raw::c_char, pMessage: *const ::std::os::raw::c_char);

#[cfg_attr(target_os = "linux", link(name = "vulkan", kind= "dylib"))]
#[cfg_attr(target_os = "windows", link(name = "vulkan-1", kind= "dylib"))]
#[cfg_attr(target_os = "android", link(name = "vulkan", kind= "dylib"))]
extern "C" {
    pub fn vkCreateInstance(
        pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks,
        pInstance: *mut VkInstance) -> VkResult;
    pub fn vkDestroyInstance(
        instance: VkInstance, pAllocator: *const VkAllocationCallbacks);
    pub fn vkEnumeratePhysicalDevices(
        instance: VkInstance, pPhysicalDeviceCount: *mut uint32_t,
        pPhysicalDevices: *mut VkPhysicalDevice) -> VkResult;
    pub fn vkGetPhysicalDeviceFeatures(
        physicalDevice: VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures);
    pub fn vkGetPhysicalDeviceFormatProperties(
        physicalDevice: VkPhysicalDevice, format: VkFormat,
        pFormatProperties: *mut VkFormatProperties);
    pub fn vkGetPhysicalDeviceImageFormatProperties(
        physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType,
        tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags,
        pImageFormatProperties: *mut VkImageFormatProperties) -> VkResult;
    pub fn vkGetPhysicalDeviceProperties(
        physicalDevice: VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties);
    pub fn vkGetPhysicalDeviceQueueFamilyProperties(
        physicalDevice: VkPhysicalDevice, pQueueFamilyPropertyCount: *mut uint32_t,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties);
    pub fn vkGetPhysicalDeviceMemoryProperties(
        physicalDevice: VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties);
    pub fn vkGetInstanceProcAddr(
        instance: VkInstance, pName: *const ::std::os::raw::c_char) -> PFN_vkVoidFunction;
    pub fn vkGetDeviceProcAddr(
        device: VkDevice, pName: *const ::std::os::raw::c_char) -> PFN_vkVoidFunction;
    pub fn vkCreateDevice(
        physicalDevice: VkPhysicalDevice, pCreateInfo: *const VkDeviceCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pDevice: *mut VkDevice) -> VkResult;
    pub fn vkDestroyDevice(device: VkDevice, pAllocator: *const VkAllocationCallbacks);
    pub fn vkEnumerateInstanceExtensionProperties(
        pLayerName: *const ::std::os::raw::c_char, pPropertyCount: *mut uint32_t,
        pProperties: *mut VkExtensionProperties) -> VkResult;
    pub fn vkEnumerateDeviceExtensionProperties(
        physicalDevice: VkPhysicalDevice, pLayerName: *const ::std::os::raw::c_char,
        pPropertyCount: *mut uint32_t, pProperties: *mut VkExtensionProperties) -> VkResult;
    pub fn vkEnumerateInstanceLayerProperties(
        pPropertyCount: *mut uint32_t, pProperties: *mut VkLayerProperties) -> VkResult;
    pub fn vkEnumerateDeviceLayerProperties(
        physicalDevice: VkPhysicalDevice, pPropertyCount: *mut uint32_t,
        pProperties: *mut VkLayerProperties) -> VkResult;
    pub fn vkGetDeviceQueue(
        device: VkDevice, queueFamilyIndex: uint32_t, queueIndex: uint32_t, pQueue: *mut VkQueue);
    pub fn vkQueueSubmit(
        queue: VkQueue, submitCount: uint32_t, pSubmits: *const VkSubmitInfo,
        fence: VkFence) -> VkResult;
    pub fn vkQueueWaitIdle(queue: VkQueue) -> VkResult;
    pub fn vkDeviceWaitIdle(device: VkDevice) -> VkResult;
    pub fn vkAllocateMemory(
        device: VkDevice, pAllocateInfo: *const VkMemoryAllocateInfo,
        pAllocator: *const VkAllocationCallbacks, pMemory: *mut VkDeviceMemory) -> VkResult;
    pub fn vkFreeMemory(
        device: VkDevice, memory: VkDeviceMemory, pAllocator: *const VkAllocationCallbacks);
    pub fn vkMapMemory(
        device: VkDevice, memory: VkDeviceMemory, offset: VkDeviceSize, size: VkDeviceSize,
        flags: VkMemoryMapFlags, ppData: *mut *mut ::std::os::raw::c_void) -> VkResult;
    pub fn vkUnmapMemory(device: VkDevice, memory: VkDeviceMemory);
    pub fn vkFlushMappedMemoryRanges(
        device: VkDevice, memoryRangeCount: uint32_t,
        pMemoryRanges: *const VkMappedMemoryRange) -> VkResult;
    pub fn vkInvalidateMappedMemoryRanges(
        device: VkDevice, memoryRangeCount: uint32_t,
        pMemoryRanges: *const VkMappedMemoryRange) -> VkResult;
    pub fn vkGetDeviceMemoryCommitment(
        device: VkDevice, memory: VkDeviceMemory, pCommittedMemoryInBytes: *mut VkDeviceSize);
    pub fn vkBindBufferMemory(
        device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize) -> VkResult;
    pub fn vkBindImageMemory(
        device: VkDevice, image: VkImage, memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize) -> VkResult;
    pub fn vkGetBufferMemoryRequirements(
        device: VkDevice, buffer: VkBuffer, pMemoryRequirements: *mut VkMemoryRequirements);
    pub fn vkGetImageMemoryRequirements(
        device: VkDevice, image: VkImage, pMemoryRequirements: *mut VkMemoryRequirements);
    pub fn vkGetImageSparseMemoryRequirements(
        device: VkDevice, image: VkImage, pSparseMemoryRequirementCount: *mut uint32_t,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements);
    pub fn vkGetPhysicalDeviceSparseImageFormatProperties(
        physicalDevice: VkPhysicalDevice, format: VkFormat, type_: VkImageType,
        samples: VkSampleCountFlagBits, usage: VkImageUsageFlags, tiling: VkImageTiling,
        pPropertyCount: *mut uint32_t, pProperties: *mut VkSparseImageFormatProperties);
    pub fn vkQueueBindSparse(
        queue: VkQueue, bindInfoCount: uint32_t, pBindInfo: *const VkBindSparseInfo,
        fence: VkFence) -> VkResult;
    pub fn vkCreateFence(
        device: VkDevice, pCreateInfo: *const VkFenceCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence) -> VkResult;
    pub fn vkDestroyFence(
        device: VkDevice, fence: VkFence, pAllocator: *const VkAllocationCallbacks);
    pub fn vkResetFences(
        device: VkDevice, fenceCount: uint32_t, pFences: *const VkFence) -> VkResult;
    pub fn vkGetFenceStatus(device: VkDevice, fence: VkFence) -> VkResult;
    pub fn vkWaitForFences(
        device: VkDevice, fenceCount: uint32_t, pFences: *const VkFence, waitAll: VkBool32,
        timeout: uint64_t) -> VkResult;
    pub fn vkCreateSemaphore(
        device: VkDevice, pCreateInfo: *const VkSemaphoreCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pSemaphore: *mut VkSemaphore) -> VkResult;
    pub fn vkDestroySemaphore(
        device: VkDevice, semaphore: VkSemaphore, pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateEvent(
        device: VkDevice, pCreateInfo: *const VkEventCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pEvent: *mut VkEvent) -> VkResult;
    pub fn vkDestroyEvent(
        device: VkDevice, event: VkEvent, pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetEventStatus(device: VkDevice, event: VkEvent) -> VkResult;
    pub fn vkSetEvent(device: VkDevice, event: VkEvent) -> VkResult;
    pub fn vkResetEvent(device: VkDevice, event: VkEvent) -> VkResult;
    pub fn vkCreateQueryPool(
        device: VkDevice, pCreateInfo: *const VkQueryPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pQueryPool: *mut VkQueryPool) -> VkResult;
    pub fn vkDestroyQueryPool(
        device: VkDevice, queryPool: VkQueryPool, pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetQueryPoolResults(
        device: VkDevice, queryPool: VkQueryPool, firstQuery: uint32_t, queryCount: uint32_t,
        dataSize: size_t, pData: *mut ::std::os::raw::c_void, stride: VkDeviceSize,
        flags: VkQueryResultFlags) -> VkResult;
    pub fn vkCreateBuffer(
        device: VkDevice, pCreateInfo: *const VkBufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pBuffer: *mut VkBuffer) -> VkResult;
    pub fn vkDestroyBuffer(
        device: VkDevice, buffer: VkBuffer, pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateBufferView(
        device: VkDevice, pCreateInfo: *const VkBufferViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pView: *mut VkBufferView) -> VkResult;
    pub fn vkDestroyBufferView(
        device: VkDevice, bufferView: VkBufferView, pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateImage(
        device: VkDevice, pCreateInfo: *const VkImageCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pImage: *mut VkImage) -> VkResult;
    pub fn vkDestroyImage(
        device: VkDevice, image: VkImage, pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetImageSubresourceLayout(
        device: VkDevice, image: VkImage, pSubresource: *const VkImageSubresource,
        pLayout: *mut VkSubresourceLayout);
    pub fn vkCreateImageView(
        device: VkDevice, pCreateInfo: *const VkImageViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pView: *mut VkImageView) -> VkResult;
    pub fn vkDestroyImageView(
        device: VkDevice, imageView: VkImageView, pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateShaderModule(
        device: VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pShaderModule: *mut VkShaderModule) -> VkResult;
    pub fn vkDestroyShaderModule(
        device: VkDevice, shaderModule: VkShaderModule, pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreatePipelineCache(
        device: VkDevice, pCreateInfo: *const VkPipelineCacheCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pPipelineCache: *mut VkPipelineCache) -> VkResult;
    pub fn vkDestroyPipelineCache(
        device: VkDevice, pipelineCache: VkPipelineCache, pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetPipelineCacheData(
        device: VkDevice, pipelineCache: VkPipelineCache, pDataSize: *mut size_t,
        pData: *mut ::std::os::raw::c_void) -> VkResult;
    pub fn vkMergePipelineCaches(
        device: VkDevice, dstCache: VkPipelineCache, srcCacheCount: uint32_t,
        pSrcCaches: *const VkPipelineCache) -> VkResult;
    pub fn vkCreateGraphicsPipelines(
        device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32_t,
        pCreateInfos: *const VkGraphicsPipelineCreateInfo, pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline) -> VkResult;
    pub fn vkCreateComputePipelines(
        device: VkDevice, pipelineCache: VkPipelineCache, createInfoCount: uint32_t,
        pCreateInfos: *const VkComputePipelineCreateInfo, pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline) -> VkResult;
    pub fn vkDestroyPipeline(
        device: VkDevice, pipeline: VkPipeline, pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreatePipelineLayout(
        device: VkDevice, pCreateInfo: *const VkPipelineLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineLayout: *mut VkPipelineLayout) -> VkResult;
    pub fn vkDestroyPipelineLayout(
        device: VkDevice, pipelineLayout: VkPipelineLayout,
        pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateSampler(
        device: VkDevice, pCreateInfo: *const VkSamplerCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pSampler: *mut VkSampler) -> VkResult;
    pub fn vkDestroySampler(
        device: VkDevice, sampler: VkSampler, pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateDescriptorSetLayout(
        device: VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSetLayout: *mut VkDescriptorSetLayout) -> VkResult;
    pub fn vkDestroyDescriptorSetLayout(
        device: VkDevice, descriptorSetLayout: VkDescriptorSetLayout,
        pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateDescriptorPool(
        device: VkDevice, pCreateInfo: *const VkDescriptorPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorPool: *mut VkDescriptorPool) -> VkResult;
    pub fn vkDestroyDescriptorPool(
        device: VkDevice, descriptorPool: VkDescriptorPool,
        pAllocator: *const VkAllocationCallbacks);
    pub fn vkResetDescriptorPool(device: VkDevice,
                                 descriptorPool: VkDescriptorPool,
                                 flags: VkDescriptorPoolResetFlags)
                                 -> VkResult;
    pub fn vkAllocateDescriptorSets(device: VkDevice,
                                    pAllocateInfo:
                                    *const VkDescriptorSetAllocateInfo,
                                    pDescriptorSets: *mut VkDescriptorSet)
                                    -> VkResult;
    pub fn vkFreeDescriptorSets(device: VkDevice,
                                descriptorPool: VkDescriptorPool,
                                descriptorSetCount: uint32_t,
                                pDescriptorSets: *const VkDescriptorSet)
                                -> VkResult;
    pub fn vkUpdateDescriptorSets(device: VkDevice,
                                  descriptorWriteCount: uint32_t,
                                  pDescriptorWrites:
                                  *const VkWriteDescriptorSet,
                                  descriptorCopyCount: uint32_t,
                                  pDescriptorCopies:
                                  *const VkCopyDescriptorSet);
    pub fn vkCreateFramebuffer(device: VkDevice,
                               pCreateInfo: *const VkFramebufferCreateInfo,
                               pAllocator: *const VkAllocationCallbacks,
                               pFramebuffer: *mut VkFramebuffer) -> VkResult;
    pub fn vkDestroyFramebuffer(device: VkDevice, framebuffer: VkFramebuffer,
                                pAllocator: *const VkAllocationCallbacks);
    pub fn vkCreateRenderPass(
        device: VkDevice, pCreateInfo: *const VkRenderPassCreateInfo,
        pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass) -> VkResult;
    pub fn vkDestroyRenderPass(
        device: VkDevice, renderPass: VkRenderPass, pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetRenderAreaGranularity(device: VkDevice,
                                      renderPass: VkRenderPass,
                                      pGranularity: *mut VkExtent2D);
    pub fn vkCreateCommandPool(device: VkDevice,
                               pCreateInfo: *const VkCommandPoolCreateInfo,
                               pAllocator: *const VkAllocationCallbacks,
                               pCommandPool: *mut VkCommandPool) -> VkResult;
    pub fn vkDestroyCommandPool(device: VkDevice, commandPool: VkCommandPool,
                                pAllocator: *const VkAllocationCallbacks);
    pub fn vkResetCommandPool(device: VkDevice, commandPool: VkCommandPool,
                              flags: VkCommandPoolResetFlags) -> VkResult;
    pub fn vkAllocateCommandBuffers(device: VkDevice,
                                    pAllocateInfo:
                                    *const VkCommandBufferAllocateInfo,
                                    pCommandBuffers: *mut VkCommandBuffer)
                                    -> VkResult;
    pub fn vkFreeCommandBuffers(device: VkDevice, commandPool: VkCommandPool,
                                commandBufferCount: uint32_t,
                                pCommandBuffers: *const VkCommandBuffer);
    pub fn vkBeginCommandBuffer(commandBuffer: VkCommandBuffer,
                                pBeginInfo: *const VkCommandBufferBeginInfo)
                                -> VkResult;
    pub fn vkEndCommandBuffer(commandBuffer: VkCommandBuffer) -> VkResult;
    pub fn vkResetCommandBuffer(commandBuffer: VkCommandBuffer,
                                flags: VkCommandBufferResetFlags) -> VkResult;
    pub fn vkCmdBindPipeline(commandBuffer: VkCommandBuffer,
                             pipelineBindPoint: VkPipelineBindPoint,
                             pipeline: VkPipeline);
    pub fn vkCmdSetViewport(commandBuffer: VkCommandBuffer,
                            firstViewport: uint32_t, viewportCount: uint32_t,
                            pViewports: *const VkViewport);
    pub fn vkCmdSetScissor(commandBuffer: VkCommandBuffer,
                           firstScissor: uint32_t, scissorCount: uint32_t,
                           pScissors: *const VkRect2D);
    pub fn vkCmdSetLineWidth(commandBuffer: VkCommandBuffer, lineWidth: f32);
    pub fn vkCmdSetDepthBias(commandBuffer: VkCommandBuffer,
                             depthBiasConstantFactor: f32,
                             depthBiasClamp: f32, depthBiasSlopeFactor: f32);
    pub fn vkCmdSetBlendConstants(commandBuffer: VkCommandBuffer,
                                  blendConstants: *mut f32);
    pub fn vkCmdSetDepthBounds(commandBuffer: VkCommandBuffer,
                               minDepthBounds: f32, maxDepthBounds: f32);
    pub fn vkCmdSetStencilCompareMask(commandBuffer: VkCommandBuffer,
                                      faceMask: VkStencilFaceFlags,
                                      compareMask: uint32_t);
    pub fn vkCmdSetStencilWriteMask(commandBuffer: VkCommandBuffer,
                                    faceMask: VkStencilFaceFlags,
                                    writeMask: uint32_t);
    pub fn vkCmdSetStencilReference(commandBuffer: VkCommandBuffer,
                                    faceMask: VkStencilFaceFlags,
                                    reference: uint32_t);
    pub fn vkCmdBindDescriptorSets(commandBuffer: VkCommandBuffer,
                                   pipelineBindPoint: VkPipelineBindPoint,
                                   layout: VkPipelineLayout,
                                   firstSet: uint32_t,
                                   descriptorSetCount: uint32_t,
                                   pDescriptorSets: *const VkDescriptorSet,
                                   dynamicOffsetCount: uint32_t,
                                   pDynamicOffsets: *const uint32_t);
    pub fn vkCmdBindIndexBuffer(commandBuffer: VkCommandBuffer,
                                buffer: VkBuffer, offset: VkDeviceSize,
                                indexType: VkIndexType);
    pub fn vkCmdBindVertexBuffers(commandBuffer: VkCommandBuffer,
                                  firstBinding: uint32_t,
                                  bindingCount: uint32_t,
                                  pBuffers: *const VkBuffer,
                                  pOffsets: *const VkDeviceSize);
    pub fn vkCmdDraw(commandBuffer: VkCommandBuffer, vertexCount: uint32_t,
                     instanceCount: uint32_t, firstVertex: uint32_t,
                     firstInstance: uint32_t);
    pub fn vkCmdDrawIndexed(commandBuffer: VkCommandBuffer,
                            indexCount: uint32_t, instanceCount: uint32_t,
                            firstIndex: uint32_t, vertexOffset: int32_t,
                            firstInstance: uint32_t);
    pub fn vkCmdDrawIndirect(commandBuffer: VkCommandBuffer, buffer: VkBuffer,
                             offset: VkDeviceSize, drawCount: uint32_t,
                             stride: uint32_t);
    pub fn vkCmdDrawIndexedIndirect(commandBuffer: VkCommandBuffer,
                                    buffer: VkBuffer, offset: VkDeviceSize,
                                    drawCount: uint32_t, stride: uint32_t);
    pub fn vkCmdDispatch(commandBuffer: VkCommandBuffer, x: uint32_t,
                         y: uint32_t, z: uint32_t);
    pub fn vkCmdDispatchIndirect(commandBuffer: VkCommandBuffer,
                                 buffer: VkBuffer, offset: VkDeviceSize);
    pub fn vkCmdCopyBuffer(commandBuffer: VkCommandBuffer,
                           srcBuffer: VkBuffer, dstBuffer: VkBuffer,
                           regionCount: uint32_t,
                           pRegions: *const VkBufferCopy);
    pub fn vkCmdCopyImage(commandBuffer: VkCommandBuffer, srcImage: VkImage,
                          srcImageLayout: VkImageLayout, dstImage: VkImage,
                          dstImageLayout: VkImageLayout,
                          regionCount: uint32_t,
                          pRegions: *const VkImageCopy);
    pub fn vkCmdBlitImage(commandBuffer: VkCommandBuffer, srcImage: VkImage,
                          srcImageLayout: VkImageLayout, dstImage: VkImage,
                          dstImageLayout: VkImageLayout,
                          regionCount: uint32_t, pRegions: *const VkImageBlit,
                          filter: VkFilter);
    pub fn vkCmdCopyBufferToImage(commandBuffer: VkCommandBuffer,
                                  srcBuffer: VkBuffer, dstImage: VkImage,
                                  dstImageLayout: VkImageLayout,
                                  regionCount: uint32_t,
                                  pRegions: *const VkBufferImageCopy);
    pub fn vkCmdCopyImageToBuffer(commandBuffer: VkCommandBuffer,
                                  srcImage: VkImage,
                                  srcImageLayout: VkImageLayout,
                                  dstBuffer: VkBuffer, regionCount: uint32_t,
                                  pRegions: *const VkBufferImageCopy);
    pub fn vkCmdUpdateBuffer(commandBuffer: VkCommandBuffer,
                             dstBuffer: VkBuffer, dstOffset: VkDeviceSize,
                             dataSize: VkDeviceSize, pData: *const uint32_t);
    pub fn vkCmdFillBuffer(commandBuffer: VkCommandBuffer,
                           dstBuffer: VkBuffer, dstOffset: VkDeviceSize,
                           size: VkDeviceSize, data: uint32_t);
    pub fn vkCmdClearColorImage(commandBuffer: VkCommandBuffer,
                                image: VkImage, imageLayout: VkImageLayout,
                                pColor: *const VkClearColorValue,
                                rangeCount: uint32_t,
                                pRanges: *const VkImageSubresourceRange);
    pub fn vkCmdClearDepthStencilImage(commandBuffer: VkCommandBuffer,
                                       image: VkImage,
                                       imageLayout: VkImageLayout,
                                       pDepthStencil:
                                       *const VkClearDepthStencilValue,
                                       rangeCount: uint32_t,
                                       pRanges:
                                       *const VkImageSubresourceRange);
    pub fn vkCmdClearAttachments(commandBuffer: VkCommandBuffer,
                                 attachmentCount: uint32_t,
                                 pAttachments: *const VkClearAttachment,
                                 rectCount: uint32_t,
                                 pRects: *const VkClearRect);
    pub fn vkCmdResolveImage(commandBuffer: VkCommandBuffer,
                             srcImage: VkImage, srcImageLayout: VkImageLayout,
                             dstImage: VkImage, dstImageLayout: VkImageLayout,
                             regionCount: uint32_t,
                             pRegions: *const VkImageResolve);
    pub fn vkCmdSetEvent(commandBuffer: VkCommandBuffer, event: VkEvent,
                         stageMask: VkPipelineStageFlags);
    pub fn vkCmdResetEvent(commandBuffer: VkCommandBuffer, event: VkEvent,
                           stageMask: VkPipelineStageFlags);
    pub fn vkCmdWaitEvents(commandBuffer: VkCommandBuffer,
                           eventCount: uint32_t, pEvents: *const VkEvent,
                           srcStageMask: VkPipelineStageFlags,
                           dstStageMask: VkPipelineStageFlags,
                           memoryBarrierCount: uint32_t,
                           pMemoryBarriers: *const VkMemoryBarrier,
                           bufferMemoryBarrierCount: uint32_t,
                           pBufferMemoryBarriers:
                           *const VkBufferMemoryBarrier,
                           imageMemoryBarrierCount: uint32_t,
                           pImageMemoryBarriers: *const VkImageMemoryBarrier);
    pub fn vkCmdPipelineBarrier(commandBuffer: VkCommandBuffer,
                                srcStageMask: VkPipelineStageFlags,
                                dstStageMask: VkPipelineStageFlags,
                                dependencyFlags: VkDependencyFlags,
                                memoryBarrierCount: uint32_t,
                                pMemoryBarriers: *const VkMemoryBarrier,
                                bufferMemoryBarrierCount: uint32_t,
                                pBufferMemoryBarriers:
                                *const VkBufferMemoryBarrier,
                                imageMemoryBarrierCount: uint32_t,
                                pImageMemoryBarriers:
                                *const VkImageMemoryBarrier);
    pub fn vkCmdBeginQuery(commandBuffer: VkCommandBuffer,
                           queryPool: VkQueryPool, query: uint32_t,
                           flags: VkQueryControlFlags);
    pub fn vkCmdEndQuery(commandBuffer: VkCommandBuffer,
                         queryPool: VkQueryPool, query: uint32_t);
    pub fn vkCmdResetQueryPool(commandBuffer: VkCommandBuffer,
                               queryPool: VkQueryPool, firstQuery: uint32_t,
                               queryCount: uint32_t);
    pub fn vkCmdWriteTimestamp(commandBuffer: VkCommandBuffer,
                               pipelineStage: VkPipelineStageFlagBits,
                               queryPool: VkQueryPool, query: uint32_t);
    pub fn vkCmdCopyQueryPoolResults(
        commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, firstQuery: uint32_t,
        queryCount: uint32_t, dstBuffer: VkBuffer, dstOffset: VkDeviceSize, stride: VkDeviceSize,
        flags: VkQueryResultFlags);
    pub fn vkCmdPushConstants(
        commandBuffer: VkCommandBuffer, layout: VkPipelineLayout, stageFlags: VkShaderStageFlags,
        offset: uint32_t, size: uint32_t, pValues: *const ::std::os::raw::c_void);
    pub fn vkCmdBeginRenderPass(
        commandBuffer: VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo,
        contents: VkSubpassContents);
    pub fn vkCmdNextSubpass(
        commandBuffer: VkCommandBuffer, contents: VkSubpassContents);
    pub fn vkCmdEndRenderPass(commandBuffer: VkCommandBuffer);
    pub fn vkCmdExecuteCommands(
        commandBuffer: VkCommandBuffer, commandBufferCount: uint32_t,
        pCommandBuffers: *const VkCommandBuffer);
    pub fn vkDestroySurfaceKHR(
        instance: VkInstance, surface: VkSurfaceKHR, pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetPhysicalDeviceSurfaceSupportKHR(
        physicalDevice: VkPhysicalDevice,
        queueFamilyIndex: uint32_t,
        surface: VkSurfaceKHR,
        pSupported: *mut VkBool32) -> VkResult;
    pub fn vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilitiesKHR) -> VkResult;
    pub fn vkGetPhysicalDeviceSurfaceFormatsKHR(
        physicalDevice: VkPhysicalDevice, surface: VkSurfaceKHR,
        pSurfaceFormatCount: *mut uint32_t, pSurfaceFormats: *mut VkSurfaceFormatKHR) -> VkResult;
    pub fn vkGetPhysicalDeviceSurfacePresentModesKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pPresentModeCount: *mut uint32_t,
        pPresentModes: *mut VkPresentModeKHR) -> VkResult;
    pub fn vkCreateSwapchainKHR(
        device: VkDevice,
        pCreateInfo: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchain: *mut VkSwapchainKHR) -> VkResult;
    pub fn vkDestroySwapchainKHR(
        device: VkDevice, swapchain: VkSwapchainKHR, pAllocator: *const VkAllocationCallbacks);
    pub fn vkGetSwapchainImagesKHR(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pSwapchainImageCount: *mut uint32_t,
        pSwapchainImages: *mut VkImage) -> VkResult;
    pub fn vkAcquireNextImageKHR(device: VkDevice, swapchain: VkSwapchainKHR,
                                 timeout: uint64_t, semaphore: VkSemaphore,
                                 fence: VkFence, pImageIndex: *mut uint32_t)
                                 -> VkResult;
    pub fn vkQueuePresentKHR(queue: VkQueue,
                             pPresentInfo: *const VkPresentInfoKHR)
                             -> VkResult;
    pub fn vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice:
                                                   VkPhysicalDevice,
                                                   pPropertyCount:
                                                   *mut uint32_t,
                                                   pProperties:
                                                   *mut VkDisplayPropertiesKHR)
                                                   -> VkResult;
    pub fn vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice:
                                                        VkPhysicalDevice,
                                                        pPropertyCount:
                                                        *mut uint32_t,
                                                        pProperties:
                                                        *mut VkDisplayPlanePropertiesKHR)
                                                        -> VkResult;
    pub fn vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice:
                                                 VkPhysicalDevice,
                                                 planeIndex: uint32_t,
                                                 pDisplayCount: *mut uint32_t,
                                                 pDisplays: *mut VkDisplayKHR)
                                                 -> VkResult;
    pub fn vkGetDisplayModePropertiesKHR(physicalDevice: VkPhysicalDevice,
                                         display: VkDisplayKHR,
                                         pPropertyCount: *mut uint32_t,
                                         pProperties:
                                         *mut VkDisplayModePropertiesKHR)
                                         -> VkResult;
    pub fn vkCreateDisplayModeKHR(physicalDevice: VkPhysicalDevice,
                                  display: VkDisplayKHR,
                                  pCreateInfo:
                                  *const VkDisplayModeCreateInfoKHR,
                                  pAllocator: *const VkAllocationCallbacks,
                                  pMode: *mut VkDisplayModeKHR) -> VkResult;
    pub fn vkGetDisplayPlaneCapabilitiesKHR(physicalDevice: VkPhysicalDevice,
                                            mode: VkDisplayModeKHR,
                                            planeIndex: uint32_t,
                                            pCapabilities:
                                            *mut VkDisplayPlaneCapabilitiesKHR)
                                            -> VkResult;
    pub fn vkCreateDisplayPlaneSurfaceKHR(instance: VkInstance,
                                          pCreateInfo:
                                          *const VkDisplaySurfaceCreateInfoKHR,
                                          pAllocator:
                                          *const VkAllocationCallbacks,
                                          pSurface: *mut VkSurfaceKHR)
                                          -> VkResult;
    pub fn vkCreateSharedSwapchainsKHR(device: VkDevice,
                                       swapchainCount: uint32_t,
                                       pCreateInfos:
                                       *const VkSwapchainCreateInfoKHR,
                                       pAllocator:
                                       *const VkAllocationCallbacks,
                                       pSwapchains: *mut VkSwapchainKHR)
                                       -> VkResult;
    pub fn vkCreateDebugReportCallbackEXT(
        instance: VkInstance, pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pCallback: *mut VkDebugReportCallbackEXT) -> VkResult;
    pub fn vkDestroyDebugReportCallbackEXT(
        instance: VkInstance, callback: VkDebugReportCallbackEXT,
        pAllocator: *const VkAllocationCallbacks);
    pub fn vkDebugReportMessageEXT(
        instance: VkInstance, flags: VkDebugReportFlagsEXT, objectType: VkDebugReportObjectTypeEXT,
        object: uint64_t, location: size_t, messageCode: int32_t,
        pLayerPrefix:*const ::std::os::raw::c_char, pMessage: *const ::std::os::raw::c_char);
}

pub fn vkMakeVersion(major: u32, minor: u32, patch: u32) -> u32 {
    (major << 22) | (minor << 12) | patch
}

pub const VK_SUBPASS_EXTERNAL: u32 = !0u32;

#[macro_export] macro_rules! vulkan_check {
    ( $x:expr ) => {
        unsafe {
            match $x {
                VkResult::VK_SUCCESS => {},
				VkResult::VK_NOT_READY => { logerr!("VK_NOT_READY") },
			    VkResult::VK_TIMEOUT => { logerr!("VK_TIMEOUT") },
			    VkResult::VK_EVENT_SET => { logerr!("VK_EVENT_SET") },
			    VkResult::VK_EVENT_RESET => { logerr!("VK_EVENT_RESET") },
			    VkResult::VK_INCOMPLETE => { logerr!("VK_INCOMPLETE") },
			    VkResult::VK_ERROR_OUT_OF_HOST_MEMORY => { logerr!("VK_ERROR_OUT_OF_HOST_MEMORY") },
			    VkResult::VK_ERROR_OUT_OF_DEVICE_MEMORY => { logerr!("VK_ERROR_OUT_OF_DEVICE_MEMORY") },
			    VkResult::VK_ERROR_INITIALIZATION_FAILED => { logerr!("VK_ERROR_INITIALIZATION_FAILED") },
			    VkResult::VK_ERROR_DEVICE_LOST => { logerr!("VK_ERROR_DEVICE_LOST") },
			    VkResult::VK_ERROR_MEMORY_MAP_FAILED => { logerr!("VK_ERROR_MEMORY_MAP_FAILED") },
			    VkResult::VK_ERROR_LAYER_NOT_PRESENT => { logerr!("VK_ERROR_LAYER_NOT_PRESENT") },
			    VkResult::VK_ERROR_EXTENSION_NOT_PRESENT => { logerr!("VK_ERROR_EXTENSION_NOT_PRESENT") },
			    VkResult::VK_ERROR_FEATURE_NOT_PRESENT => { logerr!("VK_ERROR_FEATURE_NOT_PRESENT") },
			    VkResult::VK_ERROR_INCOMPATIBLE_DRIVER => { logerr!("VK_ERROR_INCOMPATIBLE_DRIVER") },
			    VkResult::VK_ERROR_TOO_MANY_OBJECTS => { logerr!("VK_ERROR_TOO_MANY_OBJECTS") },
			    VkResult::VK_ERROR_FORMAT_NOT_SUPPORTED => { logerr!("VK_ERROR_FORMAT_NOT_SUPPORTED") },
			    VkResult::VK_ERROR_SURFACE_LOST_KHR => { logerr!("VK_ERROR_SURFACE_LOST_KHR") },
			    VkResult::VK_ERROR_NATIVE_WINDOW_IN_USE_KHR => { logerr!("VK_ERROR_NATIVE_WINDOW_IN_USE_KHR") },
			    VkResult::VK_SUBOPTIMAL_KHR => { logerr!("VK_SUBOPTIMAL_KHR") },
			    VkResult::VK_ERROR_OUT_OF_DATE_KHR => { logerr!("VK_ERROR_OUT_OF_DATE_KHR") },
			    VkResult::VK_ERROR_INCOMPATIBLE_DISPLAY_KHR => { logerr!("VK_ERROR_INCOMPATIBLE_DISPLAY_KHR") },
			    VkResult::VK_ERROR_VALIDATION_FAILED_EXT => { logerr!("VK_ERROR_VALIDATION_FAILED_EXT") },
			    VkResult::VK_ERROR_INVALID_SHADER_NV => { logerr!("VK_ERROR_INVALID_SHADER_NV") },
			    VkResult::VK_RESULT_RANGE_SIZE => { logerr!("VK_RESULT_RANGE_SIZE") },
			    VkResult::VK_RESULT_MAX_ENUM => { logerr!("VK_RESULT_MAX_ENUM") },
				// _ => { logerr!("Unknown error") },
            }
        }
    };
}